<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java高级教程</title>
      <link href="/2020/04/23/java-gao-ji-jiao-cheng/"/>
      <url>/2020/04/23/java-gao-ji-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-数据结构"><a href="#Java-数据结构" class="headerlink" title="Java 数据结构"></a>Java 数据结构</h2><p>Java工具包提供了强大的数据结构。在Java中的数据结构主要包括以下几种接口和类：</p><ul><li>枚举（Enumeration）</li><li>位集合（BitSet）</li><li>向量（Vector）</li><li>栈（Stack）</li><li>字典（Dictionary）</li><li>哈希表（Hashtable）</li><li>属性（Properties）</li></ul><p>以上这些类是传统遗留的，在Java2中引入了一种新的框架-集合框架(Collection)，我们后面再讨论。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 面向对象</title>
      <link href="/2020/04/19/java-xue-xi-san/"/>
      <url>/2020/04/19/java-xue-xi-san/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-继承"><a href="#Java-继承" class="headerlink" title="Java 继承"></a>Java 继承</h2><p>继承是java面向对象编程技术的一块基石，因为它允许<strong>创建分等级层次的类。</strong></p><p><strong>继承就是<code>子类继承父类的特征和行为</code>，使得<code>类对象（实例）具有父类的实例域和方法</code>，或<code>子类从父类继承方法</code>，使得<code>子类具有父类相同的行为</code>。</strong></p><h3 id="生活中的继承："><a href="#生活中的继承：" class="headerlink" title="生活中的继承："></a>生活中的继承：</h3><img src="//www.runoob.com/wp-content/uploads/2013/12/14B0951E-FC75-47A3-B611-4E1883887339.jpg"><p>虽然食草动物和食肉动物都是属于动物，但是两者的属性和行为上有差别，所以<strong>子类会具有<code>父类的一般特性</code>也会具有<code>自身的特性</code>。</strong></p><h3 id="类的继承格式"><a href="#类的继承格式" class="headerlink" title="类的继承格式"></a>类的继承格式</h3><p>在 Java 中通过 <strong><code>extends</code> 关键字可以申明<code>一个类是从另外一个类继承而来</code>的</strong>，一般形式如下：</p><pre><code>class 父类 {}class 子类 extends 父类 {}</code></pre><h3 id="为什么需要继承"><a href="#为什么需要继承" class="headerlink" title="为什么需要继承"></a>为什么需要继承</h3><p>开发动物类，其中动物分别为企鹅以及老鼠，要求如下：</p><ul><li>企鹅：属性（姓名，id），方法（吃，睡，自我介绍）</li><li>老鼠：属性（姓名，id），方法（吃，睡，自我介绍）</li></ul><p>从需求我们可以看到两个动物拥有相同的属性和方法，使用继承，将两段代码中相同的部分提取出来组成一个父类：</p><p><strong>公共父类：</strong></p><pre><code>public class Animal {     private String name;      private int id;     public Animal(String myName, int myid) {         name = myName;         id = myid;    }     public void eat(){         System.out.println(name+"正在吃");     }    public void sleep(){        System.out.println(name+"正在睡");    }    public void introduction() {         System.out.println("大家好！我是"         + id + "号" + name + ".");     } }</code></pre><p><strong>这个<code>Animal类</code>就可以作为一个<code>父类</code>，然后<code>企鹅类和老鼠类继承这个类</code>之后，就<code>具有父类当中的属性和方法</code>，子类就不会存在重复的代码，<code>维护性也提高</code>，<code>代码也更加简洁</code>，<code>提高代码的复用性</code>（复用性主要是可以多次使用，不用再多次写同样的代码） 继承之后的代码：</strong></p><p><strong>企鹅类：</strong></p><pre><code>public class Penguin extends Animal {     public Penguin(String myName, int myid) {         super(myName, myid);  //调用父类构造方法    } }</code></pre><p><strong>老鼠类：</strong></p><pre><code>public class Mouse extends Animal {     public Mouse(String myName, int myid) {         super(myName, myid);     } }</code></pre><h3 id="继承类型"><a href="#继承类型" class="headerlink" title="继承类型"></a>继承类型</h3><p>需要注意的是 <strong>Java <code>不支持多继承</code>，但<code>支持多重继承</code>。</strong></p><img src="https://www.runoob.com/wp-content/uploads/2013/12/types_of_inheritance-1.png"><h3 id="继承的特性"><a href="#继承的特性" class="headerlink" title="继承的特性"></a>继承的特性</h3><ul><li><strong>子类拥有<code>父类非 private 的属性、方法</code>。</strong></li><li><strong>子类可以拥有<code>自己的属性和方法</code>，即子类<code>可以对父类进行扩展</code>。</strong></li><li><strong>子类可以用<code>自己的方式实现父类的方法</code>,即方法的重写（覆盖）</strong></li><li><strong>Java 的继承是单继承，但是可以多重继承</strong>，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。</li><li><strong><code>提高了类之间的耦合性</code>（<code>继承的缺点</code>，耦合度高就会造成<code>代码之间的联系越紧密</code>，代码<code>独立性越差</code>）</strong>。</li></ul><h3 id="继承关键字"><a href="#继承关键字" class="headerlink" title="继承关键字"></a>继承关键字</h3><p><strong>继承可以使用 <code>extends</code> 和 <code>implements</code> 这两个关键字来<code>实现继承</code>，而且<code>所有的类都是继承于 java.lang.Object</code>，当一个类<code>没有继承的两个关键字</code>，则<code>默认继承object</code>（这个类在 java.lang 包中，所以不需要 import）祖先类。</strong></p><h4 id="extends关键字-用于类的继承"><a href="#extends关键字-用于类的继承" class="headerlink" title="extends关键字 (用于类的继承)"></a>extends关键字 (用于类的继承)</h4><p>在 Java 中，<strong>类的继承是单一继承</strong>，也就是说，<strong>一个子类只能拥有一个父类，所以 extends 只能继承一个类。</strong></p><pre><code>public class Animal {     private String name;       private int id;     public Animal(String myName, String myid) {         //初始化属性值    }     public void eat() {  //吃东西方法的具体实现  }     public void sleep() { //睡觉方法的具体实现  } } public class Penguin  extends  Animal{ }</code></pre><h4 id="implements关键字-用于接口的继承"><a href="#implements关键字-用于接口的继承" class="headerlink" title="implements关键字 (用于接口的继承)"></a>implements关键字 (用于接口的继承)</h4><p><strong>使用 <code>implements</code> 关键字可以变相的使java具有多继承的特性，使用范围为<code>类继承接口</code>的情况，<code>可以同时继承多个接口</code>（接口跟接口之间<code>采用逗号分隔</code>）。</strong></p><pre><code>public interface A {    public void eat();    public void sleep();}public interface B {    public void show();}public class C implements A,B {}</code></pre><h3 id="super-与-this-关键字"><a href="#super-与-this-关键字" class="headerlink" title="super 与 this 关键字"></a>super 与 this 关键字</h3><p><strong>super关键字</strong>：我们可以通过super关键字来实现对父类成员的访问，<strong>用来引用<code>当前对象的父类</code></strong>。</p><p><strong>this关键字</strong>：<strong><code>指向自己</code>的引用。</strong></p><p><strong>实例</strong></p><pre><code>class Animal {  void eat() {    System.out.println("animal : eat");  }}class Dog extends Animal {  void eat() {    System.out.println("dog : eat");  }  void eatTest() {    this.eat();   // this 调用自己的方法    super.eat();  // super 调用父类方法  }}public class Test {  public static void main(String[] args) {    Animal a = new Animal();    a.eat();    Dog d = new Dog();    d.eatTest();  }}</code></pre><p>输出结果为：</p><pre><code>animal : eatdog : eatanimal : eat</code></pre><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p><strong><code>final</code> 关键字声明类可以<code>把类定义为不能继承的</code>，即<code>最终类</code>；或者用于<code>修饰方法</code>，该方法可以继承，但<code>不能被子类重写</code>：</strong></p><ul><li>声明<strong>类</strong>：<pre><code>final class 类名 {//类体}</code></pre></li><li>声明<strong>方法</strong>：<pre><code>修饰符(public/private/default/protected) final 返回值类型 方法名(){//方法体}</code></pre></li></ul><p>注:<strong><code>实例变量</code>也可以被定义为 final，被定义为 final 的变量<code>不能被修改,且要指定初始值</code>。</strong>被声明为 <code>final</code> 类的<code>方法自动地声明为 final</code>，但是实例变量并不是 final</p><h3 id="构造器-构造方法，构造函数-非常重要"><a href="#构造器-构造方法，构造函数-非常重要" class="headerlink" title="构造器 (构造方法，构造函数)(非常重要)"></a>构造器 (构造方法，构造函数)(非常重要)</h3><ul><li><strong>子类是<code>不继承父类的构造器</code>（构造方法或者构造函数）的，它<code>只是调用（隐式或显式）</code>。</strong></li><li><strong>如果父类的构造器<code>带有参数</code>且<code>没有无参构造器</code>的话，则<code>必须在子类的构造器中显式地通过 super 关键字调用</code>父类的构造器并<code>配以适当的参数列表</code>。</strong></li><li><strong>如果父类构造器<code>没有参数</code>，则在<code>子类的构造器中不需要使用 super 关键字调用</code>父类构造器，<code>系统会自动调用</code>父类的<code>无参构造器</code>。</strong></li><li><strong>如果<code>存在super 语句</code>必须是<code>子类构造方法的第一条语句</code></strong>。</li><li><strong>如果父类中<code>不含 默认构造函数（就是 类名() ）</code>，那么子类中的<code>super()语句就会执行失败</code>，系统就会报错。一般 <code>默认构造函数</code> 编译时会<code>自动添加</code>，但<code>如果类中已经有一个构造函数</code>时，就<code>不会添加</code>。</strong></li><li><strong>子类的<code>所有构造方法</code>内部， <code>第一行</code>会<code>（隐式）自动调用父类的无参构造函数super()</code>；</strong></li><li><strong>如果<code>子类构造方法第一行显式调用</code>了父类构造方法，系统就<code>不再调用无参的super()</code>了。</strong></li></ul><pre><code>class SuperClass {  private int n;  SuperClass(){    System.out.println("SuperClass()");  }  SuperClass(int n) {    System.out.println("SuperClass(int n)");    this.n = n;  }}// SubClass 类继承class SubClass extends SuperClass{  private int n;  SubClass(){ // 自动调用父类的无参数构造器    System.out.println("SubClass");  }    public SubClass(int n){     super(300);  // 调用父类中带有参数的构造器    System.out.println("SubClass(int n):"+n);    this.n = n;  }}// SubClass2 类继承class SubClass2 extends SuperClass{  private int n;  SubClass2(){    super(300);  // 调用父类中带有参数的构造器    System.out.println("SubClass2");  }    public SubClass2(int n){ // 自动调用父类的无参数构造器    System.out.println("SubClass2(int n):"+n);    this.n = n;  }}public class TestSuperSub{  public static void main (String args[]){    System.out.println("------SubClass 类继承------");    SubClass sc1 = new SubClass();    SubClass sc2 = new SubClass(100);     System.out.println("------SubClass2 类继承------");    SubClass2 sc3 = new SubClass2();    SubClass2 sc4 = new SubClass2(200);   }}</code></pre><h3 id="Java-转型问题"><a href="#Java-转型问题" class="headerlink" title="Java 转型问题"></a>Java 转型问题</h3><ul><li><strong>向上转型</strong>(upcasting) </li><li><strong>向下转型</strong>(downcasting)。</li></ul><p>举个例子：有2个类，<strong>Father 是父类，Son 类继承自 Father</strong>。</p><pre><code>Father f1 = new Son();   // 这就叫 upcasting （向上转型)// 现在 f1 引用指向一个Son对象Son s1 = (Son)f1;   // 这就叫 downcasting (向下转型)// 现在f1 还是指向 Son对象</code></pre><p>第2个例子：</p><pre><code>Father f2 = new Father();Son s2 = (Son)f2;       // 出错，子类引用不能指向父类对象</code></pre><p><strong>总结</strong>：</p><ul><li><p><strong><code>父类引用</code>指向<code>子类对象</code>，而<code>子类引用</code>不能指向<code>父类对象</code>。</strong></p></li><li><p><strong>把<code>子类对象</code>直接<code>赋给父类引用</code>叫upcasting<code>向上转型</code>，向上转型<code>不用强制转换</code></strong>，如：</p><pre><code>Father f1 = new Son();</code></pre></li><li><p><strong>把<code>指向子类对象的父类引用</code>赋给<code>子类引用</code>叫<code>向下转型</code>(downcasting)，要<code>强制转换</code></strong></p></li><li><p><strong>向上转型的好处:</strong></p><pre><code>public class Human {public void sleep() {  System.out.println("Human sleep..");}}class Male extends Human {@Override //方法重写public void sleep() {  System.out.println("Male sleep..");}}class Female extends Human {@Override //方法重写public void sleep() {  System.out.println("Female sleep..");}}</code></pre><p>看上面的代码：</p><pre><code>public static void dosleep(Human h) {  h.sleep();}//主方法public static void main(String[] args) {      Male m = new Male();      dosleep(m);}</code></pre><p>结果：</p><pre><code>Male sleep..</code></pre><p>这里<strong><code>函数以父类为参数</code>，<code>调用时用子类作为参数</code>，就是利用了<code>向上转型</code>。这样使代码变得简洁。不然的话，如果 <code>dosleep 以子类对象为参数</code>，则<code>有多少个子类就需要写多少个函数</code>。这也体现了 JAVA 的抽象编程思想。</strong></p></li></ul><h2 id="Java-重写-Override-与重载-Overload"><a href="#Java-重写-Override-与重载-Overload" class="headerlink" title="Java 重写(Override)与重载(Overload)"></a>Java 重写(Override)与重载(Overload)</h2><h3 id="重写-Override"><a href="#重写-Override" class="headerlink" title="重写(Override)"></a>重写(Override)</h3><p><strong>重写是子类对父类的<code>允许访问</code>的<code>方法的实现过程</code>进行<code>重新编写</code>, <code>返回值和形参都不能改变</code>。即<code>外壳不变，核心重写</code>！</strong></p><p><strong>重写的<code>好处</code>在于子类可以<code>根据需要</code>，定义特定于<code>自己的行为</code>。 也就是说子类能够<code>根据需要实现父类的方法</code>。</strong></p><p>重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。</p><p>在面向对象原则里，重写意味着可以重写任何现有方法。实例如下：</p><pre><code>class Animal{   public void move(){      System.out.println("动物可以移动");   }}class Dog extends Animal{   public void move(){      System.out.println("狗可以跑和走");   }}public class TestDog{   public static void main(String args[]){      Animal a = new Animal(); // Animal 对象      Animal b = new Dog(); // Dog 对象,向上转型      a.move();// 执行 Animal 类的方法      b.move();//执行 Dog 类的方法   }}</code></pre><p>以上实例编译运行结果如下：</p><pre><code>动物可以移动狗可以跑和走</code></pre><p>在上面的例子中可以看到，<strong>尽管 b 属于 Animal 类型，但是它运行的是 Dog 类的 move方法。</strong></p><p>这是由于<strong>在<code>编译</code>阶段，只是<code>检查参数的引用类型</code>，此处为<code>父类引用</code>。</strong></p><p>然而在<strong><code>运行</code>时，Java 虚拟机(JVM)指定<code>对象的类型</code>并且<code>运行该对象的方法</code>，此处为<code>子类对象</code>。</strong></p><p>因此在上面的例子中，之所以<strong>能编译成功，是因为 <code>Animal 类中存在 move 方法</code>，然而运行时，<code>运行的是特定对象的方法</code>。</strong></p><p>思考以下例子：</p><pre><code>class Animal{   public void move(){      System.out.println("动物可以移动");   }}class Dog extends Animal{   public void move(){      System.out.println("狗可以跑和走");   }   public void bark(){      System.out.println("狗可以吠叫");   }}public class TestDog{   public static void main(String args[]){      Animal a = new Animal(); // Animal 对象      Animal b = new Dog(); // Dog 对象      a.move();// 执行 Animal 类的方法      b.move();//执行 Dog 类的方法      b.bark();   }}</code></pre><p>以上实例编译运行结果如下：</p><pre><code>TestDog.java:30: cannot find symbolsymbol  : method bark()location: class Animal                b.bark();</code></pre><p>该程序将抛出一个编译错误，因为<strong>b的引用类型Animal没有bark方法。</strong></p><p><strong>注意：</strong></p><p><strong>1.<code>父类变量</code>指向<code>子类实例</code>，该父类变量<code>不能调用父类不存在的变量和方法</code>，否则会编译错误</strong></p><p><strong>2.<code>父类变量</code>指向<code>子类实例</code>时可以使用<code>强制类型转换</code>访问<code>父类没有的子类成员</code>。</strong></p><pre><code>((Dog)b).bark();     //输出"狗可以吠叫""</code></pre><h4 id="方法的重写规则"><a href="#方法的重写规则" class="headerlink" title="方法的重写规则"></a>方法的重写规则</h4><ul><li><strong>方法名，参数列表必须完全与被重写方法的相同。</strong></li><li><strong>访问权限不能比父类中被重写的方法的访问权限更低。</strong>例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</li><li>父类的成员方法只能被它的子类重写。</li><li><strong>声明为 final 的方法不能被重写。</strong></li><li>声明为 static 的方法不能被重写，但是能够被再次声明。</li><li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</li><li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</li><li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li><li>构造方法不能被重写。</li><li>如果不能继承一个方法，则不能重写这个方法。</li></ul><h3 id="重载-Overload"><a href="#重载-Overload" class="headerlink" title="重载(Overload)"></a>重载(Overload)</h3><p><strong>重载(overloading) 是在<code>一个类里面</code>，<code>方法名字相同</code>，<code>而参数不同</code>。<code>返回类型可以相同也可以不同</code>。</strong></p><p><strong>每个重载的方法（或者构造函数）都必须有一个<code>独一无二的参数类型列表</code>。</strong></p><p><strong><code>最常用</code>的地方就是<code>构造器的重载</code>。</strong></p><p>重载规则:</p><ul><li><strong>被重载的方法<code>必须改变参数列表</code>(参数个数或类型不一样)；</strong></li><li>被重载的方法<code>可以改变返回类型</code>；</li><li>被重载的方法<code>可以改变访问修饰符</code>；</li><li>被重载的方法可以声明新的或更广的检查异常；</li><li><strong>方法能够在<code>同一个类</code>中或者在<code>一个子类</code>中被重载。</strong></li><li><strong><code>无法以返回值类型</code>作为重载函数的<code>区分标准</code>。</strong></li></ul><h3 id="重写与重载之间的区别"><a href="#重写与重载之间的区别" class="headerlink" title="重写与重载之间的区别"></a>重写与重载之间的区别</h3><table><thead><tr><th align="left">区别点</th><th align="left">重载方法</th><th align="right">重写方法</th></tr></thead><tbody><tr><td align="left">参数列表</td><td align="left">必须修改</td><td align="right">一定不能修改</td></tr><tr><td align="left">返回类型</td><td align="left">可以修改</td><td align="right">一定不能修改</td></tr><tr><td align="left">异常</td><td align="left">可以修改</td><td align="right">可以减少或删除，一定不能抛出新的或者更广的异常</td></tr><tr><td align="left">访问</td><td align="left">可以修改</td><td align="right">一定不能低于父类访问级别</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>方法的重写(<code>Overriding</code>)和重载(<code>Overloading</code>)是<code>java多态性的不同表现</code></strong></p><ul><li>方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。</li><li>方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。</li><li><strong>方法<code>重载是一个类的多态性表现</code>,而方法<code>重写是子类与父类的一种多态性表现</code>。</strong></li></ul><img src="//www.runoob.com/wp-content/uploads/2013/12/overloading-vs-overriding.png"><img src="https://www.runoob.com/wp-content/uploads/2013/12/20171102-1.png"><h2 id="Java-多态"><a href="#Java-多态" class="headerlink" title="Java 多态"></a>Java 多态</h2><p><strong>多态是<code>同一个行为</code>具有<code>多个不同表现形式或形态</code>的<code>能力</code>。</strong></p><p><strong>多态就是<code>同一个接口</code>，<code>使用不同的实例</code>而<code>执行不同操作</code></strong></p><img src="//www.runoob.com/wp-content/uploads/2013/12/dt-java.png"><p><strong><code>多态性</code>是<code>对象多种表现形式的体现</code>。</strong></p><h3 id="多态的优点"><a href="#多态的优点" class="headerlink" title="多态的优点"></a>多态的优点</h3><ul><li><strong>消除<code>类型之间</code>的耦合关系</strong></li><li>可替换性</li><li>可扩充性</li><li>接口性</li><li>灵活性</li><li>简化性</li></ul><h3 id="多态存在的三个必要条件"><a href="#多态存在的三个必要条件" class="headerlink" title="多态存在的三个必要条件"></a>多态存在的三个必要条件</h3><ul><li><strong>继承</strong></li><li><strong>重写</strong></li><li><strong>父类引用指向子类对象</strong></li></ul><p>比如：</p><pre><code>Parent p = new Child();</code></pre><p><strong>当使用<code>多态方式调用方法</code>时，首先<code>检查父类中是否有该方法</code>，如果<code>没有</code>，则<code>编译错误</code>；如果<code>有，再去调用子类的同名方法</code>。</strong></p><p>多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。</p><p>以下是一个多态实例的演示，<strong>详细说明请看注释</strong>：</p><pre><code>public class Test {    public static void main(String[] args) {      show(new Cat());  // 以 Cat 对象调用 show 方法      show(new Dog());  // 以 Dog 对象调用 show 方法      Animal a = new Cat();  // 向上转型        a.eat();               // 调用的是 Cat 的 eat      Cat c = (Cat)a;        // 向下转型        c.work();        // 调用的是 Cat 的 work  }      public static void show(Animal a)  {      a.eat();          // 类型判断        if (a instanceof Cat)  {  // 猫做的事情             Cat c = (Cat)a;              c.work();        } else if (a instanceof Dog) { // 狗做的事情             Dog c = (Dog)a;              c.work();          }      }  }abstract class Animal {      abstract void eat();      //抽象方法，需要子类实现  }  class Cat extends Animal {      public void eat() {          System.out.println("吃鱼");      }      public void work() {          System.out.println("抓老鼠");      }  }  class Dog extends Animal {      public void eat() {          System.out.println("吃骨头");      }      public void work() {          System.out.println("看家");      }  }</code></pre><p>执行以上程序，输出结果为：</p><pre><code>吃鱼抓老鼠吃骨头看家吃鱼抓老鼠</code></pre><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p><strong>虚函数的<code>存在是为了多态</code>。</strong></p><h4 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h4><p><strong>Employee.java 文件代码：</strong></p><pre><code>/* 文件名 : Employee.java */public class Employee {   private String name;   private String address;   private int number;   public Employee(String name, String address, int number) {      System.out.println("Employee 构造函数");      this.name = name;      this.address = address;      this.number = number;   }   public void mailCheck() {      System.out.println("邮寄支票给： " + this.name       + " " + this.address);   }   public String toString() {      return name + " " + address + " " + number;   }   public String getName() {      return name;   }   public String getAddress() {      return address;   }   public void setAddress(String newAddress) {      address = newAddress;   }   public int getNumber() {     return number;   }}</code></pre><p>假设下面的类继承Employee类：</p><p><strong>Salary.java 文件代码：</strong></p><pre><code>/* 文件名 : Salary.java */public class Salary extends Employee{   private double salary; // 全年工资   public Salary(String name, String address, int number, double salary) {       super(name, address, number); //必须调用父类构造函数       setSalary(salary);   }   public void mailCheck() {       System.out.println("Salary 类的 mailCheck 方法 ");       System.out.println("邮寄支票给：" + getName()       + " ，工资为：" + salary);   }   public double getSalary() {       return salary;   }   public void setSalary(double newSalary) {       if(newSalary &gt;= 0.0) {          salary = newSalary;       }   }   public double computePay() {      System.out.println("计算工资，付给：" + getName());      return salary/52;   }}</code></pre><p>现在我们仔细阅读下面的代码，尝试给出它的输出结果：</p><p><strong>VirtualDemo.java 文件代码：</strong></p><pre><code>/* 文件名 : VirtualDemo.java */public class VirtualDemo {   public static void main(String [] args) {      Salary s = new Salary("员工 A", "北京", 3, 3600.00);      Employee e = new Salary("员工 B", "上海", 2, 2400.00);  //向上转型      System.out.println("使用 Salary 的引用调用 mailCheck -- ");      s.mailCheck();      System.out.println("\n使用 Employee 的引用调用 mailCheck--");      e.mailCheck();    }}</code></pre><p>以上实例编译运行结果如下：</p><pre><code>Employee 构造函数Employee 构造函数使用 Salary 的引用调用 mailCheck -- Salary 类的 mailCheck 方法 邮寄支票给：员工 A ，工资为：3600.0使用 Employee 的引用调用 mailCheck--Salary 类的 mailCheck 方法 邮寄支票给：员工 B ，工资为：2400.0</code></pre><h4 id="例子解析"><a href="#例子解析" class="headerlink" title="例子解析"></a>例子解析</h4><ul><li>实例中，实例化了<strong><code>两个 Salary 对象</code>：一个使用 <code>Salary 引用 s</code>，另一个使用 <code>Employee 引用 e</code>。</strong></li><li>当调用 <strong>s.mailCheck() 时，编译器在<code>编译</code>时会在 <code>Salary 类中找到 mailCheck()</code>，<code>执行</code>过程 <code>JVM 就调用 Salary 类的 mailCheck()</code>。</strong></li><li><strong>在<code>编译</code>的时候，编译器使用 <code>Employee 类中的 mailCheck()</code> 方法<code>验证该语句</code>， 但是在<code>运行</code>的时候，<code>Java虚拟机(JVM)调用</code>的是 <code>Salary 类中的 mailCheck() 方法</code>。</strong></li></ul><p><strong>以上<code>整个过程</code>被称为<code>虚拟方法调用</code>，该<code>方法被称为虚拟方法</code>。</strong></p><p>Java中所有的方法都能以这种方式表现，因此，<strong>重写的方法能在运行时调用，不管编译的时候源代码中引用变量是什么数据类型。</strong></p><h3 id="多态的实现方式"><a href="#多态的实现方式" class="headerlink" title="多态的实现方式"></a>多态的实现方式</h3><h4 id="方式一：重写："><a href="#方式一：重写：" class="headerlink" title="方式一：重写："></a>方式一：重写：</h4><p>这个内容已经在上一章节详细讲过，就不再阐述，详细可访问：<a href="https://www.runoob.com/java/java-override-overload.html" target="_blank" rel="noopener">上一章节</a></p><h4 id="方式二：接口"><a href="#方式二：接口" class="headerlink" title="方式二：接口"></a>方式二：接口</h4><p> java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。具体可以看 <a href="https://www.runoob.com/java/java-interfaces.html" target="_blank" rel="noopener">Java接口</a> 这一章节的内容。</p><h4 id="方式三：抽象类和抽象方法"><a href="#方式三：抽象类和抽象方法" class="headerlink" title="方式三：抽象类和抽象方法"></a>方式三：抽象类和抽象方法</h4><p>详情请看 <a href="https://www.runoob.com/java/java-abstraction.html" target="_blank" rel="noopener">Java抽象类</a> 章节。</p><h2 id="Java-抽象类"><a href="#Java-抽象类" class="headerlink" title="Java 抽象类"></a>Java 抽象类</h2><p><strong>在<code>面向对象</code>的概念中，所有的<code>对象都是通过类来描绘</code>的，但是反过来，并<code>不是所有的类都是用来描绘对象</code>的，如果<code>一个类中没有包含足够的信息来描绘一个具体的对象</code>，这样的类就是<code>抽象类</code>。</strong></p><p><strong>抽象类除了<code>不能实例化对象</code>之外，类的<code>其它功能依然存在</code>，成员变量、成员方法和构造方法的访问方式和普通类一样。</strong></p><p><strong>由于<code>抽象类不能实例化对象</code>，所以抽象类<code>必须被继承</code>，才能被使用。</strong>也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</p><p><strong><code>父类包含了子类集合的常见的方法</code>，但是由于<code>父类本身是抽象</code>的，所以<code>不能使用这些方法</code>。</strong></p><p>在Java中<strong>抽象类表示的是一种<code>继承关系</code>，<code>一个类只能继承一个抽象类</code>，而<code>一个类却可以实现多个接口</code>。</strong></p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>在Java语言中使用<strong><code>abstract class</code>来定义<code>抽象类</code>。</strong></p><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>如果你想设计这样一个类，<strong>该类包含一个<code>特别的成员方法</code>，该方法的<code>具体实现由它的子类确定</code>，那么你可以<code>在父类中声明该方法为抽象方法</code>。</strong></p><p><strong><code>Abstract</code> 关键字同样可以用来<code>声明抽象方法</code>，抽象方法<code>只包含一个方法名</code>，而<code>没有方法体</code>。</strong></p><p><strong>抽象方法<code>没有定义</code>，<code>方法名后面直接跟一个分号</code>，<code>而不是花括号</code>。</strong></p><pre><code>public abstract class Employee{   private String name;   private String address;   private int number;   public abstract double computePay();   //其余代码}</code></pre><h3 id="抽象类总结规定"><a href="#抽象类总结规定" class="headerlink" title="抽象类总结规定"></a>抽象类总结规定</h3><ol><li><p><strong>抽象类<code>不能被实例化</code>(初学者很容易犯的错)，如果<code>被实例化，就会报错，编译无法通过</code>。只有<code>抽象类的非抽象子类可以创建对象</code>。</strong></p></li><li><p><strong>抽象类中<code>不一定</code>包含抽象方法，但是有抽象方法的类<code>必定</code>是抽象类。</strong></p></li><li><p>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</p></li><li><p><strong><code>构造方法</code>，<code>类方法</code>（用 static 修饰的方法）<code>不能声明为抽象方法</code>。</strong></p></li><li><p><strong>抽象类的<code>子类必须给出抽象类中的抽象方法的具体实现</code>，除非<code>该子类也是抽象类</code>。</strong></p></li></ol><h2 id="Java-封装"><a href="#Java-封装" class="headerlink" title="Java 封装"></a>Java 封装</h2><p><strong>在<code>面向对象程式设计方法</code>中，封装（英语：<code>Encapsulation</code>）是指一种<code>将抽象性函式接口的实现细节部分包装、隐藏</code>起来的<code>方法</code>。</strong></p><p><strong>封装可以被认为是一个<code>保护屏障</code>，<code>防止</code>该类的<code>代码和数据</code>被外部类定义的代码<code>随机访问</code>。</strong></p><p><strong>要<code>访问该类的代码和数据</code>，必须通过<code>严格的接口控制</code>。</strong></p><p>封装最主要的功能在于我们<strong>能<code>修改自己的实现代码</code>，而<code>不用修改那些调用我们代码的程序片段</code>。</strong></p><p><strong>适当的封装可以让程式码更容易<code>理解与维护</code>，也<code>加强了程式码的安全性</code>。</strong></p><h3 id="封装的优点"><a href="#封装的优点" class="headerlink" title="封装的优点"></a>封装的优点</h3><ol><li><p><strong>良好的封装能够<code>减少耦合</code>。</strong></p></li><li><p><strong><code>类内部的结构</code>可以<code>自由修改</code>。</strong></p></li><li><p><strong>可以对<code>成员变量</code>进行<code>更精确的控制</code>。</strong></p></li><li><p><strong><code>隐藏信息</code>，<code>实现细节</code>。</strong></p></li></ol><h3 id="实现Java封装的步骤"><a href="#实现Java封装的步骤" class="headerlink" title="实现Java封装的步骤"></a>实现Java封装的步骤</h3><h4 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h4><p><strong>修改<code>属性的可见性</code>来<code>限制</code>对属性的<code>访问</code>（一般限制为<code>private</code>）</strong>，例如：</p><pre><code>public class Person {    private String name;    private int age;}</code></pre><p>这段代码中，将 <strong>name 和 age 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。</strong></p><h4 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h4><p><strong>对每个值属性提供<code>对外的公共方法</code>访问，也就是创建<code>一对赋取值方法</code>，用于对<code>私有属性的访问</code></strong>，例如：</p><pre><code>public class Person{    private String name;    private int age;​    public int getAge(){      return age;    }​    public String getName(){      return name;    }​    public void setAge(int age){      this.age = age;    }​    public void setName(String name){      this.name = name;    }}</code></pre><p>采用 <strong><code>this</code> 关键字是为了解决<code>实例变量</code>（private String name）和<code>局部变量</code>（setName(String name)中的name变量）之间发生的<code>同名的冲突</code>。</strong></p><p><strong>以上实例中public方法是外部类访问该类成员变量的入口。</strong></p><p>通常情况下，<strong>这些方法被称为<code>getter</code>和<code>setter</code>方法。</strong></p><p>因此，<strong>任何要<code>访问类中私有成员变量</code>的<code>类</code>都要通过这些<code>getter和setter方法</code>。</strong></p><h2 id="Java-接口"><a href="#Java-接口" class="headerlink" title="Java 接口"></a>Java 接口</h2><p><strong>接口（英文：<code>Interface</code>），在JAVA编程语言中是一个<code>抽象类型</code>，是<code>抽象方法的集合</code>，接口通常<code>以interface来声明</code>。一个类通过<code>继承接口的方式</code>，从而<code>来继承接口的抽象方法</code>。</strong></p><p><strong>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。<code>类描述对象的属性和方法</code>。<code>接口则包含类要实现的方法</code>。</strong></p><p><strong><code>除非</code>实现接口的类是<code>抽象类</code>，否则该类要定义<code>接口中的所有方法</code>。</strong></p><p><strong>接口<code>无法被实例化</code>，但是<code>可以被实现</code>。一个<code>实现接口的类</code>，<code>必须实现接口内所描述的所有方法</code>，<code>否则</code>就必须声明为<code>抽象类</code>。另外，在 Java 中，<code>接口类型可用来声明一个变量</code>，他们可以<code>成为一个空指针</code>，或是被绑定在一个<code>以此接口实现的对象</code>。</strong></p><h3 id="接口与类相似点："><a href="#接口与类相似点：" class="headerlink" title="接口与类相似点："></a>接口与类相似点：</h3><ul><li>一个接口可以有多个方法。</li><li>接口文件保存在 .java 结尾的文件中，文件名使用接口名。</li><li>接口的字节码文件保存在 .class 结尾的文件中。</li><li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li></ul><h3 id="接口与类的区别："><a href="#接口与类的区别：" class="headerlink" title="接口与类的区别："></a>接口与类的区别：</h3><ul><li><strong>接口<code>不能用于实例化对象</code>。</strong></li><li><strong>接口<code>没有构造方法</code>。</strong></li><li><strong>接口中<code>所有的方法必须是抽象方法</code>。</strong></li><li><strong>接口不能包含成员变量，<code>除了 static 和 final 变量</code>。</strong></li><li><strong>接口<code>不是被类继承</code>了，<code>而是要被类实现</code>。</strong></li><li><strong>接口支持<code>多继承</code>。</strong></li></ul><h3 id="接口特性"><a href="#接口特性" class="headerlink" title="接口特性"></a>接口特性</h3><ul><li>接口中<strong>每一个方法</strong>也是隐式抽象的,<strong>接口中的方法会被<code>隐式</code>的指定为 <code>public abstract</code>（<code>只能是 public abstract</code>，其他修饰符都会报错）。</strong></li><li>接口中可以含有变量，但是<strong>接口中的变量会被<code>隐式</code>的指定为 <code>public static final</code> 变量（并且<code>只能是 public</code>，用 private 修饰会报编译错误）。</strong></li><li>接口中的<strong><code>方法是不能在接口中实现</code>的，只能由<code>实现接口的类</code>来实现<code>接口中的方法</code>。</strong></li></ul><h3 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><ul><li><strong>抽象类中的<code>方法(非抽象方法)可以有方法体</code>，就是能实现方法的具体功能，但是<code>接口中的方法不行</code>。</strong></li><li><strong><code>抽象类中的成员变量可以是各种类型的</code>，而<code>接口中的成员变量</code>只能是 <code>public static final</code> 类型的。</strong></li><li><strong>一个类只能<code>继承一个抽象类</code>，却可以<code>实现多个接口</code>。</strong></li></ul><h3 id="接口的声明"><a href="#接口的声明" class="headerlink" title="接口的声明"></a>接口的声明</h3><p>接口的声明语法格式如下：</p><pre><code>[访问修饰符] interface 接口名称 [extends 其他的接口名] {        // 声明变量        // 抽象方法}</code></pre><p><strong>Interface关键字用来声明一个接口</strong>。</p><p>下面是接口声明的一个简单例子。</p><p><strong>NameOfInterface.java 文件代码：</strong></p><pre><code>/* 文件名 : NameOfInterface.java */import java.lang.*;//引入包public interface NameOfInterface{   //任何类型 final, static 字段   //抽象方法}</code></pre><p><strong>接口有以下特性：</strong></p><ul><li><strong>接口是<code>隐式抽象</code>的，当声明一个接口的时候，不必使用<code>abstract</code>关键字。</strong></li><li><strong>接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。</strong></li><li><strong>接口中的<code>方法都是公有的</code>。</strong></li></ul><h3 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h3><p>当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。</p><p><strong>类使用<code>implements</code>关键字<code>实现接口</code>。在类声明中，Implements关键字<code>放在class声明后面</code>。</strong></p><p>实现一个接口的语法，可以使用这个公式：</p><pre><code>...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...</code></pre><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p><strong>Animal.java 文件代码</strong>：</p><pre><code>interface Animal {   public void eat();   public void travel();}</code></pre><p><strong>MammalInt.java 文件代码：</strong></p><pre><code>public class MammalInt implements Animal{   public void eat(){      System.out.println("Mammal eats");   }   public void travel(){      System.out.println("Mammal travels");   }    public int noOfLegs(){      return 0;   }   public static void main(String args[]){      MammalInt m = new MammalInt();      m.eat();      m.travel();   }}</code></pre><p>以上实例编译运行结果如下:</p><pre><code>Mammal eatsMammal travels</code></pre><h3 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h3><p><strong><code>一个接口能继承另一个接口</code>，和类之间的继承方式比较相似。<code>接口的继承使用extends关键字</code>，子接口继承父接口的方法。</strong></p><p>下面的<strong>Sports接口被Hockey和Football接口继承：</strong></p><p><strong>文件名: Sports.java</strong></p><pre><code>public interface Sports{   public void setHomeTeam(String name);   public void setVisitingTeam(String name);}</code></pre><p><strong>文件名: Football.java</strong></p><pre><code>public interface Football extends Sports{   public void homeTeamScored(int points);   public void visitingTeamScored(int points);   public void endOfQuarter(int quarter);}</code></pre><p><strong>文件名: Hockey.java</strong></p><pre><code>public interface Hockey extends Sports{   public void homeGoalScored();   public void visitingGoalScored();   public void endOfPeriod(int period);   public void overtimePeriod(int ot);}</code></pre><p><strong>Hockey接口自己声明了<code>四个</code>方法，从Sports接口继承了<code>两个</code>方法，这样，实现Hockey接口的<code>类</code>需要实现<code>六个</code>方法。</strong></p><p>相似的，实现Football接口的类需要实现五个方法，其中两个来自于Sports接口。</p><h3 id="接口的多继承"><a href="#接口的多继承" class="headerlink" title="接口的多继承"></a>接口的多继承</h3><p>在Java中，<strong>类的多继承是不合法，但接口允许多继承。</strong></p><p><strong>在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口。</strong> 如下所示：</p><pre><code>public interface Hockey extends Sports, Event</code></pre><h3 id="JAVA—jdk1-8之后的接口"><a href="#JAVA—jdk1-8之后的接口" class="headerlink" title="JAVA—jdk1.8之后的接口"></a>JAVA—jdk1.8之后的接口</h3><p>在 JDK1.8，允许我们给接口添加<strong>两种<code>非抽象</code>的方法实现</strong>：</p><ol><li><p><strong><code>默认方法</code>，添加 <code>default</code> 修饰即可；</strong></p><p><strong>为什么要定义默认方法？为了解决<code>接口升级</code>的问题</strong></p><p><strong>接口升级：</strong></p><p><strong>如果当前有一个接口，并且n多个类实现了这个接口；而当<code>接口再次添加抽象方法</code>的时候，<code>n多个实现类就会报错</code>。而出现了<code>默认方法就解决了这个问题</code>。</strong></p></li><li><p><strong><code>静态方法</code>，使用 <code>static</code> 修饰；示例如下：</strong></p><pre><code>interface Test{   //这个是默认方法   default String get(String aa){       System.out.println("我是jdk1.8默认实现方法...");       return "";   }      //这个是静态方法       static void staticmethod(){       System.out.println("我是静态方法");   }}</code></pre></li><li><p><strong>调用方式：</strong></p><ul><li><strong><code>static</code> 方法只能通过<code>接口名</code>调用，不可以通过<code>实现类的类名</code>或者<code>实现类的对象</code>调用</strong></li><li><strong><code>default</code> 方法只能通过<code>接口实现类的对象</code>来调用。</strong></li></ul></li></ol><h2 id="Java-包-package"><a href="#Java-包-package" class="headerlink" title="Java 包(package)"></a>Java 包(package)</h2><p>为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。</p><h3 id="包的作用"><a href="#包的作用" class="headerlink" title="包的作用"></a>包的作用</h3><ol><li><p><strong>把<code>功能相似或相关</code>的<code>类或接口</code>组织在<code>同一个包</code>中，方便类的<code>查找和使用</code>。</strong></p></li><li><p>如同文件夹一样，包也采用了树形目录的存储方式。<strong>同一个包中的类名字是<code>不同</code>的，不同的包中的类的名字是<code>可以相同</code>的，当同时调用两个<code>不同包中相同类名</code>的类时，应该加上<code>包名</code>加以区别。因此，包可以避免<code>名字冲突</code>。</strong></p></li><li><p><strong>包也限定了<code>访问权限</code>，拥有包访问权限的类才能访问某个包中的类。</strong></p></li></ol><p>包语句的语法格式为：</p><pre><code>package pkg1[．pkg2[．pkg3…]];</code></pre><p>以下是一些 Java 中的包：</p><ul><li><strong>java.lang</strong>-打包基础的类</li><li><strong>java.io</strong>-包含输入输出功能的函数</li></ul><h3 id="import-关键字"><a href="#import-关键字" class="headerlink" title="import 关键字"></a>import 关键字</h3><p>为了能够使用某一个包的成员，我们需要<strong>在 Java 程序中明确<code>导入</code>该包。使用 <code>"import" 语句</code>可完成此功能。</strong></p><p><strong>在 java 源文件中 <code>import 语句应位于 package 语句之后</code>，所有<code>类的定义之前</code>，可以没有，也可以有多条</strong></p><p>其语法格式为：</p><pre><code>import package1[.package2…].(classname|*);</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习 二</title>
      <link href="/2020/04/14/java-xue-xi-er/"/>
      <url>/2020/04/14/java-xue-xi-er/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-运算符"><a href="#Java-运算符" class="headerlink" title="Java 运算符"></a>Java 运算符</h2><p>计算机的最基本用途之一就是执行数学运算，作为一门计算机语言，Java也提供了一套丰富的运算符来操纵变量。我们可以把运算符分成以下几组：</p><ul><li>算术运算符</li><li>关系运算符</li><li>位运算符</li><li>逻辑运算符</li><li>赋值运算符</li><li>其他运算符</li></ul><p>重点讲一下instanceof 运算符</p><h3 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h3><p>该运算符<strong>用于<code>操作对象实例(必须为引用类型，不能是基本类型)</code>，检查该对象是否是一个<code>特定类型</code>（<code>类类型或接口类型</code>）。</strong></p><p>instanceof运算符使用格式如下：</p><pre><code>( Object reference variable ) instanceof  (class/interface type)</code></pre><p>如果<strong>运算符<code>左侧变量所指的对象</code>，是操作符<code>右侧类或接口(class/interface)的一个对象</code>，那么<code>结果为真</code>。</strong></p><p>下面是一个例子：</p><pre><code>String name = "James";boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真</code></pre><p>如果<strong><code>被比较的对象兼容于右侧类型</code>,该运算符仍然<code>返回true</code>。</strong></p><p>看下面的例子：</p><pre><code>class Vehicle {}public class Car extends Vehicle {   public static void main(String[] args){       //向上转型      Vehicle a = new Car();         boolean result =  a instanceof Car;      System.out.println( result);   }}</code></pre><p>以上实例编译运行结果如下：</p><pre><code>true</code></pre><p><strong>鉴于大部分内容与其他编程语言用法类似，不再详细记载</strong></p><p><a href="https://www.runoob.com/java/java-operators.html" target="_blank" rel="noopener">运算符详细教程</a></p><h2 id="Java-循环结构-for-while-及-do…while"><a href="#Java-循环结构-for-while-及-do…while" class="headerlink" title="Java 循环结构 - for, while 及 do…while"></a>Java 循环结构 - for, while 及 do…while</h2><p>顺序结构的程序语句只能被执行一次。如果您想要同样的操作执行多次,，就需要使用循环结构。 </p><p>Java中有三种主要的循环结构：</p><ul><li>while 循环</li><li>do…while 循环</li><li>for 循环</li></ul><p>对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。</p><p>do…while 循环和 while 循环相似，不同的是，<strong>do…while 循环至少会执行一次</strong>。</p><p><strong>在Java5中引入了一种主要用于数组的增强型for循环。</strong></p><h3 id="Java-增强-for-循环"><a href="#Java-增强-for-循环" class="headerlink" title="Java 增强 for 循环"></a>Java 增强 for 循环</h3><p>Java 增强 for 循环语法格式如下:</p><pre><code>for(声明语句 : 表达式){   //代码句子}</code></pre><p><strong>声明语句</strong>：声明新的局部变量，<strong>该变量的类型必须和数组元素的类型匹配</strong>。其作用域限定在循环语句块，其值与此时数组元素的值相等。 </p><p><strong>表达式：表达式是要访问的<code>数组名</code>，或者是<code>返回值为数组</code>的<code>方法</code></strong>。</p><p>实例</p><pre><code>public class Test {   public static void main(String args[]){      int [] numbers = {10, 20, 30, 40, 50};      for(int x : numbers ){         System.out.print( x );         System.out.print(",");      }      System.out.print("\n");      String [] names ={"James", "Larry", "Tom", "Lacy"};      for( String name : names ) {         System.out.print( name );         System.out.print(",");      }   }}</code></pre><p>以上实例编译运行结果如下：</p><pre><code>10,20,30,40,50,James,Larry,Tom,Lacy,</code></pre><h3 id="break-关键字"><a href="#break-关键字" class="headerlink" title="break 关键字"></a>break 关键字</h3><p><strong>break 主要用在<code>循环语句</code>或者<code>switch 语句</code>中，用来跳出整个语句块。</strong></p><p><strong>break 跳出<code>最里层</code>的循环，并且继续执行该循环下面的语句。</strong></p><h3 id="continue-关键字"><a href="#continue-关键字" class="headerlink" title="continue 关键字"></a>continue 关键字</h3><p><strong>continue 适用于<code>任何循环控制结构</code>中。作用是让程序立刻跳转到下一次循环的迭代。</strong></p><p><strong>在 <code>for</code>循环中，continue 语句使程序立即跳转到<code>更新语句</code>。</strong></p><pre><code>for(初始化; 布尔表达式; 更新) {    //代码语句}</code></pre><p><strong>在 <code>while 或者 do…while</code>循环中，程序立即跳转到<code>布尔表达式</code>的判断语句。</strong> </p><h2 id="Java-条件语句-if…else"><a href="#Java-条件语句-if…else" class="headerlink" title="Java 条件语句 - if…else"></a>Java 条件语句 - if…else</h2><h3 id="if…else语句"><a href="#if…else语句" class="headerlink" title="if…else语句"></a>if…else语句</h3><p><strong>if 语句后面可以跟 else 语句</strong>，当 if 语句的布尔表达式值为 false 时，else 语句块会被执行。</p><pre><code>if(布尔表达式){   //如果布尔表达式的值为true}else{   //如果布尔表达式的值为false}</code></pre><h3 id="if…else-if…else-语句"><a href="#if…else-if…else-语句" class="headerlink" title="if…else if…else 语句"></a>if…else if…else 语句</h3><p>if 语句后面可以跟 else if…else 语句，<strong>这种语句可以检测到<code>多种可能的情况</code>。</strong></p><p>使用 if，else if，else 语句的时候，需要注意下面几点：</p><ul><li><strong>if 语句至多有<code>1 个</code>else 语句，else 语句在所有的 <code>else if</code>语句之后。</strong></li><li>if 语句可以有若干个 else if 语句，它们必须在 else 语句之前。</li><li><strong>一旦其中一个 else if 语句检测为 true，其他的 else if 以及 else 语句都将<code>跳过执行</code>。</strong></li></ul><h3 id="嵌套的-if…else-语句"><a href="#嵌套的-if…else-语句" class="headerlink" title="嵌套的 if…else 语句"></a>嵌套的 if…else 语句</h3><p>用嵌套的 if…else 语句是合法的。也就是说你<strong>可以在另一个 if 或者 else if 语句中使用 if 或者 else if 语句。</strong></p><h2 id="Java-switch-case-语句"><a href="#Java-switch-case-语句" class="headerlink" title="Java switch case 语句"></a>Java switch case 语句</h2><p>switch case 语句<strong>判断一个变量与一系列值中某个值是否相等，每个值称为一个分支</strong>。</p><pre><code>switch(expression){    case value :       //语句       break; //可选    case value :       //语句       break; //可选    //你可以有任意数量的case语句    default : //可选       //语句}</code></pre><p>switch case 语句有如下规则：</p><ul><li>switch 语句中的<strong>变量类型可以是： <code>byte、short、int 或者 char</code>。从 Java SE 7 开始，switch 支持<code>字符串 String 类型</code>了，同时 case 标签必须为<code>字符串常量</code>或<code>字面量</code>。</strong></li><li>switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。</li><li><strong>case 语句中的<code>值</code>的数据类型必须与<code>变量</code>的数据类型相同，而且<code>只能是常量或者字面常量</code>。</strong></li><li>当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，<strong>直到 break 语句出现才会跳出 switch 语句</strong>。</li><li>当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。<strong>case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句</strong>。</li><li>switch 语句可以包含一个 <strong>default 分支，该分支一般是 switch 语句的最后一个分支（可以在任何位置，但建议在最后一个）。default 在没有 case 语句的值和变量值相等的时候执行。default 分支<code>不需要 break 语句</code>。</strong></li></ul><p><strong>switch case 执行时，一定会先进行匹配，匹配成功返回当前 case 的值，再根据是否有 break，判断是否继续输出，或是跳出判断。</strong></p><h2 id="Java-Number-amp-Math-类"><a href="#Java-Number-amp-Math-类" class="headerlink" title="Java Number &amp; Math 类"></a>Java Number &amp; Math 类</h2><p><strong>一般地，当需要使用数字的时候，我们通常使用内置数据类型，如：byte、int、long、double 等。</strong></p><p>实例</p><pre><code>int a = 5000;float b = 13.65f;byte c = 0x4a;</code></pre><p>然而，在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情形。为了解决这个问题，<strong>Java 语言为每一个内置数据类型提供了对应的包装类</strong>。 </p><p>所有的包装类<code>（Integer、Long、Byte、Double、Float、Short）</code>都是<strong><code>抽象类 Number</code> 的子类</strong>。</p><p> <img src="https://www.runoob.com/wp-content/uploads/2013/12/number1.png" alt=""></p><p>这种由编译器特别支持的包装称为装箱，所以当<strong>内置数据类型被当作对象使用的时候，编译器会把内置类型<code>装箱</code>为包装类。</strong>相似的，<strong>编译器也可以把一个对象<code>拆箱</code>为内置类型</strong>。Number 类属于 java.lang 包。 </p><p>下面是一个使用 Integer 对象的实例：</p><pre><code>public class Test{   public static void main(String args[]){      Integer x = 5;      x =  x + 10;      System.out.println(x);    }}</code></pre><p>以上实例编译运行结果如下：</p><pre><code>15</code></pre><p><strong>当 x 被赋为整型值时，由于x是一个对象，所以编译器要对x进行<code>装箱</code>。然后，为了使x能进行加运算，所以要对x进行<code>拆箱</code>。</strong> </p><h3 id="Java-Math-类"><a href="#Java-Math-类" class="headerlink" title="Java Math 类"></a>Java Math 类</h3><p><strong>Java 的 Math 包含了用于执行基本数学运算的<code>属性</code>和<code>方法</code></strong>，如初等指数、对数、平方根和三角函数。</p><p><strong>Math 的方法都被定义为 <code>static</code>形式，通过 Math 类可以在<code>主函数</code>中直接调用。</strong></p><pre><code>public class Test {      public static void main (String []args)      {          System.out.println("90 度的正弦值：" + Math.sin(Math.PI/2));          System.out.println("0度的余弦值：" + Math.cos(0));          System.out.println("60度的正切值：" + Math.tan(Math.PI/3));          System.out.println("1的反正切值： " + Math.atan(1));          System.out.println("π/2的角度值：" + Math.toDegrees(Math.PI/2));          System.out.println(Math.PI);      }  }</code></pre><h3 id="Number-amp-Math-类方法"><a href="#Number-amp-Math-类方法" class="headerlink" title="Number &amp; Math 类方法"></a>Number &amp; Math 类方法</h3><p><a href="https://www.runoob.com/java/java-number.html" target="_blank" rel="noopener">常用方法请参考</a></p><h3 id="Math-的-floor-round-和-ceil-方法实例比较"><a href="#Math-的-floor-round-和-ceil-方法实例比较" class="headerlink" title="Math 的 floor,round 和 ceil 方法实例比较"></a>Math 的 floor,round 和 ceil 方法实例比较</h3><ul><li>Math.floor（地板）</li><li>Math.round（四舍五入）</li><li>Math.ceil（天花板）</li></ul><h2 id="Java-Character-类"><a href="#Java-Character-类" class="headerlink" title="Java Character 类"></a>Java Character 类</h2><p><strong><code>Character 类</code>用于对<code>单个字符</code>进行操作。</strong></p><p><strong><code>Character 类</code>在<code>对象</code>中包装一个基本类型 <code>char</code> 的值</strong></p><pre><code>char ch = 'a';// Unicode 字符表示形式char uniChar = '\u039A'; // 字符数组char[] charArray ={ 'a', 'b', 'c', 'd', 'e' };</code></pre><p>然而，在实际开发过程中，我们经常会遇到<strong>需要使用对象，而不是内置数据类型的情况</strong>。为了解决这个问题，Java语言为内置数据类型char提供了包装类Character类。 </p><p>Character类提供了一系列方法来操纵字符。你可以<strong>使用Character的构造方法创建一个Character类对象</strong>，例如： </p><pre><code>Character ch = new Character('a');</code></pre><p>在某些情况下，Java编译器会自动创建一个Character对象。</p><p>例如，<strong>将一个<code>char</code>类型的参数传递给需要一个<code>Character</code>类型参数的方法时，那么<code>编译器</code>会自动地将<code>char</code>类型参数转换为<code>Character</code>对象。 这种特征称为<code>装箱</code>，反过来称为<code>拆箱</code>。</strong> </p><p>实例</p><pre><code>// 原始字符 'a' 装箱到 Character 对象 ch 中Character ch = 'a';// 原始字符 'x' 用 test 方法装箱// 再返回拆箱的值到 'c'char c = test('x');</code></pre><h3 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h3><p><a href="https://www.runoob.com/java/java-character.html" target="_blank" rel="noopener">转义序列请参考</a></p><p><strong>当打印语句遇到一个转义序列时，编译器可以正确地对其进行解释。</strong></p><p>以下实例转义双引号并输出：</p><pre><code>public class Test {   public static void main(String args[]) {      System.out.println("访问\"菜鸟教程!\"");   }}</code></pre><p>以上实例编译运行结果如下： </p><pre><code>访问"菜鸟教程!"</code></pre><h3 id="Character-方法"><a href="#Character-方法" class="headerlink" title="Character 方法"></a>Character 方法</h3><p><a href="https://www.runoob.com/java/java-character.html" target="_blank" rel="noopener">Character类的方法请参考</a></p><h2 id="Java-String-类"><a href="#Java-String-类" class="headerlink" title="Java String 类"></a>Java String 类</h2><p>字符串广泛应用 在 Java 编程中，在 Java 中<strong>字符串属于对象</strong>，Java 提供了 <strong>String 类来创建和操作字符串</strong>。 </p><h3 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a>创建字符串</h3><p>创建字符串最简单的方式如下:</p><pre><code>String greeting = "菜鸟教程";</code></pre><p>在代码中遇到字符串常量时，这里的值是 “菜鸟教程””，编译器会使用该值创建一个 String 对象。</p><p>和其它对象一样，<strong>可以使用<code>关键字</code>和<code>构造方法</code>来创建 String 对象。</strong></p><p>String 类有<strong><code>11 种构造方法</code>，这些方法提供不同的参数来初始化字符串</strong>，比如提供一个字符数组参数:</p><pre><code>//StringDemo 字符串示范public class StringDemo{   public static void main(String args[]){      char[] helloArray = { 'r', 'u', 'n', 'o', 'o', 'b'};      String helloString = new String(helloArray);        System.out.println( helloString );   }}</code></pre><p>以上实例编译运行结果如下：</p><pre><code>runoob</code></pre><p><strong>注意:String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了</strong></p><p><strong>String 类是不可改变的解析</strong>，例如：</p><pre><code>String s = "Google";System.out.println("s = " + s);s = "Runoob";System.out.println("s = " + s);</code></pre><p>输出结果为：</p><pre><code>GoogleRunoob</code></pre><p>从结果上看是改变了，但为什么说String对象是不可变的呢？</p><p><strong>原因在于实例中的 s 只是一个 String 对象的引用，并不是对象本身，当执行 s = “Runoob”; 创建了一个新的对象 “Runoob”，而原来的 “Google” 还存在于内存中。</strong></p><p><img src="https://www.runoob.com/wp-content/uploads/2013/12/string-no-modify.png" alt=""></p><p>还可以根据 jdk 的源码来分析。</p><p><strong>字符串实际上就是一个 <code>char 数组</code>，并且内部就是<code>封装</code>了一个 char 数组</strong>。</p><p><strong>并且这里 char 数组是被 <code>final</code> 修饰的</strong>:</p><pre><code>public final class String    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {    /** The value is used for character storage. */    private final char value[];</code></pre><p><strong>并且 String 中的所有的方法，都是对于 <code>char 数组的改变</code>，只要是对它的改变，方法内部都是<code>返回一个新的 String 实例</code>。</strong></p><p>如果<strong>需要对字符串做很多修改，那么应该选择使用 <a href="https://www.runoob.com/java/java-stringbuffer.html" target="_blank" rel="noopener"> StringBuffer &amp; StringBuilder </a> 类。</strong> </p><h3 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h3><p><strong>用于<code>获取有关对象的信息的方法</code>称为<code>访问器方法</code>。</strong></p><p><strong>String 类的一个<code>访问器方法</code>是 <code>length() 方法</code>，它返回字符串对象包含的<code>字符数</code>。</strong></p><p>下面的代码执行后，len 变量等于 14:</p><pre><code>public class StringDemo {    public static void main(String args[]) {        String site = "www.runoob.com";        int len = site.length();        System.out.println( "菜鸟教程网址长度 : " + len );   }}</code></pre><p>以上实例编译运行结果如下：</p><pre><code>菜鸟教程网址长度 : 14</code></pre><h4 id="length-方法，length-属性和-size-方法的区别"><a href="#length-方法，length-属性和-size-方法的区别" class="headerlink" title="length() 方法，length 属性和 size() 方法的区别:"></a>length() 方法，length 属性和 size() 方法的区别:</h4><ul><li><strong><code>length() 方法</code>是针对<code>字符串</code>来说的，要<code>求一个字符串的长度</code>就要用到它的<code>length()方法</code>；</strong> </li><li><strong><code>length 属性</code>是针对 Java 中的<code>数组</code>来说的，要求<code>数组的长度</code>可以用其 <code>length 属性</code>；</strong> </li><li><strong>Java 中的 <code>size() 方法</code>是针对<code>泛型集合</code>说的, 如果想看这个<code>泛型有多少个元素</code>, 就调用此方法来查看!</strong><br><a href="https://www.runoob.com/java/java-generics.html" target="_blank" rel="noopener">泛型具体教程</a> </li></ul><p>演示这两个方法和一个属性的用法：</p><pre><code>import java.util.ArrayList;import java.util.List;public class Main {    public static void main(String[] args) {        String array[] = { "First", "Second", "Third" };        String a = "HelloWorld";        List&lt;String&gt; list = new ArrayList&lt;String&gt;();        list.add(a);        System.out.println("数组array的长度为" + array.length);        System.out.println("字符串a的长度为" + a.length());        System.out.println("list中元素个数为" + list.size());    }}</code></pre><p>输出的值为: </p><pre><code>数组array的长度为3字符串a的长度为10list中元素个数为1</code></pre><h3 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h3><p>String 类提供了连接两个字符串的方法：</p><pre><code>// 返回 string2 连接 string1 的新字符串string1.concat(string2);// 也可以对字符串常量使用 concat() 方法"我的名字是 ".concat("Runoob");// 更常用的是使用'+'操作符来连接字符串String string1 = "菜鸟教程网址：";     System.out.println("1、" + string1 + "www.runoob.com");  </code></pre><p>以上实例编译运行结果如下：</p><pre><code>1、菜鸟教程网址：www.runoob.com</code></pre><p>对于<strong>字符串的<code>加运算</code>，当编译成 class 文件时，会<code>自动编译</code>为 <code>StringBuffer</code> 来进行字符串的连接操作。</strong></p><p>如下列代码：</p><pre><code>String a = "a";String b = "b";String c = a + b;</code></pre><p>相当于：</p><pre><code>String c = new StringBuffer().append(a).append(b).toString();</code></pre><p>同时对于字符串常量池：</p><p><strong>当一个字符串是一个<code>字面量</code>时，它会被放到一个<code>常量池</code>中，等待<code>复用</code>。</strong></p><pre><code>String a = "saff";                 // 常量池String b = "saff";                 // 缓冲池String c = new String("saff");    // 堆内存中System.out.println(a.equal(b));  // trueSystem.out.println(a.equal(c));  // trueSystem.out.println(a == b);  // trueSystem.out.println(a == c);  // false两个对象的地址值不一样。</code></pre><p><strong>“==””这里的比较是针对两个String类型的<code>变量的引用</code>，也就是说如果两个String类型的变量，他们所引用的是同一个string对象（<code>指向同一个内存堆</code>），即返回true。</strong> </p><p><strong>String对象继承自Object，并且对equals方法进行了重写，用此方法进行比较时，其实是对String对象封装的<code>字符串内容</code>进行比较，相同返回true。</strong></p><p><strong>再来看<code>b</code>这个字符串对象并不是通过<code>new</code>来创建的，所以虚拟机并不会为它分配内存堆，而是先到String<code>缓冲池</code>中寻找是否存在与“saff”相同值的String对象存在，如果有，直接将该对象的引用赋值给str，若没有，则<code>虚拟机</code>会在<code>缓冲池</code>内创建此对象，其动作就是<code>new String(“saff”);</code>,然后把此String对象的引用赋值给b。</strong></p><p><strong>众所周知，通过 <code>new 关键字</code>来生成对象是在<code>堆区</code>进行的，而在堆区进行对象生成的过程是<code>不会去检测该对象是否已经存在</code>的。因此通过 new 来创建对象，创建出的<code>一定是不同的对象</code>，即使字符串的<code>内容是相同</code>的。</strong></p><p><strong>面试题1:</strong></p><pre><code>String s1="a"+"b"+"c";String s2="abc";System.out.println(s1==s2);System.out.println(s1.equals(s2));</code></pre><p><strong>java 中常量优化机制，<code>编译时</code> s1 已经成为 abc 在<code>常量池</code>中查找创建，s2 不需要再创建。</strong> </p><p><strong>面试题2:</strong></p><pre><code>String s1="ab";String s2="abc";String s3=s1+"c";System.out.println(s3==s2);         // falseSystem.out.println(s3.equals(s2));  // true</code></pre><p><strong>先在<code>常量池</code>中创建 ab ，地址指向 s1, 再创建 abc ，指向 s2。对于 s3，先创建<code>StringBuilder（或 StringBuffer）对象</code>，通过 append 连接得到 abc ,再调用 <code>toString()</code> 转换得到的地址指向 s3。故 (s3==s2) 为 false。</strong></p><h3 id="创建格式化字符串"><a href="#创建格式化字符串" class="headerlink" title="创建格式化字符串"></a>创建格式化字符串</h3><p>我们知道输出格式化数字可以使用 printf() 和 format() 方法。</p><p><strong>String 类使用静态方法 <code>format()</code> 返回一个<code>String 对象</code>而<code>不是 PrintStream 对象</code>。</strong></p><p><strong>String 类的静态方法 format() 能用来<code>创建可复用的格式化字符串</code>，而不仅仅是用于一次打印输出。</strong></p><pre><code>String fs;fs = String.format("浮点型变量的值为 " +                   "%f, 整型变量的值为 " +                   " %d, 字符串变量的值为 " +                   " %s", floatVar, intVar, stringVar);</code></pre><h3 id="String-方法"><a href="#String-方法" class="headerlink" title="String 方法"></a>String 方法</h3><p>请参考：<a href="https://www.runoob.com/java/java-string.html" target="_blank" rel="noopener">String支持的方法</a></p><h2 id="Java-StringBuffer-和-StringBuilder-类"><a href="#Java-StringBuffer-和-StringBuilder-类" class="headerlink" title="Java StringBuffer 和 StringBuilder 类"></a>Java StringBuffer 和 StringBuilder 类</h2><p><strong>当对字符串进行修改的时候，需要使用 <code>StringBuffer</code> 和 <code>StringBuilder</code> 类。</strong> </p><p><strong>和 String 类不同的是，<code>StringBuffer</code> 和 <code>StringBuilder</code> 类的对象<code>能够被多次的修改</code>，并且<code>不产生新的未使用对象</code>。</strong> </p><p>StringBuilder 类在 Java 5 中被提出，<strong>它和 StringBuffer 之间的最大不同在于 <code>StringBuilder 的方法不是线程安全的</code>（不能同步访问）。</strong> </p><p><strong>由于 <code>StringBuilder</code> 相较于 <code>StringBuffer</code> 有<code>速度优势</code>，所以多数情况下建议使用 <code>StringBuilder</code> 类。然而在应用程序要求<code>线程安全</code>的情况下，则<code>必须使用 StringBuffer</code>类。</strong> </p><pre><code>public class Test{  public static void main(String args[]){    StringBuffer sBuffer = new StringBuffer("菜鸟教程官网：");    sBuffer.append("www");    sBuffer.append(".runoob");    sBuffer.append(".com");    System.out.println(sBuffer);    }}</code></pre><p>以上实例编译运行结果如下：</p><pre><code>菜鸟教程官网：www.runoob.com</code></pre><h3 id="StringBuffer-方法"><a href="#StringBuffer-方法" class="headerlink" title="StringBuffer 方法"></a>StringBuffer 方法</h3><p><a href="https://www.runoob.com/java/java-stringbuffer.html" target="_blank" rel="noopener">StringBuffer 类支持的主要方法</a></p><h2 id="Java-数组"><a href="#Java-数组" class="headerlink" title="Java 数组"></a>Java 数组</h2><p><strong>Java 语言中提供的数组是用来存储<code>固定大小</code>的<code>同类型</code>元素。</strong></p><h3 id="声明数组变量"><a href="#声明数组变量" class="headerlink" title="声明数组变量"></a>声明数组变量</h3><p><strong>首先必须<code>声明</code>数组变量，才能在程序中使用数组。</strong>下面是声明数组变量的语法：</p><pre><code>dataType[] arrayRefVar;   // 首选的方法或dataType arrayRefVar[];  // 效果相同，但不是首选方法</code></pre><p><strong>注意: 建议使用 <code>dataType[] arrayRefVar</code> 的声明风格声明数组变量。 <code>dataType arrayRefVar[]</code> 风格是来自 <code>C/C++ 语言</code> ，在Java中采用是为了<code>让 C/C++ 程序员能够快速理解java语言</code>。</strong> </p><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><p><strong>Java语言使用new操作符来<code>创建</code>数组，</strong>语法如下：</p><pre><code>arrayRefVar = new dataType[arraySize];</code></pre><p>上面的语法语句做了两件事：</p><ul><li>使用 dataType[arraySize] 创建了一个数组。</li><li><strong>把新创建的数组的<code>引用赋值</code>给变量 arrayRefVar。</strong></li></ul><p><strong>数组变量的<code>声明，和创建数组</code>可以用一条语句完成，</strong>如下所示：</p><pre><code>dataType[] arrayRefVar = new dataType[arraySize];</code></pre><p>另外，你还可以使用如下的方式创建数组。</p><pre><code>dataType[] arrayRefVar = {value0, value1, ..., valuek};</code></pre><p><strong>数组的<code>元素是通过索引访问的</code>。数组索引从 0 开始，所以索引值从 <code>0 到 arrayRefVar.length-1</code>。</strong></p><pre><code>public class TestArray {   public static void main(String[] args) {      // 数组大小      int size = 10;      // 定义数组      double[] myList = new double[size];      myList[0] = 5.6;      myList[1] = 4.5;      myList[2] = 3.3;      myList[3] = 13.2;      myList[4] = 4.0;      myList[5] = 34.33;      myList[6] = 34.0;      myList[7] = 45.45;      myList[8] = 99.993;      myList[9] = 11123;      // 计算所有元素的总和      double total = 0;      for (int i = 0; i &lt; size; i++) {         total += myList[i];      }      System.out.println("总和为： " + total);   }}</code></pre><p>以上实例输出结果为：</p><pre><code>总和为： 11367.373</code></pre><h3 id="处理数组"><a href="#处理数组" class="headerlink" title="处理数组"></a>处理数组</h3><pre><code>public class TestArray {   public static void main(String[] args) {      double[] myList = {1.9, 2.9, 3.4, 3.5};      // 打印所有数组元素      for (int i = 0; i &lt; myList.length; i++) {         System.out.println(myList[i] + " ");      }      // 计算所有元素的总和      double total = 0;      for (int i = 0; i &lt; myList.length; i++) {         total += myList[i];      }      System.out.println("Total is " + total);      // 查找最大元素      double max = myList[0];      for (int i = 1; i &lt; myList.length; i++) {         if (myList[i] &gt; max) max = myList[i];      }      System.out.println("Max is " + max);   }}</code></pre><p>以上实例编译运行结果如下：</p><pre><code>1.92.93.43.5Total is 11.7Max is 3.5</code></pre><h4 id="For-Each-循环"><a href="#For-Each-循环" class="headerlink" title="For-Each 循环"></a>For-Each 循环</h4><p>JDK 1.5 引进了一种新的循环类型，被称为<strong><code>For-Each 循环</code>或者<code>加强型循环</code></strong>，它能在不使用下标的情况下遍历数组。</p><p>语法格式如下：</p><pre><code>for(type element: array){    System.out.println(element);}</code></pre><p>实例</p><pre><code>public class TestArray {   public static void main(String[] args) {      double[] myList = {1.9, 2.9, 3.4, 3.5};      // 打印所有数组元素      for (double element: myList) {         System.out.println(element);      }   }}</code></pre><p>以上实例编译运行结果如下：</p><pre><code>1.92.93.43.5</code></pre><h3 id="数组作为函数的参数"><a href="#数组作为函数的参数" class="headerlink" title="数组作为函数的参数"></a>数组作为函数的参数</h3><p><strong>数组可以<code>作为参数传递给方法</code>。</strong></p><p>例如，下面的例子就是一个打印 int 数组中元素的方法:</p><pre><code>public static void printArray(int[] array) {  for (int i = 0; i &lt; array.length; i++) {    System.out.print(array[i] + " ");  }}</code></pre><p>下面例子调用 printArray 方法打印出 3，1，2，6，4 和 2：</p><pre><code>printArray(new int[]{3, 1, 2, 6, 4, 2}); //注意这种写法</code></pre><h3 id="数组作为函数的返回值"><a href="#数组作为函数的返回值" class="headerlink" title="数组作为函数的返回值"></a>数组作为函数的返回值</h3><pre><code>public static int[] reverse(int[] list) {  int[] result = new int[list.length];  for (int i = 0, j = result.length - 1; i &lt; list.length; i++, j--) {    result[j] = list[i];  }  return result;}</code></pre><p><strong>以上实例中 <code>result 数组</code>作为<code>函数的返回值</code>。</strong></p><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p><strong><code>多维数组</code>可以看成是<code>数组的数组</code>，比如<code>二维数组</code>就是一个<code>特殊的一维数组</code>，其<code>每一个元素</code>都是一个<code>一维数组</code></strong>，例如：</p><pre><code>String str[][] = new String[3][4];</code></pre><h4 id="多维数组的动态初始化（以二维数组为例）"><a href="#多维数组的动态初始化（以二维数组为例）" class="headerlink" title="多维数组的动态初始化（以二维数组为例）"></a>多维数组的动态初始化（以二维数组为例）</h4><p>直接为每一维分配空间，格式如下： </p><pre><code>type[][] typeName = new type[typeLength1][typeLength2];</code></pre><p><strong>type 可以为<code>基本数据类型</code>和<code>复合数据类型</code>，arraylength1 和 arraylength2 <code>必须为正整数</code>，<code>arraylength1 为行数</code>，<code>arraylength2 为列数</code>。</strong></p><p>例如：</p><pre><code>int a[][] = new int[2][3];</code></pre><p>解析：</p><p>二维数组 a 可以看成一个<strong>两行三列的数组。</strong></p><p>**从最高维开始，分别为每一维分配空间，例如： </p><pre><code>String s[][] = new String[2][];s[0] = new String[2];s[1] = new String[3];s[0][0] = new String("Good");s[0][1] = new String("Luck");s[1][0] = new String("to");s[1][1] = new String("you");s[1][2] = new String("!");</code></pre><p>解析： </p><p><strong><code>s[0]=new String[2]</code> 和 <code>s[1]=new String[3]</code> 是为最高维分配引用空间，也就是为最高维限制其能保存数据的最长的长度，然后再为其每个数组元素单独分配空间 <code>s[0][0]=new String("Good")</code> 等操作。</strong></p><h3 id="多维数组的引用（以二维数组为例）"><a href="#多维数组的引用（以二维数组为例）" class="headerlink" title="多维数组的引用（以二维数组为例）"></a>多维数组的引用（以二维数组为例）</h3><p><strong>对二维数组中的每个元素，引用方式为 <code>arrayName[index1][index2]</code></strong>，例如：</p><h3 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h3><p><strong><code>java.util.Arrays</code> 类能方便地<code>操作数组</code>，它提供的<code>所有方法都是静态</code>的。</strong></p><p>具有以下功能：</p><ul><li><strong>给数组赋值</strong>：通过 <strong>fill 方法</strong>。</li><li><strong>对数组排序</strong>：通过 <strong>sort 方法,按升序。</strong></li><li><strong>比较数组</strong>：通过 <strong>equals 方法</strong>比较数组中元素值是否相等。</li><li><strong>查找数组元素</strong>：通过 <strong><code>binarySearch 方法</code>能对<code>排序好</code>的数组进行<code>二分查找法</code></strong>操作。</li></ul><p><a href="https://www.runoob.com/java/java-array.html" target="_blank" rel="noopener">具体说明请查看</a></p><h2 id="Java-日期时间"><a href="#Java-日期时间" class="headerlink" title="Java 日期时间"></a>Java 日期时间</h2><p><strong><code>java.util 包</code>提供了 <code>Date</code> 类来封装当前的日期和时间。 Date 类提供<code>两个构造函数</code>来实例化 Date 对象。</strong></p><p><strong>第一个构造函数使用<code>当前日期和时间来初始化对象</code>。</strong></p><pre><code>Date( )</code></pre><p><strong>第二个构造函数<code>接收一个参数</code>，该参数是从<code>1970年1月1日起的毫秒数</code>。</strong> </p><pre><code>Date(long millisec)</code></pre><p>Date对象创建以后，可以调用下面的方法。</p><p><a href="https://www.runoob.com/java/java-date-time.html" target="_blank" rel="noopener">具体方法</a></p><h3 id="获取当前日期时间"><a href="#获取当前日期时间" class="headerlink" title="获取当前日期时间"></a>获取当前日期时间</h3><p>Java中获取当前日期和时间很简单，使用 <strong><code>Date 对象</code>的 <code>toString() 方法</code>来打印当前日期和时间</strong>，如下所示： </p><pre><code>import java.util.Date;public class DateDemo {   public static void main(String args[]) {       // 初始化 Date 对象       Date date = new Date();       // 使用 toString() 函数显示日期时间       System.out.println(date.toString());   }}</code></pre><p>以上实例编译运行结果如下:</p><pre><code>Wed Apr 15 20:54:19 CST 2020</code></pre><h3 id="日期比较"><a href="#日期比较" class="headerlink" title="日期比较"></a>日期比较</h3><p>Java使用以下三种方法来比较两个日期：</p><ul><li><strong>使用 <code>getTime()</code>方法获取<code>一个日期</code>（自1970年1月1日经历的毫秒数值），然后<code>比较这两个值</code>。</strong></li><li><strong>使用方法 <code>before()，after() 和 equals()</code></strong>。例如，一个月的12号比18号早，则 new Date(99, 2, 12).before(new Date (99, 2, 18)) 返回true。</li><li><strong>使用 <code>compareTo()</code>方法，它是由 Comparable 接口定义的，Date 类实现了这个接口。</strong></li></ul><h3 id="使用-SimpleDateFormat-格式化日期-重要"><a href="#使用-SimpleDateFormat-格式化日期-重要" class="headerlink" title="使用 SimpleDateFormat 格式化日期 (重要)"></a>使用 SimpleDateFormat 格式化日期 (重要)</h3><p><strong><code>SimpleDateFormat</code> 是一个以<code>语言环境</code>敏感的方式来<code>格式化和分析日期的类</code>。需要引进<code>import java.text.*;</code>包。</strong> SimpleDateFormat 允许你选择任何<code>用户自定义日期时间格式</code>来运行。**例如： </p><pre><code>import  java.util.*;import java.text.*;public class DateDemo {   public static void main(String args[]) {      Date dNow = new Date( );      SimpleDateFormat ft = new SimpleDateFormat ("yyyy-MM-dd HH:mm:ss");      System.out.println("当前时间为: " + ft.format(dNow));   }}</code></pre><p>以上实例编译运行结果如下:</p><pre><code>2020-04-15 21:53:50</code></pre><p>解析：</p><pre><code>SimpleDateFormat ft = new SimpleDateFormat ("yyyy-MM-dd hh:mm:ss");</code></pre><p><strong>这一行代码确立了转换的格式，其中 <code>yyyy</code> 是完整的<code>公元年</code>，<code>MM</code> 是<code>月份</code>，<code>dd</code> 是<code>日期</code>，<code>HH:mm:ss</code> 是<code>时、分、秒</code></strong>。</p><p><strong>注意: 有的格式大写，有的格式小写，例如 <code>MM</code> 是<code>月份</code>，<code>mm</code> 是<code>分</code>；<code>HH</code> 是 <code>24 小时制</code>，而 <code>hh</code> 是 <code>12 小时制</code>。</strong></p><h3 id="日期和时间的格式化编码"><a href="#日期和时间的格式化编码" class="headerlink" title="日期和时间的格式化编码"></a>日期和时间的格式化编码</h3><p><a href="https://www.runoob.com/java/java-date-time.html" target="_blank" rel="noopener">具体参考</a></p><h3 id="使用printf格式化日期"><a href="#使用printf格式化日期" class="headerlink" title="使用printf格式化日期"></a>使用printf格式化日期</h3><p><strong>printf 方法可以很轻松地格式化时间和日期。使用<code>两个字母格式</code>，它以 <code>%t 开头</code>并且以下面<code>表格中的一个字母结尾</code>。</strong></p><p><a href="https://www.runoob.com/java/java-date-time.html" target="_blank" rel="noopener">具体参考</a></p><p>实例</p><pre><code>import java.util.Date;public class DateDemo {  public static void main(String args[]) {     // 初始化 Date 对象     Date date = new Date();     //c的使用      System.out.printf("全部日期和时间信息：%tc%n",date);   // %n代表换行           //f的使用      System.out.printf("年-月-日格式：%tF%n",date);      //d的使用      System.out.printf("月/日/年格式：%tD%n",date);      //r的使用      System.out.printf("HH:MM:SS PM格式（12时制）：%tr%n",date);      //t的使用      System.out.printf("HH:MM:SS格式（24时制）：%tT%n",date);      //R的使用      System.out.printf("HH:MM格式（24时制）：%tR",date);    }}</code></pre><p>以上实例编译运行结果如下:</p><pre><code>全部日期和时间信息：星期一 九月 10 10:43:36 CST 2012  年-月-日格式：2012-09-10  月/日/年格式：09/10/12  HH:MM:SS PM格式（12时制）：10:43:36 上午  HH:MM:SS格式（24时制）：10:43:36  HH:MM格式（24时制）：10:43</code></pre><h3 id="Java-休眠-sleep"><a href="#Java-休眠-sleep" class="headerlink" title="Java 休眠(sleep)"></a>Java 休眠(sleep)</h3><p><strong><code>sleep()</code>使当前线程进入<code>停滞</code>状态（<code>阻塞当前线程</code>），<code>让出CPU</code>的使用、目的是<code>不让当前线程独自霸占该进程所获的CPU资源</code>，以留一定时间<code>给其他线程执行的机会</code>。</strong><br>你可以让程序休眠一毫秒的时间或者到您的计算机的寿命长的任意段时间。例如，下面的程序会休眠3秒：</p><pre><code>import java.util.*;public class SleepDemo {   public static void main(String args[]) {      try {          System.out.println(new Date( ) + "\n");          Thread.sleep(1000*3);   // Thread为线程类，休眠3秒         System.out.println(new Date( ) + "\n");       } catch (Exception e) {           System.out.println("Got an exception!");       }   }}</code></pre><p>以上实例编译运行结果如下:</p><pre><code>Thu Apr 16 19:09:58 CST 2020Thu Apr 16 19:10:01 CST 2020</code></pre><h3 id="测量时间"><a href="#测量时间" class="headerlink" title="测量时间"></a>测量时间</h3><pre><code>import java.util.*;public class DiffDemo {   public static void main(String args[]) {      try {         long start = System.currentTimeMillis( );         System.out.println(new Date( ) + "\n");         Thread.sleep(5*60*10);         System.out.println(new Date( ) + "\n");         long end = System.currentTimeMillis( );         long diff = end - start;         System.out.println("Difference is : " + diff);      } catch (Exception e) {         System.out.println("Got an exception!");      }   }}</code></pre><p>以上实例编译运行结果如下:</p><pre><code>Thu Apr 16 19:15:37 CST 2020Thu Apr 16 19:15:40 CST 2020Difference is : 3018</code></pre><h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><p>我们现在已经能够格式化并创建一个日期对象了，但是我们如何才能<strong>设置和获取日期数据的特定部分呢，比如说小时，日，或者分钟</strong>? 我们又如何<strong>在日期的这些部分加上或者减去值</strong>呢? 答案是使用Calendar 类。 </p><p><strong>Calendar类的功能要比Date类强大很多</strong>，而且在实现方式上也比Date类要复杂一些。</p><p>Calendar类是一个<strong><code>抽象类</code>，在实际使用时实现特定的子类的对象，创建对象的<code>过程对程序员来说是透明的</code>，只需要使用<code>getInstance</code>方法创建即可。</strong></p><h4 id="创建一个代表系统当前日期的Calendar对象"><a href="#创建一个代表系统当前日期的Calendar对象" class="headerlink" title="创建一个代表系统当前日期的Calendar对象"></a>创建一个代表系统<code>当前日期</code>的Calendar对象</h4><pre><code>Calendar c = Calendar.getInstance();//默认是当前日期</code></pre><h4 id="创建一个指定日期的Calendar对象"><a href="#创建一个指定日期的Calendar对象" class="headerlink" title="创建一个指定日期的Calendar对象"></a>创建一个指定日期的Calendar对象</h4><p>使用Calendar类代表特定的时间，需要首先创建一个Calendar的对象，然后再设定该对象中的年月日参数来完成。</p><pre><code>//创建一个代表2009年6月12日的Calendar对象Calendar c1 = Calendar.getInstance();c1.set(2009, 6 - 1, 12);</code></pre><h4 id="Calendar类对象字段类型"><a href="#Calendar类对象字段类型" class="headerlink" title="Calendar类对象字段类型"></a>Calendar类对象字段类型</h4><p><a href="https://www.runoob.com/java/java-date-time.html" target="_blank" rel="noopener">常量具体参考</a></p><h4 id="Calendar类对象信息的获得"><a href="#Calendar类对象信息的获得" class="headerlink" title="Calendar类对象信息的获得"></a>Calendar类对象信息的获得</h4><pre><code>Calendar c1 = Calendar.getInstance();// 获得年份int year = c1.get(Calendar.YEAR);// 获得月份int month = c1.get(Calendar.MONTH) + 1;// 获得日期int date = c1.get(Calendar.DATE);// 获得小时int hour = c1.get(Calendar.HOUR_OF_DAY);// 获得分钟int minute = c1.get(Calendar.MINUTE);// 获得秒int second = c1.get(Calendar.SECOND);// 获得星期几（注意（这个与Date类是不同的）：1代表星期日、2代表星期1、3代表星期二，以此类推）int day = c1.get(Calendar.DAY_OF_WEEK);</code></pre><h2 id="Java-正则表达式"><a href="#Java-正则表达式" class="headerlink" title="Java 正则表达式"></a>Java 正则表达式</h2><p>正则表达式<strong>定义了字符串的模式。</strong></p><p>正则表达式<strong>可以用来搜索、编辑或处理文本。</strong></p><p>正则表达式<strong>并不仅限于某一种语言，但是在每种语言中有细微的差别。</strong></p><p>给定一个正则表达式和另一个字符串，我们可以达到如下的目的：</p><ul><li><strong>给定的字符串是否符合正则表达式的<code>过滤逻辑</code>（称作”<code>匹配</code>“）</strong></li><li><strong>可以通过正则表达式，<code>从字符串中获取我们想要的特定部分</code></strong></li></ul><h3 id="正则表达式实例"><a href="#正则表达式实例" class="headerlink" title="正则表达式实例"></a>正则表达式实例</h3><p><strong>一个字符串其实就是一个简单的正则表达式</strong>，例如 Hello World 正则表达式匹配 “Hello World” 字符串。</p><p><strong><code>.（点号）</code>也是一个正则表达式，它匹配<code>任何一个字符</code>如：”a” 或 “1”。</strong></p><p>下表列出了一些正则表达式的实例及描述：<br><img src="https://cdn.jsdelivr.net/gh/Kanbaraleo/imgs/images/TIM%E5%9B%BE%E7%89%8720200416204116.png" alt=""></p><p><strong><code>java.util.regex 包</code> (注意引入该包) 主要包括以下<code>三个类</code>：</strong></p><ul><li><strong>Pattern 类：</strong><br><strong>pattern <code>对象是一个正则表达式的编译表示</code>。Pattern 类<code>没有公共构造方法</code>。要创建一个 Pattern 对象，你必须首先<code>调用其公共静态编译方法</code>，它返回一个 Pattern 对象。该方法<code>接受一个正则表达式作为它的第一个参数</code>。</strong></li><li><strong>Matcher 类：</strong><br>Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你<strong>需要调用 <code>Pattern</code>对象的 <code>matcher</code>方法<code>来</code>获得一个 Matcher 对象`。</strong></li><li>PatternSyntaxException：<br>PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</li></ul><p>以下实例中使用了正则表达式 .<em>runoob.</em> 用于查找字符串中是否包了 runoob 子串：</p><pre><code>import java.util.regex.*;class RegexExample1{   public static void main(String args[]){      String content = "I am noob " +        "from runoob.com.";      String pattern = ".*runoob.*";  //定义正则表达式，.*表示零次或多次匹配前面的任意字符      boolean isMatch = Pattern.matches(pattern, content);   //public boolean matches() 尝试将整个区域与模式匹配。      System.out.println("字符串中是否包含了 'runoob' 子字符串? " + isMatch);   }}</code></pre><p>实例输出结果为：</p><pre><code>字符串中是否包含了 'runoob' 子字符串? true </code></pre><h3 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h3><p>在其他语言中，\ 表示：我想要在正则表达式中插入一个普通的（字面上的）反斜杠，请不要给它任何特殊的意义。</p><p><strong>在 Java 中，\ 表示：我要插入一个<code>正则表达式的反斜线</code>，所以<code>其后的字符具有特殊的意义</code>。</strong></p><p>所以，在其他的语言中（如Perl），一个反斜杠 \ 就足以具有转义的作用，而在 <strong>Java 中正则表达式中则需要有<code>两个反斜杠</code>才能被<code>解析为其他语言中的转义作用</code>。也可以简单的理解在 <code>Java 的正则表达式中，</code>两个 \ 代表<code>其他语言中的</code>一个 `，这也就是为什么表示<code>一位数字</code>的正则表达式是 <code>\\d</code>，而表示一个普通的<code>反斜杠是 \\\\</code>。</strong></p><p><a href="https://www.runoob.com/java/java-regular-expressions.html" target="_blank" rel="noopener">字符说明参考</a></p><h3 id="Matcher-类的方法"><a href="#Matcher-类的方法" class="headerlink" title="Matcher 类的方法"></a>Matcher 类的方法</h3><h4 id="start-和-end-方法"><a href="#start-和-end-方法" class="headerlink" title="start 和 end 方法"></a>start 和 end 方法</h4><p>下面是一个对单词 “cat” 出现在输入字符串中出现次数进行计数的例子： </p><pre><code>import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexMatches{    private static final String REGEX = "\\bcat\\b";    // 按指定模式在字符串查找    private static final String INPUT =                                    "cat cat cat cattie cat";    public static void main( String args[] ){       Pattern p = Pattern.compile(REGEX);// 调用其公共静态编译方法compile()创建 Pattern 对象       Matcher m = p.matcher(INPUT); // 获取 matcher 对象       int count = 0;       while(m.find()) //public boolean find() 尝试查找与该模式匹配的输入序列的下一个子序列。       {         count++;         System.out.println("Match number "+count);         System.out.println("start(): "+m.start());//返回以前匹配的初始索引。         System.out.println("end(): "+m.end()); //返回最后匹配字符之后的偏移量(最后匹配字符索引加1)。      }   }}</code></pre><p>以上实例编译运行结果如下：</p><pre><code>Match number 1start(): 0end(): 3Match number 2start(): 4end(): 7Match number 3start(): 8end(): 11Match number 4start(): 19end(): 22</code></pre><p><strong><code>Start</code>方法返回在以前的匹配操作期间，由给定组所捕获的<code>子序列的初始索引</code>，<code>end</code>方法<code>最后一个匹配字符的索引加 1</code>。</strong> </p><p><strong>下面的例子讲String类的matcheS()方法</strong>，校验QQ号，要求：必须是5~15位数字，0不能开头。没有正则表达式之前</p><pre><code>public class regex {    public static void main(String[] args) {            checkQQ2("0123134");    }    public static void checkQQ2(String qq) {                                                                        String reg = "[1-9][0-9]{4,14}";                              System.out.println(qq.matches(reg)?"合法qq":"非法qq");                                     }}</code></pre><p><strong>注意：<code>boolean matches(String regex)</code>告知此字符串是否匹配给定的正则表达式。</strong></p><p><strong><code>String.matches(regex)</code>方法本质调用了<code>Pattern.matches(regex, str)</code>，而该方法调<code>Pattern.compile(regex).matcher(input).matches()方法</code>，而<code>Matcher.matches()</code>方法试图将<code>整个区域与模式匹配</code>，如果匹配成功，则可以通过开始、结束和组方法获得更多信息。</strong></p><p><strong>总的来说，<code>String.matches(regex)</code>，<code>Pattern.matches(regex, str)</code>，<code>Matcher.matches()</code>都是<code>全局匹配</code>的，相当于”^regex$”的正则匹配结果。如果<code>不想使用全局匹配</code>则可以使用<code>Matcher.find()</code>方法进行<code>部分查找</code>。</strong></p><pre><code>public boolean find() 尝试查找与该模式匹配的输入序列的下一个子序列。public boolean find(int start）重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。</code></pre><h2 id="Java-方法-非常重要"><a href="#Java-方法-非常重要" class="headerlink" title="Java 方法(非常重要)"></a>Java 方法(非常重要)</h2><p>在前面几个章节中我们经常使用到 System.out.println()，那么它是什么呢？</p><ul><li>println() 是一个方法。</li><li>System 是系统类。</li><li>out 是标准输出对象。</li></ul><p>这句话的用法是<strong>调用<code>系统类 System</code> 中的<code>标准输出对象 out</code> 中的<code>方法 println()</code>。</strong> </p><h3 id="那么什么是方法呢？"><a href="#那么什么是方法呢？" class="headerlink" title="那么什么是方法呢？"></a>那么什么是方法呢？</h3><p><strong>Java方法是语句的集合</strong>，它们在一起执行一个功能。</p><ul><li>方法是解决一类问题的步骤的有序组合</li><li>方法包含于类或对象中</li><li>方法在程序中被创建，在其他地方被引用</li></ul><h3 id="方法的优点"><a href="#方法的优点" class="headerlink" title="方法的优点"></a>方法的优点</h3><ol><li>使程序变得更简短而清晰。</li><li>有利于程序维护。</li><li>可以提高程序开发的效率。</li><li>提高了代码的重用性。</li></ol><h3 id="方法的命名规则"><a href="#方法的命名规则" class="headerlink" title="方法的命名规则"></a>方法的命名规则</h3><p><strong>方法的名字的第一个单词应以<code>小写字母作为开头</code>，后面的单词则用<code>大写字母开头写</code>，不使用连接符。例如：addPerson。</strong></p><h3 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h3><p>一般情况下，定义一个方法包含以下语法：</p><pre><code>修饰符 返回值类型 方法名(参数类型 参数名){    ...    方法体    ...    return 返回值;}</code></pre><p><strong>方法包含一个<code>方法头</code>和一个<code>方法体</code>。</strong>下面是一个方法的所有部分：</p><ul><li><strong>修饰符</strong>：修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。</li><li><strong>返回值类型</strong> ：<strong>方法<code>可能</code>会返回值。</strong>returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字void。</li><li><strong>方法名</strong>：是方法的实际名称。方法名和参数表共同构成方法签名。</li><li><strong>参数类型</strong>：参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</li><li><strong>方法体</strong>：方法体包含具体的语句，定义该方法的功能。</li></ul><img src="//www.runoob.com/wp-content/uploads/2013/12/12-130Q1220955916.jpg"><p><strong>注意： 在一些其它语言中方法指<code>过程</code>和<code>函数</code>。一个<code>返回非void类型</code>返回值的方法称为<code>函数</code>；一个<code>返回void类型</code>返回值的方法叫做<code>过程</code>。</strong> </p><p>下面的方法包含 2 个参数 num1 和 num2，它返回这两个参数的最大值。 </p><pre><code>/** 返回两个整型变量数据的较大值 */public static int max(int num1, int num2) {   int result;   if (num1 &gt; num2)      result = num1;   else      result = num2;   return result; }</code></pre><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p><strong>Java 支持两种调用方法的方式，根据<code>方法是否返回值</code>来选择。</strong> </p><p><strong>当程序<code>调用一个方法</code>时，程序的<code>控制权交给了被调用的方法</code>。当被调用方法的<code>返回语句执行</code>或者<code>到达方法体闭括号时候</code>交还控制权给程序。</strong> </p><p><strong>当方法<code>返回一个值</code>的时候，方法<code>调用通常被当做一个值</code>。</strong>例如： </p><pre><code>int larger = max(30, 40);</code></pre><p><strong>如果方法<code>返回值是void</code>，方法<code>调用一定是一条语句</code>。</strong>例如，方法println返回void。下面的调用是个语句： </p><pre><code>System.out.println("欢迎访问菜鸟教程！");</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>下面的例子演示了如何定义一个方法，以及如何调用它：</p><pre><code>public class TestMax {   /** 主方法 */   public static void main(String[] args) {      int i = 5;      int j = 2;      int k = max(i, j);      System.out.println( i + " 和 " + j + " 比较，最大值是：" + k);   }   /** 返回两个整数变量较大的值 */   public static int max(int num1, int num2) {      int result;      if (num1 &gt; num2)         result = num1;      else         result = num2;      return result;    }}</code></pre><p>以上实例编译运行结果如下：</p><pre><code>5 和 2 比较，最大值是：5</code></pre><p>这个程序包含 main 方法和 max 方法。<strong><code>main</code> 方法是被 <code>JVM 调用</code>的</strong>，除此之外，main 方法和其它方法没什么区别。 </p><p><strong><code>main 方法的头部是不变的</code>，如例子所示，带修饰符 <code>public 和 static</code>,<code>返回 void 类型值</code>，<code>方法名字是 main</code>,此外带个一个 String[] 类型参数。<code>String[]</code> 表明参数是<code>字符串数组</code>。</strong> </p><h3 id="通过值传递参数"><a href="#通过值传递参数" class="headerlink" title="通过值传递参数"></a>通过值传递参数</h3><p>传递两个参数调用方法。有趣的是，<strong>方法被调用后，实参的值并没有改变。(值传递，并非引用传递)</strong> </p><h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><p>上面使用的max方法仅仅适用于int型数据。但如果你想得到两个浮点类型数据的最大值呢？</p><p><strong>解决方法是创建另一个有<code>相同名字</code>但<code>参数不同</code>的方法</strong>，如下面代码所示：</p><pre><code>public static double max(double num1, double num2) {  if (num1 &gt; num2)    return num1;  else    return num2;}</code></pre><p>如果你调用max方法时传递的是int型参数，则 int型参数的max方法就会被调用；</p><ul><li>如果传递的是double型参数，则double类型的max方法体会被调用，这叫做<strong>方法重载</strong>； </li><li>就是说<strong>一个类的两个方法拥有<code>相同的名字</code>，但是有<code>不同的参数列表</code>。</strong></li><li><strong>Java编译器根据<code>方法签名</code>判断哪个方法应该被调用。</strong> </li><li>方法重载可以让程序更清晰易读。执行密切相关任务的方法应该使用相同的名字。 </li><li><strong>重载的方法<code>必须拥有不同的参数列表</code>,方法的<code>返回类型、修饰符</code>可以相同，也可不同。</strong></li></ul><h3 id="方法重写-注意与重载区分"><a href="#方法重写-注意与重载区分" class="headerlink" title="方法重写(注意与重载区分)"></a>方法重写(注意与重载区分)</h3><p>在Java和其他一些高级面向对象的编程语言中，<strong>子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。<code>方法重写</code>又称<code>方法覆盖</code>。</strong></p><p><strong>若子类中的方法与父类中的<code>某一方法</code>具有相同的<code>方法名</code>、<code>返回类型</code>和<code>参数表</code>，则新方法将<code>覆盖原有的方法</code>。 如需<code>父类中原有的方法</code>，可使用<code>super</code>关键字，该关键字引用了<code>当前类的父类</code>。</strong></p><p>关于方法重写的一些特性：</p><ul><li>发生方法<strong>重写的两个方法<code>返回值</code>、<code>方法名</code>、<code>参数列表</code>必须<code>完全一致</code>(子类重写父类的方法)</strong></li><li>子类抛出的异常下不能超过父类相应方法抛出的异常(<strong>子类异常不能大于父类异常</strong>)</li><li>子类<strong><code>方法</code>的访问级别<code>不能低于</code>父类<code>相应方法</code>的访问级别</strong>(子类访问级别不能低于父类访问级别)</li></ul><p>根据2，3条可以确定第一条，子类重写父类方法的返回值类型不能大于父类方法的返回值类型，即是说子类方法的返回值必须和父类方法的返回值相同或是其子类。</p><p><strong>注意：</strong></p><ul><li>方法重写与方法重载不同，<strong>方法的<code>重载</code>是方法的<code>参数个数或类型不同</code>，<code>方法名相同</code>。</strong></li><li><strong>方法重写是要注意权限的问题，<code>子类中的权限不能小于父类的权限</code>，当父类的权限为<code>private</code>时，<code>子类无法继承</code>。也就<code>无法产生所谓的重写</code>。</strong></li><li>修饰符高低：private &lt; 默认修饰符 &lt; protected&lt; public</li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>当一个对象被创建时候，<strong>构造方法用来<code>初始化该对象</code>。构造方法和它<code>所在类的名字相同</code>，但构造方法<code>没有返回值</code>。</strong></p><p><strong><code>通常</code>会使用构造方法给一个类的<code>实例变量赋初值</code></strong>，或者执行其它必要的步骤来创建一个完整的对象。 </p><p>不管你是否自定义构造方法，所有的类都有构造方法，<strong>因为Java自动提供了一个默认构造方法，<code>默认构造方法的访问修改符</code>和<code>类的访问修改符</code>相同(类为 public，构造函数也为 public；类改为 protected，构造函数也改为 protected)。</strong> </p><p><strong>一旦你定义了自己的构造方法，默认构造方法就会失效。</strong> </p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>下面是一个使用构造方法的例子：</p><pre><code>// 一个简单的构造函数class MyClass {  int x;  // 以下是构造函数  MyClass(int i ) {    x = i;  }}</code></pre><p>你可以像下面这样调用构造方法来初始化一个对象：</p><pre><code>public class ConsDemo {  public static void main(String args[]) {    MyClass t1 = new MyClass( 10 );    MyClass t2 = new MyClass( 20 );    System.out.println(t1.x + " " + t2.x);  }}</code></pre><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>JDK 1.5 开始，<strong>Java支持传递<code>同类型</code>的<code>可变参数</code>给一个方法。</strong></p><p>在计算机程序设计，<strong>一个可变参数函数是指一个函数拥有不定引数，即是它接受一个可变数目的参数。</strong></p><p>简单来说，就是<strong>函数的参数<code>个数可变</code>，参数<code>类型不定</code>的函数。 (在Java中类型固定!!!!)</strong></p><p>方法的可变参数的声明如下所示：</p><pre><code>typeName... parameterName</code></pre><p><strong>在方法声明中，在指定参数<code>类型后加一个省略号(...)</code> 。</strong></p><p><strong>一个方法中<code>只能指定一个</code>可变参数，它<code>必须是方法的最后一个参数</code>。任何普通的参数必须在它之前声明。</strong> </p><pre><code>public class VarargsDemo {    public static void main(String args[]) {        // 调用可变参数的方法        printMax(34, 3, 3, 2, 56.5);        printMax(new double[]{1, 2, 3});    }    public static void printMax( double... numbers) //注意为静态方法，否则main()无法引用    {        if (numbers.length == 0) {            System.out.println("No argument passed");            return;        }        double result = numbers[0];        for (int i = 1; i &lt;  numbers.length; i++){            if (numbers[i] &gt;  result) {                result = numbers[i];            }        }        System.out.println("The max value is " + result);    }}</code></pre><p>以上实例编译运行结果如下：</p><pre><code>The max value is 56.5The max value is 3.0</code></pre><h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize() 方法"></a>finalize() 方法</h3><p><a href="https://www.runoob.com/java/java-methods.html" target="_blank" rel="noopener">方法具体请参考，此处不予说明</a></p><p><strong>Java 的<code>内存回收</code>可以由 <code>JVM</code> 来自动完成。</strong>如果你想手动使用，则可以使用上面的方法。 </p><h2 id="Java-流-Stream-、文件-File-和IO"><a href="#Java-流-Stream-、文件-File-和IO" class="headerlink" title="Java 流(Stream)、文件(File)和IO"></a>Java 流(Stream)、文件(File)和IO</h2><p><strong><code>Java.io</code>包几乎包含了所有操作输入、输出需要的类。</strong>所有这些流类代表了输入源和输出目标。</p><p>Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。</p><p><strong>一个<code>流</code>可以理解为一个<code>数据的序列</code>。<code>输入流</code>表示<code>从一个源读取数据</code>，<code>输出流</code>表示<code>向一个目标写数据</code>。</strong> </p><p>Java 为 I/O 提供了强大的而灵活的支持，使其更广泛地应用到文件传输和网络编程中。 </p><p><strong>JDK 5 后的版本我们也可以使用 Java <code>Scanner</code> 类来<code>获取控制台的输入</code>。</strong></p><h3 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h3><p>Java中的<strong>输出语句有以下四种</strong>：</p><pre><code>System.out.println(1111);//换行打印System.out.print(1111);//不换行打印System.out.write(2222);//字节输出System.out.printf("%+8.3f\n", 3.14);//按格式输出</code></pre><ul><li><strong>System.out.println(); 是<code>最常用</code>的输出语句，它会把括号里的<code>内容转换成字符串</code>输出到输出窗口（控制台），<code>并且换行</code>，当输出的是一个<code>基本数据类型</code>时，会自动转换成<code>字符串</code>，如果输出的是一个<code>对象</code>，会自动<code>调用对象的toString();方法</code>，将返回值输出到控制台</strong></li><li>System.out.print(); 与第一个很相似，<strong>区别就是上一个输出后会换行，而这个命令<code>输出后并不换行</code>。</strong></li><li>System.out.write(); 并不常用</li><li>System.out.printf(); 这个方法延续了C语言的输出方式，通过格式化文本和参数列表输出。</li></ul><h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p>如前所述，一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。 </p><img src="//www.runoob.com/wp-content/uploads/2013/12/iostream2xx.png"><h3 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h3><p><strong>该流用于<code>从文件读取数据</code>，它的对象可以用关键字 new 来创建。</strong></p><p>有多种构造方法可用来创建对象。 </p><p>可以使用字符串类型的文件名来创建一个输入流对象来读取文件(<strong>需要文件存在</strong>)：</p><pre><code>InputStream f = new FileInputStream("C:/java/hello");</code></pre><p>也可以<strong>使用一个文件对象来创建一个输入流对象来读取文件。</strong>我们首先得使用 <strong>File() 方法来创建一个文件对象</strong>： </p><pre><code>File f = new File("C:/java/hello");InputStream out = new FileInputStream(f);</code></pre><p>创建了InputStream对象，就可以使用下面的方法来读取流或者进行其他的流操作。</p><p><img src="https://i.loli.net/2020/04/17/Vh6Jom7rlWFwbNi.png" alt="one.png"></p><h3 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h3><p>该类用来<strong>创建一个文件并向文件中写数据。</strong></p><p><strong>如果该流在打开文件进行输出前，<code>目标文件不存在</code>，那么该流会<code>创建</code>该文件。</strong></p><p>有两个构造方法可以用来创建 FileOutputStream 对象。</p><p>使用字符串类型的文件名来创建一个输出流对象：</p><pre><code>OutputStream f = new FileOutputStream("C:/java/hello")</code></pre><p>也可以使用一个文件对象来创建一个输出流来写文件。我们首先得使用File()方法来创建一个文件对象： </p><pre><code>File f = new File("C:/java/hello");OutputStream f = new FileOutputStream(f);</code></pre><p>创建OutputStream 对象完成后，就可以使用下面的方法来写入流或者进行其他的流操作。 </p><p><img src="https://i.loli.net/2020/04/17/wqQf9BLstNOWmcM.png" alt="TIM图片20200417230723.png"></p><p>下面是一个演示 InputStream 和 OutputStream 用法的例子： </p><pre><code>//文件名 :fileStreamTest2.javaimport java.io.*;public class fileStreamTest2 {    public static void main(String[] args) throws IOException {        File f = new File("a.txt");        FileOutputStream fop = new FileOutputStream(f);        // 构建FileOutputStream对象,文件不存在会自动新建        OutputStreamWriter writer = new OutputStreamWriter(fop, "UTF-8");        // 构建OutputStreamWriter对象,参数可以指定编码,默认为操作系统默认编码,windows上是gbk        writer.append("中文输入");        // 写入到缓冲区        writer.append("\r\n");        // 换行        writer.append("English");        // 刷新缓存冲,写入到文件,如果下面已经没有写入的内容了,直接close也会写入        writer.close();        // 关闭写入流,同时会把缓冲区内容写入文件,所以上面的注释掉        fop.close();        // 关闭输出流,释放系统资源        FileInputStream fip = new FileInputStream(f);        // 构建FileInputStream对象        InputStreamReader reader = new InputStreamReader(fip, "UTF-8");        // 构建InputStreamReader对象,编码与写入相同        StringBuffer sb = new StringBuffer();        while (reader.ready()) {            sb.append((char) reader.read());            // 转成char加到StringBuffer对象中        }        System.out.println(sb.toString());        reader.close();        // 关闭读取流        fip.close();        // 关闭输入流,释放系统资源    }}</code></pre><h3 id="Java-File类"><a href="#Java-File类" class="headerlink" title="Java File类"></a>Java File类</h3><p>Java文件类以抽象的方式代表文件名和目录路径名。该类<strong>主要用于文件和目录的创建、文件的查找和文件的删除等。</strong> </p><p>File对象代表磁盘中实际存在的文件和目录。通过以下构造方法创建一个File对象。</p><p><strong>通过将给定路径名字符串转换成抽象路径名来创建一个新 File 实例。</strong></p><pre><code>File(String pathname)</code></pre><h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><p>File类中有两个方法可以用来创建文件夹：</p><ul><li><strong>mkdir( )方法创建一个<code>文件夹</code></strong>，成功则返回true，失败则返回false。失败表明File对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。</li><li><strong>mkdirs()方法创建一个<code>文件夹</code>和它的<code>所有父文件夹</code>。</strong></li></ul><p>下面的例子<strong>创建 “/tmp/user/java/bin”文件夹</strong>：</p><pre><code>import java.io.File;public class CreateDir {    public static void main(String args[]) {        String dirname = "/tmp/user/java/bin";        File d = new File(dirname);        // 现在创建目录        d.mkdirs();    }}</code></pre><h4 id="读取目录"><a href="#读取目录" class="headerlink" title="读取目录"></a>读取目录</h4><p><strong>一个目录其实就是一个 File 对象</strong>，它包含其他文件和文件夹。 </p><p>如果创建一个 <strong>File 对象并且它是一个<code>目录</code>，那么调用 <code>isDirectory()</code> 方法会返回 true。</strong> </p><p>可以通过调用该对象上的 <strong>list() 方法，来提取它包含的<code>文件和文件夹的列表</code>。</strong> </p><p>下面展示的例子说明如何使用 list() 方法来检查一个文件夹中包含的内容：</p><pre><code>import java.io.File;public class DirList {    public static void main(String args[]) {        String dirname = "/tmp";        File f1 = new File(dirname);        if (f1.isDirectory()) {            System.out.println("目录 " + dirname);            String s[] = f1.list();            for (int i = 0; i &lt; s.length; i++) {                File f = new File(dirname + "/" + s[i]);                if (f.isDirectory()) {                    System.out.println(s[i] + " 是一个目录");                } else {                    System.out.println(s[i] + " 是一个文件");                }            }        } else {            System.out.println(dirname + " 不是一个目录");        }    }}</code></pre><h4 id="删除目录或文件"><a href="#删除目录或文件" class="headerlink" title="删除目录或文件"></a>删除目录或文件</h4><p><strong>删除文件可以使用 <code>java.io.File.delete()</code>方法。</strong></p><p>以下代码会删除目录 /tmp/java/，需要<strong>注意的是当删除某一目录时，必须保证<code>该目录下没有其他文件</code>才能正确删除，否则将删除失败。</strong></p><pre><code>import java.io.File;public class DeleteFileDemo {    public static void main(String args[]) {        // 这里修改为自己的测试目录        File folder = new File("/tmp/java/");        deleteFolder(folder);    }    // 删除文件及目录    public static void deleteFolder(File folder) {        File[] files = folder.listFiles();        if (files != null) {            for (File f : files) {                if (f.isDirectory()) {                    deleteFolder(f);                } else {                    f.delete();                }            }        }        folder.delete();    }}</code></pre><h3 id="Java-FileReader类"><a href="#Java-FileReader类" class="headerlink" title="Java FileReader类"></a>Java FileReader类</h3><p><strong><code>FileReader</code>类从<code>InputStreamReader</code>类继承而来。该类<code>按字符</code>读取流中数据。</strong>可以通过<strong>以下几种构造方法</strong>创建需要的对象。 </p><p>在给定从中读取数据的 File 的情况下创建一个新 FileReader。</p><pre><code>FileReader(File file)</code></pre><p>在给定从中读取数据的 FileDescriptor 的情况下创建一个新 FileReader。</p><pre><code>FileReader(FileDescriptor fd) </code></pre><p>在给定从中读取数据的文件名的情况下创建一个新 FileReader。</p><pre><code>FileReader(String fileName)</code></pre><p>创建FIleReader对象成功后，可以参照以下列表里的方法操作文件。</p><p><img src="https://i.loli.net/2020/04/17/pDlmk1bz8Nq3WdX.png" alt="TIM图片20200417232946.png"></p><h3 id="Java-FileWriter类"><a href="#Java-FileWriter类" class="headerlink" title="Java FileWriter类"></a>Java FileWriter类</h3><p>FileWriter 类从 OutputStreamWriter 类继承而来。该类<strong>按字符向流中写入数据</strong>。可以通过以下几种构造方法创建需要的对象。 </p><p>在给出 File 对象的情况下构造一个 FileWriter 对象。</p><pre><code>FileWriter(File file)</code></pre><p>在给出 File 对象的情况下构造一个 FileWriter 对象。</p><pre><code>FileWriter(File file, boolean append)</code></pre><p><strong>参数：</strong></p><ul><li><strong>file</strong>：要写入数据的 File 对象。 </li><li><strong>append</strong>：<strong>如果 append 参数为 <code>true</code>，则将字节写入<code>文件末尾处</code>，相当于<code>追加信息</code>。如果 append 参数为 <code>false</code>, 则写入文件<code>开始处</code>。</strong></li></ul><p>创建FileWriter对象成功后，可以参照以下列表里的方法操作文件。</p><p><img src="https://i.loli.net/2020/04/17/Ts5HDniYABZewLk.png" alt="TIM图片20200417234306.png"></p><p>实例</p><pre><code>import java.io.*;public class FileRead {    public static void main(String args[]) throws IOException {        File file = new File("Hello1.txt");        // 创建文件        file.createNewFile();        // creates a FileWriter Object        FileWriter writer = new FileWriter(file);        // 向文件写入内容        writer.write("This\n is\n an\n example\n");        writer.flush(); //清空缓冲区并完成文件写入操作        writer.close();        // 创建 FileReader 对象        FileReader fr = new FileReader(file);        char[] a = new char[50];        fr.read(a); // 读取数组中的内容        for (char c : a)            System.out.print(c); // 一个一个打印字符        fr.close();    }}</code></pre><p>以上实例编译运行结果如下：</p><pre><code>Thisisanexample</code></pre><h2 id="Java-Scanner-类"><a href="#Java-Scanner-类" class="headerlink" title="Java Scanner 类"></a>Java Scanner 类</h2><p>对于大部分学过C++，C的同学来说，可能有一点陌生，<strong>java是一门面向对象的语言 ，所以它的输入并不是先定义一个变量，再cin它</strong>；java没有提供诸如C/C++中的scanf输入函数，因此从键盘输入并不是一个简单的事情</p><p><strong><code>java.util.Scanner</code> 是 <code>Java5</code> 的<code>新特征</code>，我们可以通过 Scanner 类来<code>获取用户的输入</code>。</strong></p><p>下面是创建 Scanner 对象的基本语法：</p><pre><code>Scanner s = new Scanner(System.in);      //构造Scanner类对象，它附属于标准输入流System.in</code></pre><p>接下来我们演示一个最简单的数据输入，<strong>并通过 <code>Scanner</code> 类的 <code>next()</code> 与 <code>nextLine()</code> 方法<code>获取输入的字符串</code>，在读取前我们一般需要 使用 <code>hasNext</code> 与 <code>hasNextLine</code> 判断<code>是否还有输入的数据</code></strong>：</p><h3 id="使用-next-方法："><a href="#使用-next-方法：" class="headerlink" title="使用 next 方法："></a>使用 next 方法：</h3><pre><code>import java.util.Scanner; public class ScannerDemo {    public static void main(String[] args) {        Scanner scan = new Scanner(System.in);        // 从键盘接收数据        // next方式接收字符串        System.out.println("next方式接收：");        // 判断是否还有输入        if (scan.hasNext()) {            String str1 = scan.next();            System.out.println("输入的数据为：" + str1);        }        scan.close();    }}</code></pre><p>执行以上程序输出结果为：</p><pre><code>next方式接收：run boc输入的数据为：run    //可以看到 boc 字符串并未输出</code></pre><h3 id="使用-nextLine-方法："><a href="#使用-nextLine-方法：" class="headerlink" title="使用 nextLine 方法："></a>使用 nextLine 方法：</h3><pre><code>import java.util.Scanner;public class ScannerDemo {    public static void main(String[] args) {        Scanner scan = new Scanner(System.in);        // 从键盘接收数据        // nextLine方式接收字符串        System.out.println("nextLine方式接收：");        // 判断是否还有输入        if (scan.hasNextLine()) {            String str2 = scan.nextLine();            System.out.println("输入的数据为：" + str2);        }        scan.close();    }}</code></pre><p>执行以上程序输出结果为：</p><pre><code>next方式接收：run com输入的数据为：run com    //可以看到 com 字符串输出。</code></pre><h3 id="next-与-nextLine-区别"><a href="#next-与-nextLine-区别" class="headerlink" title="next() 与 nextLine() 区别"></a>next() 与 nextLine() 区别</h3><h4 id="next"><a href="#next" class="headerlink" title="next():"></a>next():</h4><ul><li>一定要<strong>读取到有效字符后，<code>回车</code>才可以结束输入</strong></li><li>对输入<strong>有效字符之前遇到的空格，next() 方法会自动将其去掉。</strong> </li><li>只有<strong>输入有效字符后才将其后面输入的空白作为结束符，即空白后的字符不会显示。</strong> </li><li><strong>next() 不能得到带有<code>空格</code>的字符串。</strong></li></ul><h4 id="nextLine-："><a href="#nextLine-：" class="headerlink" title="nextLine()："></a>nextLine()：</h4><ul><li><strong><code>以Enter为结束符</code>,也就是说 nextLine()方法返回的是输入<code>回车之前的所有字符</code>。</strong> </li><li><strong>可以获得空白。</strong></li></ul><p>如果要<strong>输入 <code>int 或 float</code> 类型的数据，在 Scanner 类中也有支持，但是在输入之前最好先使用 <code>hasNextXxx()</code> 方法进行验证，再使用 <code>nextXxx()</code>来读取：</strong></p><pre><code>import java.util.Scanner;public class ScannerDemo {    public static void main(String[] args) {        Scanner scan = new Scanner(System.in);        // 从键盘接收数据        int i = 0;        float f = 0.0f;        System.out.print("输入整数：");        if (scan.hasNextInt()) {            // 判断输入的是否是整数            i = scan.nextInt();            // 接收整数            System.out.println("整数数据：" + i);        } else {            // 输入错误的信息            System.out.println("输入的不是整数！");        }        System.out.print("输入小数：");        if (scan.hasNextFloat()) {            // 判断输入的是否是小数            f = scan.nextFloat();            // 接收小数            System.out.println("小数数据：" + f);        } else {            // 输入错误的信息            System.out.println("输入的不是小数！");        }        scan.close();     //结束时使用close();方法关闭对象。    }}</code></pre><p>执行以上程序输出结果为：</p><pre><code>输入整数：1整数数据：1输入小数：1.1小数数据：1.1</code></pre><p>以下实例我们可以<strong>输入多个数字，并求其<code>总和</code>与<code>平均数</code>，每输入一个数字用<code>回车确认</code>，通过输入<code>非数字来结束输入</code>并输出执行结果</strong>：</p><pre><code>import java.util.Scanner;class ScannerDemo {    public static void main(String[] args) {        Scanner scan = new Scanner(System.in);        double sum = 0;        int m = 0;        while (scan.hasNextDouble()) {            double x = scan.nextDouble();            m = m + 1;            sum = sum + x;        }        System.out.println(m + "个数的和为" + sum);        System.out.println(m + "个数的平均值是" + (sum / m));        scan.close();    //结束时使用close();方法关闭对象。    }}</code></pre><p>执行以上程序输出结果为：</p><pre><code>12231521.4end     //输入end结束输入4个数的和为71.44个数的平均值是17.85</code></pre><h2 id="Java-异常处理"><a href="#Java-异常处理" class="headerlink" title="Java 异常处理"></a>Java 异常处理</h2><p>异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。 </p><p>异常发生的原因有很多，通常包含以下几大类：</p><ul><li><strong>用户输入了非法数据。</strong></li><li>要打开的文件不存在。</li><li>网络通信时连接中断，或者JVM内存溢出。</li></ul><p>这些异常<strong>有的是因为用户错误引起，有的是程序错误引起的，还有其它一些是因为物理错误引起的。</strong></p><p>要理解Java异常处理是如何工作的，你需要掌握以下<strong>三种类型的异常</strong>：</p><ul><li>检查性异常：<strong>最具代表的检查性异常是<code>用户错误</code>或<code>问题</code>引起的异常，这是程序员无法预见的。</strong>例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</li><li>运行时异常：<strong>运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常<code>可以在编译时被忽略</code>。</strong></li><li>错误：<strong>错误不是异常，而是脱离程序员控制的问题。</strong>错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</li></ul><p><strong>注意</strong>：</p><ul><li><strong>检查性异常(非运行时异常): <code>不处理编译不能通过</code></strong> </li></ul><img src="//www.runoob.com/wp-content/uploads/2018/08/697611-20170620140556085-547309633.png"><ul><li><strong>非检查性异常(运行时异常): <code>不处理编译可以通过</code>，如果有抛出直接抛到控制台</strong> </li><li><img src="//www.runoob.com/wp-content/uploads/2018/08/697611-20170620141139913-1638456043.png"></li></ul><h3 id="Exception-类的层次"><a href="#Exception-类的层次" class="headerlink" title="Exception 类的层次"></a>Exception 类的层次</h3><p><strong>所有的异常类是从 <code>java.lang.Exception</code> 类<code>继承的子类</code>。</strong></p><p>Exception 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error 。 </p><p><strong>Java 程序通常不捕获错误。</strong>错误一般发生在严重故障时，它们在Java程序处理的范畴之外。 </p><p><strong><code>Error</code> 用来指示<code>运行时环境发生的错误</code>。</strong></p><p><strong>异常类有两个主要的子类：<code>IOException</code> 类和 <code>RuntimeException</code> 类。</strong></p><img src="//www.runoob.com/wp-content/uploads/2013/12/12-130Q1234I6223.jpg"><h3 id="Java-内置异常类"><a href="#Java-内置异常类" class="headerlink" title="Java 内置异常类"></a>Java 内置异常类</h3><p>Java 语言<strong>定义了一些异常类在 <code>java.lang</code> 标准包中。</strong> </p><p>标准运行时异常类的子类是最常见的异常类。<strong>由于 java.lang 包是默认加载到所有的 Java 程序的，所以<code>大部分</code>从运行时异常类继承而来的异常都可以<code>直接使用</code>。</strong> </p><p>常见的一些<strong>非检查性异常</strong></p><pre><code>ArrayIndexOutOfBoundsException     用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。IndexOutOfBoundsException          指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。NullPointerException               当应用程序试图在需要对象的地方使用 null 时，抛出该异常StringIndexOutOfBoundsException    此异常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小。</code></pre><p>常见的检查性异常类</p><pre><code>ClassNotFoundException             应用程序试图加载类时，找不到相应的类，抛出该异常。</code></pre><p>更多异常类请访问：<a href="https://www.runoob.com/java/java-exceptions.html" target="_blank" rel="noopener">网址</a></p><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p><strong>使用 try 和 catch 关键字可以<code>捕获异常</code>。try/catch 代码块放在<code>异常可能发生</code>的地方。</strong> </p><p>try/catch代码块中的代码称为<strong>保护代码</strong>，使用 try/catch 的语法如下</p><pre><code>try{   // 程序代码}catch(ExceptionName e1){   //Catch 块}</code></pre><p><strong>Catch 语句包含要<code>捕获异常类型的声明</code>。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。</strong></p><p><strong>如果发生的<code>异常包含在 catch 块中</code>，异常会被<code>传递到该 catch 块</code>，这和传递一个参数到方法是一样。</strong> </p><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><p>下面的例子中声明有两个元素的一个数组，<strong>当代码试图访问数组的第三个元素的时候就会抛出一个异常。</strong></p><pre><code>// 文件名 : ExcepTest.javaimport java.io.*;public class ExcepTest{   public static void main(String args[]){      try{         int a[] = new int[2];         System.out.println("Access element three :" + a[3]);      }catch(ArrayIndexOutOfBoundsException e){         System.out.println("Exception thrown  :" + e);    //访问数组下标越界      }      System.out.println("Out of the block");   }}</code></pre><p>以上代码编译运行输出结果如下：</p><pre><code>Exception thrown  :java.lang.ArrayIndexOutOfBoundsException: 3Out of the block</code></pre><h3 id="多重捕获块"><a href="#多重捕获块" class="headerlink" title="多重捕获块"></a>多重捕获块</h3><p><strong>一个 <code>try 代码块</code>后面跟随<code>多个 catch 代码块</code>的情况就叫<code>多重捕获</code>。</strong> </p><p>多重捕获块的语法如下所示：</p><pre><code>try{   // 程序代码}catch(异常类型1 异常的变量名1){  // 程序代码}catch(异常类型2 异常的变量名2){  // 程序代码}catch(异常类型2 异常的变量名2){  // 程序代码}</code></pre><h3 id="finally关键字"><a href="#finally关键字" class="headerlink" title="finally关键字"></a>finally关键字</h3><p><strong>无论是否发生异常，finally 代码块中的代码<code>总会被执行</code>。</strong> </p><p><strong>在 finally 代码块中，可以运行<code>清理类型等收尾善后性质</code>的语句。</strong></p><p><strong>finally 代码块出现在 <code>catch</code> 代码块<code>最后</code></strong>，语法如下：</p><pre><code>try{  // 程序代码}catch(异常类型1 异常的变量名1){  // 程序代码}catch(异常类型2 异常的变量名2){  // 程序代码}finally{  // 程序代码}</code></pre><p>注意：</p><ul><li><strong>catch 不能独立于 try 存在。</strong></li><li><strong>在 try/catch 后面<code>添加 finally 块并非强制性</code>要求的。</strong></li><li><strong>try 代码后不能既没 <code>catch</code> 块也没 <code>finally</code> 块。</strong></li><li><strong>try, catch, finally 块之间<code>不能添加任何代码</code>。</strong></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习</title>
      <link href="/2020/04/10/java-xue-xi/"/>
      <url>/2020/04/10/java-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-简介和基础语法"><a href="#Java-简介和基础语法" class="headerlink" title="Java 简介和基础语法"></a>Java 简介和基础语法</h2><p><a href="https://www.runoob.com/try/runcode.php?filename=HelloWorld&amp;type=java" target="_blank" rel="noopener">Java在线工具</a></p><p>Java是由Sun Microsystems公司于1995年5月推出的Java面向对象程序设计语言和Java平台的总称。由James Gosling和同事们共同研发，并在1995年正式推出。</p><p>Java分为三个体系：</p><p>JavaSE（J2SE）（Java2 Platform Standard Edition，java平台标准版）</p><ul><li>一般用来<strong>开发桌面应用程序</strong>，但是在开发桌面应用程序上相对VB，Delphi，VC++并没有什么优势。</li></ul><p><strong>JavaEE(J2EE)(Java 2 Platform,Enterprise Edition，java平台企业版)</strong></p><ul><li>一般用于<strong>开发<code>JavaWeb应用程序</code>，初级的一般是用<code>JSP（Java Server Pages）+servlet+JavaBean</code>来开发的，对大型的网站一般是使用<code>框架</code>来开发的，例如<code>struts，hibernate，spring</code>。</strong></li></ul><p>JavaME(J2ME)(Java 2 Platform Micro Edition，java平台微型版)。</p><p>2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，<strong>Java的各种版本已经更名以取消其中的数字”2”：J2EE更名为Java EE, J2SE更名为Java SE，J2ME更名为Java ME。</strong> </p><h3 id="Java主要特性"><a href="#Java主要特性" class="headerlink" title="Java主要特性"></a>Java主要特性</h3><ul><li><p><strong>Java语言是简单的</strong>：<br>Java语言的语法与C语言和C++语言很接近，使得大多数程序员很容易学习和使用。另一方面，Java丢弃了C++中很少使用的、很难理解的、令人迷惑的那些特性，如<strong>操作符重载、多继承、自动的强制类型转换</strong>。特别地，Java语言<strong>不使用指针，而是引用</strong>。并提供了自动的废料收集，使得程序员不必为内存管理而担忧。</p></li><li><p><strong>Java语言是面向对象的</strong>：<br>Java语言提供类、接口和继承等面向对象的特性，为了简单起见，只支持<strong>类之间的单继承</strong>，但支持<strong>接口之间的多继承</strong>，并支持类与接口之间的实现机制（关键字为implements）。Java语言全面支持动态绑定，而C++语言只对虚函数使用动态绑定。总之，Java语言是一个纯的面向对象程序设计语言。</p></li><li><p><strong>Java语言是分布式的</strong>：<br>Java语言支持Internet应用的开发，在基本的Java应用编程接口中有一个网络应用编程接口（java net），它提供了用于网络应用编程的类库，包括URL、URLConnection、Socket、ServerSocket等。Java的RMI（远程方法激活）机制也是开发分布式应用的重要手段。</p></li><li><p><strong>Java语言是健壮的</strong>：<br>Java的强类型机制、异常处理、垃圾的自动收集等是Java程序健壮性的重要保证。对指针的丢弃是Java的明智选择。Java的安全检查机制使得Java更具健壮性。</p></li><li><p><strong>Java语言是安全的</strong>：<br>Java通常被用在网络环境中，为此，Java提供了一个安全机制以防恶意代码的攻击。除了Java语言具有的许多安全特性以外，Java对通过网络下载的类具有一个安全防范机制（类ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查，并提供安全管理机制（类SecurityManager）让Java应用设置安全哨兵。</p></li><li><p><strong>Java语言是体系结构中立的</strong>：<br>Java程序（<strong>后缀为java的文件</strong>）在Java平台上被编译为体系结构中立的<strong>字节码格式（后缀为class的文件）</strong>，然后可以在实现这个Java平台的任何系统中运行。这种途径适合于异构的网络环境和软件的分发。</p></li><li><p><strong>Java语言是可移植的</strong>：<br>这种可移植性来源于体系结构中立性，另外，Java还严格规定了各个基本数据类型的长度。Java系统本身也具有很强的可移植性，Java编译器是用Java实现的，Java的运行环境是用ANSI C实现的。</p></li><li><p><strong>Java语言是解释型的</strong>：<br>如前所述，Java程序<strong>在Java平台上被编译为<code>字节码</code>格式，然后可以在实现这个<code>Java平台的任何系统中运行</code>。在运行时，Java平台中的<code>Java解释器</code>对这些<code>字节码</code>进行<code>解释执行</code></strong>，执行过程中需要的类在联接阶段被载入到运行环境中。</p></li><li><p><strong>Java是高性能的</strong>：<br>与那些解释型的高级脚本语言相比，Java的确是高性能的。事实上，Java的运行速度随着JIT(Just-In-Time）编译器技术的发展越来越接近于C++。</p></li><li><p><strong>Java语言是多线程的</strong>：<br>在Java语言中，线程是一种特殊的对象，它必须由Thread类或其子（孙）类来创建。通常有两种方法来创建线程：其一，使用型构为Thread(Runnable)的构造子类将一个实现了Runnable接口的对象包装成一个线程，其二，从Thread类派生出子类并重写run方法，使用该子类创建的对象即为线程。值得注意的是Thread类已经实现了Runnable接口，因此，任何一个线程均有它的run方法，而run方法中包含了线程所要运行的代码。线程的活动由一组方法来控制。Java语言支持多个线程的同时执行，并提供多线程之间的同步机制（关键字为synchronized）。</p></li><li><p><strong>Java语言是动态的</strong>：<br>Java语言的设计目标之一是适应于动态变化的环境。Java程序需要的类能够动态地被载入到运行环境，也可以通过网络来载入所需要的类。这也有利于软件的升级。另外，Java中的类有一个运行时刻的表示，能进行运行时刻的类型检查。</p></li></ul><h3 id="Java开发工具"><a href="#Java开发工具" class="headerlink" title="Java开发工具"></a>Java开发工具</h3><ul><li>Linux 系统、Mac OS 系统、Windows 95/98/2000/XP，WIN 7/8系统。</li><li>Java JDK 7、8……（<strong>JDK（Java Development Kit）称为<code>Java开发包</code>或<code>Java开发工具</code>，是一个编写Java的Applet小程序和应用程序的<code>程序开发环境</code>。JDK是整个Java的<code>核心</code>，包括了<code>Java运行环境（Java Runtime Environment）</code>，一些Java工具和Java的核心类库（Java API）。</strong>）</li><li><strong>另外，可以把Java API类库中的<code>Java SE API子集</code>和<code>Java虚拟机(JVM)</code>这两部分统称为<code>JRE（JAVA Runtime Environment）</code>，JRE是支持Java程序<code>运行的标准环境</code>。</strong></li><li>JVM是<strong>Java Virtual Machine（Java虚拟机）</strong>的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。<strong>引入Java语言虚拟机后，Java语言在<code>不同平台上运行时不需要重新编译</code>。Java语言使用<code>Java虚拟机屏蔽了与具体平台相关的信息</code>，使得Java语言<code>编译程序只需生成在Java虚拟机上运行的目标代码（字节码）</code>，就可以在多种平台上不加修改地运行。</strong></li><li>Notepad 编辑器或者其他编辑器。</li><li>IDE：Eclipse（<strong>集成开发环境（IDE，Integrated Development Environment ）是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。集成了代码编写功能、分析功能、编译功能、调试功能等一体化的开发软件服务套。所有具备这一特性的软件或者软件套（组）都可以叫集成开发环境。</strong> ）</li></ul><p><strong>总结：<code>JRE</code>是个<code>运行环境</code>，<code>JDK</code>是个<code>开发环境</code>。因此<code>写Java程序的时候需要JDK</code>，而<code>运行Java程序的时候就需要JRE</code>。而<code>JDK里面已经包含了JRE</code>，因此只要安装了JDK，就可以编辑Java程序，也可以正常运行Java程序。但由于JDK包含了许多与运行无关的内容，占用的空间较大，因此运行普通的Java程序无须安装JDK，而只需要安装JRE即可。</strong></p><h3 id="使用Netbeans运行第一个-Java-程序"><a href="#使用Netbeans运行第一个-Java-程序" class="headerlink" title="使用Netbeans运行第一个 Java 程序"></a>使用Netbeans运行第一个 Java 程序</h3><p>HelloWorld.java 文件代码：</p><pre><code>public class HelloWorld {    /* 第一个Java程序     * 它将打印字符串 Hello World     */    public static void main(String []args) {        System.out.println("Hello World"); // 打印 Hello World    }}</code></pre><p><strong>注意</strong>：String args[] 与 String[] args 都可以执行，但推荐使用 <strong>String[] args</strong>，这样可以避免歧义和误读。</p><h3 id="Java-基础语法"><a href="#Java-基础语法" class="headerlink" title="Java 基础语法"></a>Java 基础语法</h3><p>一个 Java 程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作。下面简要介绍下类、对象、方法和实例变量的概念。</p><ul><li><strong>对象</strong>：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</li><li><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态。</li><li><strong>方法</strong>：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。</li><li><strong>实例变量</strong>：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。</li></ul><p>编写 Java 程序时，应注意以下几点：</p><ul><li><strong>大小写敏感</strong>：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。</li><li><strong>包名</strong>：多单词组成时所有字母都小写：xxxyyyzzz</li><li><strong>类名，接口名</strong>：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。(<strong>大驼峰</strong>)</li><li><strong>变量名、方法名</strong>：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。xxxYyyZzz。（<strong>小驼峰</strong>）</li><li><strong>源文件名</strong>：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 .java。（如果文件名和类名不相同则会导致编译错误）。</li><li><strong>常量名</strong>：所有字母大写，多单词时每个单词用下划线连接：XXX_YYY_ZZZ</li><li><strong>主方法入口</strong>：所有的 Java 程序由 public static void main(String []args) 方法开始执行。</li></ul><h3 id="Java-标识符"><a href="#Java-标识符" class="headerlink" title="Java 标识符"></a>Java 标识符</h3><p>Java 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。</p><p>关于 Java 标识符的命名规则，不遵守编译不通过：</p><ul><li>所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始</li><li>首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合</li><li>关键字不能用作标识符</li><li>标识符是大小写敏感的</li><li>合法标识符举例：age、$salary、_value、__1_value</li><li>非法标识符举例：123abc、-salary</li></ul><h3 id="Java-修饰符"><a href="#Java-修饰符" class="headerlink" title="Java 修饰符"></a>Java 修饰符</h3><p>像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：</p><p><strong>访问控制修饰符</strong> : default, public , protected, private</p><p><strong>非访问控制修饰符</strong> : final, abstract, static, synchronized </p><h3 id="Java-变量"><a href="#Java-变量" class="headerlink" title="Java 变量"></a>Java 变量</h3><p>Java 中主要有如下几种类型的变量</p><ul><li>局部变量</li><li>类变量（静态变量）</li><li>成员变量（非静态变量）</li></ul><h3 id="Java-数组"><a href="#Java-数组" class="headerlink" title="Java 数组"></a>Java 数组</h3><p>数组是储存在堆上的对象，可以保存多个同类型变量。</p><h3 id="Java-枚举"><a href="#Java-枚举" class="headerlink" title="Java 枚举"></a>Java 枚举</h3><p>Java 5.0引入了枚举，枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的 bug。</p><p>例如，我们为果汁店设计一个程序，它将限制果汁为小杯、中杯、大杯。这就意味着它不允许顾客点除了这三种尺寸外的果汁。</p><pre><code>class FreshJuice {   enum FreshJuiceSize{ SMALL, MEDIUM , LARGE }   FreshJuiceSize size;}public class FreshJuiceTest {   public static void main(String []args){      FreshJuice juice = new FreshJuice();      juice.size = FreshJuice.FreshJuiceSize.MEDIUM  ;   }}</code></pre><p><strong>注意</strong>：枚举可以单独声明或者声明在类里面。方法、变量、构造函数也可以在枚举中定义。</p><p><a href="https://www.runoob.com/java/java-basic-syntax.html" target="_blank" rel="noopener">关键字具体参考</a></p><h3 id="Java注释"><a href="#Java注释" class="headerlink" title="Java注释"></a>Java注释</h3><p>类似于 C/C++、Java 也支持单行以及多行注释。注释中的字符将被 Java 编译器忽略。</p><pre><code>public class HelloWorld {   /* 这是第一个Java程序    *它将打印Hello World    * 这是一个多行注释的示例    */    public static void main(String []args){       // 这是单行注释的示例       /* 这个也是单行注释的示例 */       System.out.println("Hello World");     }}</code></pre><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在 Java 中，一个类可以由其他类派生。如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以将新创建的类继承该类。<br>利用继承的方法，可以重用已存在类的方法和属性，而不用重写这些代码。被继承的类称为超类（super class），派生类称为子类（subclass）。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>在 Java 中，接口可理解为对象间相互通信的协议。接口在继承中扮演着很重要的角色。</p><p>接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类。</p><h3 id="Java-源程序与编译型运行区别"><a href="#Java-源程序与编译型运行区别" class="headerlink" title="Java 源程序与编译型运行区别"></a>Java 源程序与编译型运行区别</h3><p><img src="https://www.runoob.com/wp-content/uploads/2013/12/ZSSDMld.png" alt=""></p><h3 id="Java-对象和类"><a href="#Java-对象和类" class="headerlink" title="Java 对象和类"></a>Java 对象和类</h3><p>Java作为一种面向对象语言。支持以下基本概念：</p><ul><li>多态</li><li>继承</li><li>封装</li><li>抽象</li><li>类</li><li>对象</li><li>实例</li><li>方法</li><li>重载</li></ul><p>对象和类的概念</p><ul><li>对象：对象是类的一个实例（对象不是找个女朋友），有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</li><li>类：类是一个模板，它描述一类对象的行为和状态。</li></ul><h3 id="Java中的对象"><a href="#Java中的对象" class="headerlink" title="Java中的对象"></a>Java中的对象</h3><p>现在让我们深入了解什么是对象。看看周围真实的世界，会发现身边有很多对象，车，狗，人等等。所有这些对象都有自己的状态和行为。<br>拿一条狗来举例，它的状态有：名字、品种、颜色，行为有：叫、摇尾巴和跑。<br>对比现实对象和软件对象，它们之间十分相似。<br>软件对象也有状态和行为。软件对象的状态就是属性，行为通过方法体现。<br>在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。</p><h3 id="Java中的类"><a href="#Java中的类" class="headerlink" title="Java中的类"></a>Java中的类</h3><p>类可以看成是创建Java对象的模板。</p><p>通过下面一个简单的类来理解下Java中类的定义：</p><pre><code>public class Dog{  String breed; //品种  int age;      //年龄  String color; //颜色  void barking(){      //吠叫  }  void hungry(){      //饥饿  }  void sleeping(){      //睡觉  }}</code></pre><p>一个类可以包含以下类型变量：</p><ul><li><strong>局部变量</strong>：在<strong>方法、构造方法或者语句块</strong>中定义的变量被称为局部变量。<strong>变量声明和初始化</strong>都是在方法中，方法结束后，变量就会自动销毁。</li><li><strong>成员变量</strong>：成员变量是定义在<strong>类中，方法体之外</strong>的变量。这种变量在创建对象的时候实例化。成员变量可以被<strong>类中方法、构造方法和特定类的语句块访问</strong>。</li><li><strong>类变量</strong>：类变量也声明在<strong>类中，方法体之外</strong>，但<strong>必须声明</strong>为<strong>static</strong>类型。</li></ul><p><strong>一个类可以拥有多个方法</strong>，在上面的例子中：barking()、hungry()和sleeping()都是Dog类的方法。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个<strong>默认构造方法</strong>。</p><p>在创建一个对象的时候，至少要调用一个构造方法。构造方法的<strong>名称必须与类同名</strong>，一个类可以有多个构造方法。</p><p>下面是一个构造方法(构造器)示例：</p><pre><code>public class Puppy{    public Puppy(){    }    public Puppy(String name){        // 这个构造器仅有一个参数：name    }}</code></pre><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>对象是根据类创建的。在Java中，使用<strong>关键字new</strong>来创建一个新的对象。创建对象需要以下三步：</p><ul><li><strong>声明</strong>：声明一个对象，包括对象名称和对象类型。</li><li><strong>实例化</strong>：使用关键字new来创建一个对象。</li><li><strong>初始化</strong>：使用new创建对象时，会<strong>调用构造方法初始化</strong>对象。</li></ul><p>下面是一个创建对象的例子：</p><pre><code>public class Puppy{   public Puppy(String name){      //这个构造器仅有一个参数：name      System.out.println("小狗的名字是 : " + name );    }   public static void main(String[] args){      // 下面的语句将创建一个Puppy对象      Puppy myPuppy = new Puppy( "tommy" );   }}</code></pre><p>编译并运行上面的程序，会打印出下面的结果：<code>小狗的名字是 : tommy</code></p><h3 id="访问实例变量和方法"><a href="#访问实例变量和方法" class="headerlink" title="访问实例变量和方法"></a>访问实例变量和方法</h3><p>通过已创建的<strong>对象来访问成员变量和成员方法</strong>，如下所示：</p><pre><code>/* 实例化对象 */Object referenceVariable = new Constructor();/* 访问类中的变量 */referenceVariable.variableName;/* 访问类中的方法 */referenceVariable.methodName();</code></pre><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><pre><code>public class Puppy{   int puppyAge;   public Puppy(String name){      // 这个构造器仅有一个参数：name      System.out.println("小狗的名字是 : " + name );    }   public void setAge( int age ){       puppyAge = age;   }   public int getAge( ){       System.out.println("小狗的年龄为 : " + puppyAge );        return puppyAge;   }   public static void main(String[] args){      /* 创建对象 */      Puppy myPuppy = new Puppy( "tommy" );      /* 通过方法来设定age */      myPuppy.setAge( 2 );      /* 调用另一个方法获取age */      myPuppy.getAge( );      /*你也可以像下面这样访问成员变量 */      System.out.println("变量值 : " + myPuppy.puppyAge );    }}</code></pre><p>编译并运行上面的程序，产生如下结果： </p><pre><code>小狗的名字是 : tommy小狗的年龄为 : 2变量值 : 2</code></pre><h3 id="源文件声明规则"><a href="#源文件声明规则" class="headerlink" title="源文件声明规则"></a>源文件声明规则</h3><p>当在一个源文件中<strong>定义多个类</strong>，并且还有<strong>import语句和package语句</strong>时，要特别注意这些规则。</p><ul><li>一个源文件中只能有<strong>一个public类</strong></li><li>一个源文件可以有多个非public类</li><li><strong>源文件的名称</strong>应该和<strong>public类的类名保持一致</strong>。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java。</li><li>如果一个<strong>类定义在某个包</strong>中，那么package语句应该在<strong>源文件的首行</strong>。</li><li>如果源文件包含import语句，那么应该放在<strong>package语句和类定义之间</strong>。如果没有package语句，那么import语句应该在源文件中最前面。</li><li>import语句和package语句对源文件中定义的所有类都有效。在<strong>同一源文件中，不能给不同的类不同的包声明</strong>。</li></ul><p>类有若干种访问级别，并且类也分不同的类型：抽象类和final类等。这些将在访问控制章节介绍。<br>除了上面提到的几种类型，Java还有一些特殊的类，如：内部类、匿名类。</p><h3 id="Java-包"><a href="#Java-包" class="headerlink" title="Java 包"></a>Java 包</h3><p>包主要用来<strong>对类和接口进行分类</strong>。当开发Java程序时，可能编写成百上千的类，因此很有必要对类和接口进行分类。</p><h3 id="Import-语句"><a href="#Import-语句" class="headerlink" title="Import 语句"></a>Import 语句</h3><p>在Java中，如果给出一个完整的限定名，包括包名、类名，那么Java编译器就可以很容易地定位到源代码或者类。Import语句就是用来提供一个合理的路径，使得编译器可以找到某个类。</p><p>例如，下面的命令行将会命令编译器载入<strong>java_installation/java/io</strong>路径下的<strong>所有类</strong></p><pre><code>import java.io.*;</code></pre><h4 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h4><p>创建两个类：Employee 和 EmployeeTest。</p><p>Employee类有四个成员变量：<strong>name、age、designation和salary</strong>。该类显式声明了一个构造方法，该方法只有一个参数。</p><p>Employee.java 文件代码：</p><pre><code>import java.io.*;public class Employee{   String name;   int age;   String designation;   double salary;   // Employee 类的构造器   public Employee(String name){      this.name = name;   }   // 设置age的值   public void empAge(int empAge){      age =  empAge;   }   /* 设置designation的值*/   public void empDesignation(String empDesig){      designation = empDesig;   }   /* 设置salary的值*/   public void empSalary(double empSalary){      salary = empSalary;   }   /* 打印信息 */   public void printEmployee(){      System.out.println("名字:"+ name );      System.out.println("年龄:" + age );      System.out.println("职位:" + designation );      System.out.println("薪水:" + salary);   }}</code></pre><p><strong>程序都是从main方法开始执行</strong>。为了能<strong>运行这个程序</strong>，必须<strong>包含main方法</strong>并且<strong>创建一个实例对象</strong>。</p><p>下面给出EmployeeTest类，该类实例化<strong>2个 Employee 类的实例</strong>，并调用方法<strong>设置变量的值</strong>。</p><p>EmployeeTest.java文件代码：</p><pre><code>import java.io.*;public class EmployeeTest{   public static void main(String[] args){      /* 使用构造器创建两个对象 */      Employee empOne = new Employee("RUNOOB1");      Employee empTwo = new Employee("RUNOOB2");      // 调用这两个对象的成员方法      empOne.empAge(26);      empOne.empDesignation("高级程序员");      empOne.empSalary(1000);      empOne.printEmployee();      empTwo.empAge(21);      empTwo.empDesignation("菜鸟程序员");      empTwo.empSalary(500);      empTwo.printEmployee();   }}</code></pre><p>编译这两个文件并且运行 EmployeeTest 类，可以看到如下结果：</p><pre><code>名字:RUNOOB1年龄:26职位:高级程序员薪水:1000.0名字:RUNOOB2年龄:21职位:菜鸟程序员薪水:500.0</code></pre><h2 id="Java-基本数据类型"><a href="#Java-基本数据类型" class="headerlink" title="Java 基本数据类型"></a>Java 基本数据类型</h2><p>变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。</p><p>内存管理系统<strong>根据变量的类型</strong>为变量分配存储空间，分配的空间<strong>只能用来储存该类型数据</strong>。</p><p><img src="https://www.runoob.com/wp-content/uploads/2013/12/memorypic1.jpg" alt=""></p><p>因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。</p><p>Java 的两大数据类型:</p><ul><li><strong>内置</strong>数据类型</li><li><strong>引用</strong>数据类型</li></ul><h3 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a>内置数据类型</h3><p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。 </p><p><strong>四个整数型</strong>：</p><p><strong>byte</strong>：</p><ul><li>byte 数据类型是<strong>8位</strong>、有符号的，以<strong>二进制补码</strong>表示的整数；</li><li><strong>最小值</strong>是 <strong>-128（-2^7）</strong>；</li><li><strong>最大值</strong>是 <strong>127（2^7-1）</strong>；</li><li>默认值是 0；</li><li>byte 类型<strong>用在大型数组</strong>中节约空间，主要<strong>代替整数</strong>，因为 byte 变量占用的空间<strong>只有 int 类型的四分之一</strong>；</li><li>例子：byte a = 100，byte b = -50。</li></ul><p><strong>short</strong>：</p><ul><li>short 数据类型是 <strong>16 位</strong>、有符号的以二进制补码表示的整数</li><li>最小值是 -32768（-2^15）；</li><li>最大值是 32767（2^15 - 1）；</li><li>Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；</li><li>默认值是 0；</li><li>例子：short s = 1000，short r = -20000。</li></ul><p><strong>int</strong>：</p><ul><li>int 数据类型是<strong>32位</strong>、有符号的以二进制补码表示的整数；</li><li>最小值是 -2,147,483,648（-2^31）；</li><li>最大值是 2,147,483,647（2^31 - 1）；</li><li>一般地<strong>整型变量默认为 int 类型</strong>；</li><li>默认值是 0 ；</li><li>例子：int a = 100000, int b = -200000。</li></ul><p><strong>long</strong>：</p><ul><li>long 数据类型是 64 位、有符号的以二进制补码表示的整数；</li><li>最小值是 -9,223,372,036,854,775,808（-2^63）；</li><li>最大值是 9,223,372,036,854,775,807（2^63 -1）；</li><li>这种类型主要<strong>使用在需要比较大整数的系统</strong>上；</li><li>默认值是 <strong>0L</strong>；</li><li>例子： long a = 100000<strong>L</strong>，Long b = -200000<strong>L</strong>。</li><li>“L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以<strong>最好大写</strong>。 </li></ul><p><strong>两个浮点型</strong>：</p><p><strong>float</strong>：</p><ul><li>float 数据类型是<strong>单精度</strong>、<strong>32位</strong>、符合IEEE 754标准的浮点数；</li><li>float 在<strong>储存大型浮点数组</strong>的时候<strong>可节省内存</strong>空间；</li><li>默认值是 <strong>0.0f</strong>；</li><li>浮点数不能用来表示精确的值，如货币；</li><li>例子：float f1 = 234.5f。</li></ul><p><strong>double</strong>：</p><ul><li>double 数据类型是<strong>双精度</strong>、<strong>64 位</strong>、符合IEEE 754标准的浮点数；</li><li><strong>浮点数的默认类型</strong>为<strong>double</strong>类型；</li><li>double类型同样不能表示精确的值，如货币；</li><li>默认值是 <strong>0.0d</strong>；</li><li>例子：double d1 = 123.4。</li></ul><p><strong>布尔型</strong>：</p><p><strong>boolean</strong>：</p><ul><li>boolean数据类型表示一位的信息；</li><li><strong>只有两个取值</strong>：true 和 false；</li><li>这种类型只作为一种标志来记录 true/false 情况；</li><li>默认值是 false；</li><li>例子：boolean one = true。</li></ul><p><strong>字符型</strong>：</p><p><strong>char</strong>：</p><ul><li>char类型是一个<strong>单一的 16 位 Unicode 字符</strong>；</li><li>最小值是 \u0000（即为0）；</li><li>最大值是 \uffff（即为65,535）；</li><li>char 数据类型<strong>可以储存任何字符</strong>；</li><li>例子：char letter = ‘A’;。</li></ul><h4 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h4><p>对于数值类型的基本类型的<strong>取值范围，我们无需强制去记忆</strong>，因为它们的<strong>值都已经以常量的形式定义在对应的包装类</strong>中了。请看下面的例子：</p><pre><code>public class PrimitiveTypeTest {      public static void main(String[] args) {          // byte          System.out.println("基本类型：byte 二进制位数：" + Byte.SIZE);          System.out.println("包装类：java.lang.Byte");          System.out.println("最小值：Byte.MIN_VALUE=" + Byte.MIN_VALUE);          System.out.println("最大值：Byte.MAX_VALUE=" + Byte.MAX_VALUE);          System.out.println();          // short          System.out.println("基本类型：short 二进制位数：" + Short.SIZE);          System.out.println("包装类：java.lang.Short");          System.out.println("最小值：Short.MIN_VALUE=" + Short.MIN_VALUE);          System.out.println("最大值：Short.MAX_VALUE=" + Short.MAX_VALUE);          System.out.println();          // int          System.out.println("基本类型：int 二进制位数：" + Integer.SIZE);          System.out.println("包装类：java.lang.Integer");          System.out.println("最小值：Integer.MIN_VALUE=" + Integer.MIN_VALUE);          System.out.println("最大值：Integer.MAX_VALUE=" + Integer.MAX_VALUE);          System.out.println();          // long          System.out.println("基本类型：long 二进制位数：" + Long.SIZE);          System.out.println("包装类：java.lang.Long");          System.out.println("最小值：Long.MIN_VALUE=" + Long.MIN_VALUE);          System.out.println("最大值：Long.MAX_VALUE=" + Long.MAX_VALUE);          System.out.println();          // float          System.out.println("基本类型：float 二进制位数：" + Float.SIZE);          System.out.println("包装类：java.lang.Float");          System.out.println("最小值：Float.MIN_VALUE=" + Float.MIN_VALUE);          System.out.println("最大值：Float.MAX_VALUE=" + Float.MAX_VALUE);          System.out.println();          // double          System.out.println("基本类型：double 二进制位数：" + Double.SIZE);          System.out.println("包装类：java.lang.Double");          System.out.println("最小值：Double.MIN_VALUE=" + Double.MIN_VALUE);          System.out.println("最大值：Double.MAX_VALUE=" + Double.MAX_VALUE);          System.out.println();          // char          System.out.println("基本类型：char 二进制位数：" + Character.SIZE);          System.out.println("包装类：java.lang.Character");          // 以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台          System.out.println("最小值：Character.MIN_VALUE="                  + (int) Character.MIN_VALUE);          // 以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台          System.out.println("最大值：Character.MAX_VALUE="                  + (int) Character.MAX_VALUE);      }  }</code></pre><p>编译以上代码输出结果如下所示：</p><pre><code>基本类型：byte 二进制位数：8包装类：java.lang.Byte最小值：Byte.MIN_VALUE=-128最大值：Byte.MAX_VALUE=127基本类型：short 二进制位数：16包装类：java.lang.Short最小值：Short.MIN_VALUE=-32768最大值：Short.MAX_VALUE=32767基本类型：int 二进制位数：32包装类：java.lang.Integer最小值：Integer.MIN_VALUE=-2147483648最大值：Integer.MAX_VALUE=2147483647基本类型：long 二进制位数：64包装类：java.lang.Long最小值：Long.MIN_VALUE=-9223372036854775808最大值：Long.MAX_VALUE=9223372036854775807基本类型：float 二进制位数：32包装类：java.lang.Float最小值：Float.MIN_VALUE=1.4E-45最大值：Float.MAX_VALUE=3.4028235E38基本类型：double 二进制位数：64包装类：java.lang.Double最小值：Double.MIN_VALUE=4.9E-324最大值：Double.MAX_VALUE=1.7976931348623157E308基本类型：char 二进制位数：16包装类：java.lang.Character最小值：Character.MIN_VALUE=0最大值：Character.MAX_VALUE=65535</code></pre><p>Float和Double的最小值和最大值都是以科学记数法的形式输出的，结尾的<strong>“E+数字”表示E之前的数字要乘以10的多少次方</strong>。比如<strong>3.14E3就是3.14 × 103 =3140</strong>，<strong>3.14E-3 就是 3.14 x 10-3 =0.00314</strong>。</p><p>实际上，JAVA中还存在<strong>另外一种基本类型 void</strong>，它也有对应的包装类 <strong>java.lang.Void</strong>，不过我们<strong>无法直接对它们进行操作</strong>。</p><h3 id="类型默认值"><a href="#类型默认值" class="headerlink" title="类型默认值"></a>类型默认值</h3><p>下表列出了 Java 各个类型的默认值：</p><table><thead><tr><th align="left">数据类型</th><th align="right">默认值</th></tr></thead><tbody><tr><td align="left">byte</td><td align="right">0</td></tr><tr><td align="left">short</td><td align="right">0</td></tr><tr><td align="left">int</td><td align="right">0</td></tr><tr><td align="left">long</td><td align="right">0L</td></tr><tr><td align="left">float</td><td align="right">0.0f</td></tr><tr><td align="left">double</td><td align="right">0.0d</td></tr><tr><td align="left">char</td><td align="right">‘u0000’</td></tr><tr><td align="left">String (or any object)</td><td align="right">null</td></tr><tr><td align="left">boolean</td><td align="right">false</td></tr></tbody></table><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><pre><code>public class Test {    //类变量    static boolean bool;    static byte by;    static char ch;    static double d;    static float f;    static int i;    static long l;    static short sh;    static String str;    public static void main(String[] args) {        System.out.println("Bool :" + bool);        System.out.println("Byte :" + by);        System.out.println("Character:" + ch);        System.out.println("Double :" + d);        System.out.println("Float :" + f);        System.out.println("Integer :" + i);        System.out.println("Long :" + l);        System.out.println("Short :" + sh);        System.out.println("String :" + str);    }}</code></pre><p>实例输出结果为：</p><pre><code>Bool     :falseByte     :0Character:Double   :0.0Float    :0.0Integer  :0Long     :0Short    :0String   :null</code></pre><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><ul><li>在Java中，引用类型的变量非常<strong>类似于C/C++的指针</strong>。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。</li><li><strong>对象、数组都是引用数据类型。</strong></li><li>所有引用类型的<strong>默认值都是null</strong>。</li><li>一个引用变量可以用来引用任何与之兼容的类型。</li><li>例子：Site site = new Site(“Runoob”)。</li></ul><h3 id="Java-常量"><a href="#Java-常量" class="headerlink" title="Java 常量"></a>Java 常量</h3><p>常量在<strong>程序运行时是不能被修改</strong>的。</p><p>在 Java 中使用 <strong>final 关键字</strong>来<strong>修饰</strong>常量，声明方式和变量类似：</p><pre><code>final double PI = 3.1415927;</code></pre><p>虽然常量名也可以用小写，但为了便于识别，通常使用<strong>大写字母表示常量</strong>。 </p><p><strong>字面量</strong>可以赋给<strong>任何内置类型的变量</strong>。例如：</p><pre><code>byte a = 68;char a = 'A'</code></pre><p><strong>byte、int、long、和short</strong>都<strong>可以用十进制、16进制以及8进制</strong>的方式来表示。</p><p>当使用常量的时候，<strong>前缀 0 表示 8 进制</strong>，而<strong>前缀 0x 代表 16 进制</strong>, 例如：</p><pre><code>int decimal = 100;int octal = 0144;int hexa =  0x64;</code></pre><p>和其他语言一样，Java的<strong>字符串常量</strong>也是包含在两个引号之间的字符序列。下面是字符串型字面量的例子：</p><pre><code>"Hello World""two\nlines""\"This is in quotes\""</code></pre><p><strong>字符串常量和字符常量</strong>都<strong>可以包含任何Unicode字符</strong>。例如：</p><pre><code>char a = '\u0001';String a = "\u0001";</code></pre><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>整型、实型（常量）、字符型数据可以<strong>混合运算</strong>。运算中，不同类型的数据先转化为同一类型，然后进行运算。</p><p>转换从<strong>低级到高级</strong>。</p><pre><code>低  ------------------------------------&gt;  高byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double</code></pre><p>数据类型转换<strong>必须满足</strong>如下规则：</p><ul><li><p><strong>不能对boolean类型进行类型转换</strong>。</p></li><li><p><strong>不能把对象类型转换成不相关类的对象</strong>。</p></li><li><p><strong>在把容量大的类型转换为容量小的类型时必须使用强制类型转换</strong>。</p></li><li><p>转换过程中可能导致<strong>溢出或损失精度</strong>，例如：</p><pre><code>int i =128;   byte b = (byte)i;</code></pre><p>因为 <strong>byte 类型是 8 位，最大值为127</strong>。所以当<strong>int 强制转换为 byte</strong>类型时，<strong>值 128 时候就会导致溢出</strong>。</p></li><li><p><strong>浮点数到整数</strong>的转换是通过<strong>舍弃小数</strong>得到，而<strong>不是四舍五入</strong>，例如：</p><pre><code>(int)23.7 == 23;        (int)-45.89f == -45</code></pre></li></ul><h3 id="自动类型转换-1"><a href="#自动类型转换-1" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>必须满足<strong>转换前的数据类型的位数要低于转换后的数据类型(低转高)</strong>，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。 </p><pre><code>public class ZiDongLeiZhuan{        public static void main(String[] args){            char c1='a';//定义一个char类型            int i1 = c1;//char自动类型转换为int            System.out.println("char自动类型转换为int后的值等于"+i1);            char c2 = 'A';//定义一个char类型            int i2 = c2+1;//char 类型和 int 类型计算            System.out.println("char类型和int计算后的值等于"+i2);        }}</code></pre><p>运行结果为:</p><pre><code>char自动类型转换为int后的值等于97char类型和int计算后的值等于66</code></pre><p><strong>解析：c1 的值为字符 a ,查 ASCII 码表可知对应的 int 类型值为 97， A 对应值为 65，所以 i2=65+1=66。</strong></p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><ol><li>条件是转换的<strong>数据类型必须是兼容</strong>的。</li><li>格式：(type)value type是要强制类型转换后的数据类型 实例：<pre><code>public class QiangZhiZhuanHuan{ public static void main(String[] args){     int i1 = 123;     byte b = (byte)i1;//强制类型转换为byte     System.out.println("int强制类型转换为byte后的值等于"+b); }}</code></pre>运行结果：<pre><code>int强制类型转换为byte后的值等于123</code></pre></li></ol><h3 id="隐含强制类型转换"><a href="#隐含强制类型转换" class="headerlink" title="隐含强制类型转换"></a>隐含强制类型转换</h3><ol><li><strong>整数的默认类型是 int</strong>。</li><li><strong>浮点型不存在这种情况</strong>，因为在<strong>定义 float 类型时必须在数字后面跟上 F 或者 f</strong>。 </li></ol><h1 id="Java-变量类型"><a href="#Java-变量类型" class="headerlink" title="Java 变量类型"></a>Java 变量类型</h1><p>在Java语言中，所有的<strong>变量在使用前必须声明</strong>。声明变量的基本格式如下：</p><pre><code>type identifier [ = value][, identifier [= value] ...] ;  //[]表示可选</code></pre><p><strong>格式说明：type为Java数据类型。identifier是变量名。可以使用逗号隔开来声明多个同类型变量。</strong></p><p>以下列出了一些变量的声明实例。注意有些包含了初始化过程。</p><pre><code>int a, b, c;         // 声明三个int型整数：a、 b、cint d = 3, e = 4, f = 5; // 声明三个整数并赋予初值byte z = 22;         // 声明并初始化 zString s = "runoob";  // 声明并初始化字符串 sdouble pi = 3.14159; // 声明了双精度浮点型变量 pichar x = 'x';        // 声明变量 x 的值是字符 'x'。</code></pre><p>Java语言支持的变量类型有：</p><ul><li><strong>类变量</strong>：<strong>类中，独立于方法之外</strong>的变量，<strong>用 static 修饰</strong>。</li><li><strong>实例变量</strong>：<strong>类中，独立于方法之外</strong>的变量，不过<strong>没有 static 修饰</strong>。 </li><li><strong>局部变量</strong>：类的方法中的变量。</li></ul><pre><code>public class Variable{    static int allClicks=0;    // 类变量    String str="hello world";  // 实例变量    public void method(){        int i =0;  // 局部变量    }}</code></pre><h3 id="Java-局部变量"><a href="#Java-局部变量" class="headerlink" title="Java 局部变量"></a>Java 局部变量</h3><ul><li>局部变量声明在<strong>方法、构造方法或者语句块中</strong>；</li><li>局部变量在方法、构造方法、或者语句块<strong>被执行的时候创建</strong>，当它们<strong>执行完成后，变量将会被销毁</strong>；</li><li><strong>访问修饰符不能用于局部变量</strong>；</li><li>局部变量只在声明它的方法、构造方法或者语句块中可见；</li><li>局部变量是在<strong>栈上分配的</strong>。</li><li>局部变量<strong>没有默认值</strong>，所以局部变量<strong>被声明后，必须经过初始化，才可以使用</strong>。</li></ul><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例 1"></a>实例 1</h4><p>在以下实例中age是一个局部变量。定义在pupAge()方法中，它的作用域就限制在这个方法中。</p><pre><code>package com.runoob.test;public class Test{    public void pupAge(){      int age = 0;      age = age + 7;      System.out.println("小狗的年龄是: " + age);   }   public static void main(String[] args){      Test test = new Test();      test.pupAge();   }}</code></pre><p>以上实例编译运行结果如下:</p><pre><code>小狗的年龄是: 7</code></pre><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例 2"></a>实例 2</h4><p>在下面的例子中 age 变量没有初始化，所以在编译时会出错：</p><pre><code>package com.runoob.test;public class Test{    public void pupAge(){      int age;      age = age + 7;      System.out.println("小狗的年龄是 : " + age);   }   public static void main(String[] args){      Test test = new Test();      test.pupAge();   }}</code></pre><p>以上实例编译运行结果如下:</p><pre><code>Test.java:4:variable number might not have been initializedage = age + 7;         ^1 error</code></pre><h3 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h3><ul><li>实例变量<strong>声明在一个类中，但在方法、构造方法和语句块之外</strong>；</li><li>当一个对象被<strong>实例化之后，每个实例变量的值就跟着确定</strong>；</li><li>实例变量在<strong>对象创建的时候创建，在对象被销毁的时候销毁</strong>；</li><li>实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；</li><li>实例变量可以声明在使用前或者使用后；</li><li><strong>访问修饰符可以修饰实例变量</strong>；</li><li>实例变量<strong>对于类中的方法、构造方法或者语句块是可见的</strong>。一般情况下<strong>应该把实例变量设为私有</strong>。通过<strong>使用访问修饰符可以使实例变量对子类可见</strong>；</li><li><strong>实例变量具有默认值</strong>。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的<strong>值可以在声明时指定，也可以在构造方法中指定</strong>；</li><li>实例变量可以直接通过变量名访问。但在<strong>静态方法以及其他类中</strong>，就应该<strong>使用完全限定名：<code>ObejectReference.VariableName</code>。</strong></li></ul><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><p><strong>Employee.java 文件代码</strong>：</p><pre><code>import java.io.*;public class Employee{   // 这个实例变量对子类可见   public String name;   // 私有变量，仅在该类可见   private double salary;   //在构造器中对name赋值   public Employee (String empName){      name = empName;   }   //设定salary的值   public void setSalary(double empSal){      salary = empSal;   }     // 打印信息   public void printEmp(){      System.out.println("名字 : " + name );      System.out.println("薪水 : " + salary);   }   public static void main(String[] args){      Employee empOne = new Employee("RUNOOB");      empOne.setSalary(1000.0);      empOne.printEmp();   }}</code></pre><p>以上实例编译运行结果如下:</p><pre><code>名字 : RUNOOB薪水 : 1000.0</code></pre><h3 id="类变量（静态变量）"><a href="#类变量（静态变量）" class="headerlink" title="类变量（静态变量）"></a>类变量（静态变量）</h3><ul><li><p>类变量<strong>也称为静态变量</strong>，在类中<strong>以 static 关键字声明，但必须在方法之外</strong>。</p></li><li><p>无论一个类创建了多少个对象，<strong>类只拥有类变量的一份拷贝</strong>。</p></li><li><p><strong>静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变</strong>。</p></li><li><p><strong>静态变量储存在静态存储区。经常被声明为常量，很少<code>单独</code>使用static声明变量</strong>。</p></li><li><p>静态变量在<strong>第一次被访问时创建，在程序结束时销毁</strong>。</p></li><li><p>与实例变量具有相似的可见性。但<strong>为了对类的使用者可见，大多数静态变量声明为public类型</strong>。</p></li><li><p>默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</p></li><li><p><strong>静态变量可以通过：<code>ClassName.VariableName</code>的方式访问</strong>。</p></li><li><p>类变量<strong>被声明为<code>public static final</code>类型时</strong>，类变量<strong>名称一般建议使用大写字母</strong>。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。</p></li><li><p>怎么理解静态变量呢？简单来说<strong><code>静态变量</code>就是一个<code>类的公有属性</code>。</strong>在这里可以打个拙劣的比方：假设“班里的学生”是一个类，班里的任何一个同学都相当于一个对象。那么所有学生的学费是一样的对吧？”学费“就相当于一个”静态变量“，其特征是它不属于任何一个”对象“（即学生）的专有属性，是大家”公有“的，若是变了，那就所有的同学的学费都会变。我们假设每个同学都有修改学费的权力，那么任何一个同学修改了学费（这个静态变量），所有同学的学费就都会变。</p></li></ul><h4 id="实例：-1"><a href="#实例：-1" class="headerlink" title="实例："></a>实例：</h4><p>Employee.java 文件代码：</p><pre><code>import java.io.*;public class Employee {    //salary是静态的私有变量    private static double salary;    // DEPARTMENT是一个常量    public static final String DEPARTMENT = "开发人员";    public static void main(String[] args){    salary = 10000;        System.out.println(DEPARTMENT+"平均工资:"+salary);    }}</code></pre><p>以上实例编译运行结果如下:</p><pre><code>开发人员平均工资:10000.0</code></pre><p><strong>注意：如果<code>其他类</code>想要访问该变量，可以这样访问：Employee.DEPARTMENT。</strong></p><h2 id="Java-修饰符-1"><a href="#Java-修饰符-1" class="headerlink" title="Java 修饰符"></a>Java 修饰符</h2><p>Java语言提供了很多修饰符，主要分为以下两类：</p><ul><li><strong>访问</strong>修饰符</li><li><strong>非访问</strong>修饰符</li></ul><p>修饰符用来<strong>定义类、方法或者变量</strong>，通常<strong>放在语句的最前端</strong>。我们通过下面的例子来说明： </p><pre><code>public class ClassName {   private boolean myFlag;   static final double weeks = 9.5;   protected static final int BOXWIDTH = 42;   public static void main(String[] arguments) {      // 方法体   }}</code></pre><h3 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h3><p>Java中，可以<strong>使用访问控制符来保护对类、变量、方法和构造方法的访问</strong>。Java 支持<strong>4 种不同的访问权限</strong>。</p><ul><li><strong>default</strong> <strong>(即默认，什么也不写）: 在<code>同一包内</code>可见，不使用任何修饰符。</strong>使用对象：<strong>类</strong>、接口、变量、方法。</li><li><strong>private</strong> : <strong>在<code>同一类内</code>可见</strong>。使用对象：变量、方法。 <strong>注意：不能修饰类!!!（外部类）</strong></li><li><strong>public</strong> : <strong>对<code>所有类</code>可见</strong>。使用对象：<strong>类</strong>、接口、变量、方法</li><li><strong>protected</strong> : <strong>对<code>同一包内的类</code>和<code>所有子类</code>可见</strong>。使用对象：变量、方法。 <strong>注意：不能修饰类!!!（外部类）。</strong></li></ul><h4 id="默认访问修饰符-不使用任何关键字"><a href="#默认访问修饰符-不使用任何关键字" class="headerlink" title="默认访问修饰符-不使用任何关键字"></a>默认访问修饰符-不使用任何关键字</h4><p>使用<strong>默认访问修饰符声明的变量和方法，对同一个包内的类是可见的</strong>。</p><p><strong>特殊：<code>接口</code>里的<code>变量</code>都隐式声明为 <code>public static final</code>,而<code>接口</code>里的<code>方法</code>默认情况下访问权限为 <code>public</code></strong>。 </p><p>如下例所示，<strong>变量和方法的声明可以不使用任何修饰符</strong>。 </p><pre><code>String version = "1.5.1";boolean processOrder() {   return true;}</code></pre><h4 id="私有访问修饰符-private"><a href="#私有访问修饰符-private" class="headerlink" title="私有访问修饰符-private"></a>私有访问修饰符-private</h4><p>私有访问修饰符是<strong>最严格的访问级别</strong>，所以被声明为 <strong>private 的<code>方法、变量和构造方法</code>只能被所属类访问</strong>，并且<strong><code>类和接口</code>不能声明为 private</strong>。</p><p>声明为<strong>私有访问类型的变量只能通过类中<code>公共的 getter 方法</code>被外部类访问</strong>。</p><p>Private 访问修饰符的使用主要用来<strong>隐藏类的实现细节和保护类的数据</strong>。</p><p>下面的类使用了私有访问修饰符：</p><pre><code>public class Logger {   private String format;   public String getFormat() {      return this.format;   }   public void setFormat(String format) {      this.format = format;   }}</code></pre><p><strong>实例中，Logger 类中的 format 变量为<code>私有变量</code>，所以其他类不能直接得到和设置该变量的值。为了使其他类能够操作该变量，定义了两个 <code>public 方法</code>：getFormat() （返回 format的值）和 setFormat(String)（设置 format 的值）</strong></p><h4 id="公有访问修饰符-public"><a href="#公有访问修饰符-public" class="headerlink" title="公有访问修饰符-public"></a>公有访问修饰符-public</h4><p>被声明为 public 的类、方法、构造方法和接口<strong>能够被任何其他类访问</strong>。 </p><p><strong>如果几个相互访问的 public 类分布在不同的包中，则需要<code>导入</code>相应 public 类所在的包。</strong>由于类的继承性，<strong>类所有的<code>公有方法和变量</code>都能被其子类继承</strong>。 </p><p>以下函数使用了公有访问控制：</p><pre><code>public static void main(String[] arguments) {   // ...}</code></pre><p><strong>Java 程序的 <code>main() 方法必须设置成公有的</code>，否则，Java 解释器将不能运行该类</strong>。</p><h4 id="受保护的访问修饰符-protected"><a href="#受保护的访问修饰符-protected" class="headerlink" title="受保护的访问修饰符-protected"></a>受保护的访问修饰符-protected</h4><p>protected 需要从以下两个点来分析说明：</p><ul><li><strong>子类与基类在同一包中</strong>：被声明为 protected 的<strong><code>变量、方法和构造器</code>能被同一个包中的任何其他类访问</strong>；</li><li><strong>子类与基类不在同一包中</strong>：那么在子类中，<strong>子类实例可以访问其<code>从基类继承</code>而来的 protected <code>方法</code>，而不能访问<code>基类实例</code>的protected方法</strong>。</li></ul><p>protected 可以修饰数据成员，构造方法，方法成员，<strong>不能修饰类!!!（内部类除外）</strong>。</p><p><strong><code>接口及接口的成员变量和成员方法</code>不能声明为 protected。</strong></p><p>子类能访问 protected 修饰符声明的方法和变量，这样就能<strong>防止不相关的类使用这些方法和变量</strong>。</p><p>下面的父类使用了 protected 访问修饰符，<strong>子类重写了父类的 openSpeaker() 方法</strong>。</p><pre><code>class AudioPlayer {   protected boolean openSpeaker(Speaker sp) {      // 实现细节   }}class StreamingAudioPlayer extends AudioPlayer {   protected boolean openSpeaker(Speaker sp) {      // 重写后的实现细节   }}</code></pre><p>如果把 openSpeaker() 方法声明为 private，那么除了 AudioPlayer 之外的类将不能访问该方法。</p><p>如果把 openSpeaker() 声明为 public，那么所有的类都能够访问该方法。</p><p>如果我们<strong>只想让该方法对其<code>所在类的子类可见</code>，则将该方法声明为 protected</strong>。</p><h4 id="访问控制和继承"><a href="#访问控制和继承" class="headerlink" title="访问控制和继承"></a>访问控制和继承</h4><p>请注意以下方法继承的规则： </p><ul><li><strong>父类中声明为 public 的<code>方法</code>在子类中也必须为 public</strong>。</li><li><strong>父类中声明为 protected 的<code>方法</code>在子类中要么声明为 protected，要么声明为 public，不能声明为 private</strong>。</li><li><strong>父类中声明为 private 的<code>方法</code>，不能够被继承</strong>。</li></ul><h3 id="非访问修饰符"><a href="#非访问修饰符" class="headerlink" title="非访问修饰符"></a>非访问修饰符</h3><p>为了实现一些其他的功能，Java 也提供了许多非访问修饰符。</p><p><strong>static</strong> 修饰符，用来修饰<strong><code>类方法</code>和<code>类变量</code></strong>。</p><p><strong>final</strong> 修饰符，用来修饰类、方法和变量，<strong>final 修饰的<code>类不能够被继承</code>，修饰的<code>方法不能被继承类重新定义</code>，修饰的<code>变量为常量</code>，是不可修改的</strong>。</p><p><strong>abstract</strong> 修饰符，用来创建<strong><code>抽象类</code>和<code>抽象方法</code></strong>。</p><p><strong>synchronized 和 volatile</strong> 修饰符，主要用于<strong><code>线程的编程</code></strong>。</p><h4 id="static-修饰符"><a href="#static-修饰符" class="headerlink" title="static 修饰符"></a>static 修饰符</h4><ul><li><p><strong>静态变量</strong>：<br>static 关键字用来<strong>声明<code>独立于对象</code>的静态变量，无论一个类实例化多少对象，它的静态变量只有<code>一份拷贝</code></strong>。 静态变量也被称为<strong><code>类变量</code>。<code>局部变量</code>不能被声明为 static 变量</strong>。 </p></li><li><p><strong>静态方法</strong>：<br>static 关键字用来<strong>声明<code>独立于对象</code>的静态方法。<code>静态方法</code>不能使用类的<code>非静态变量</code></strong>。静态方法从参数列表得到数据，然后计算这些数据。 </p><p><strong>对<code>类变量</code>和<code>方法</code>的访问可以直接使用 <code>classname.variablename</code> 和 <code>classname.methodname</code> 的方式访问</strong>。 </p><p>如下例所示，static修饰符用来创建类方法和类变量。</p><pre><code>public class InstanceCounter {  private static int numInstances = 0;  protected static int getCount() {     return numInstances;  }  private static void addInstance() {     numInstances++;  }  InstanceCounter() {     InstanceCounter.addInstance();  }  public static void main(String[] arguments) {     System.out.println("Starting with " +     InstanceCounter.getCount() + " instances");     for (int i = 0; i &lt; 500; ++i){        new InstanceCounter();         }     System.out.println("Created " +     InstanceCounter.getCount() + " instances");  }}</code></pre><p>以上实例运行编辑结果如下:</p><pre><code>Starting with 0 instancesCreated 500 instances</code></pre></li></ul><h4 id="final-修饰符"><a href="#final-修饰符" class="headerlink" title="final 修饰符"></a>final 修饰符</h4><p><strong>final 变量</strong>：  </p><p>final 表示<strong>“最后的、最终的”</strong>含义，<code>变量</code><strong>一旦赋值后，不能被重新赋值。被 final 修饰的<code>实例变量</code>必须<code>显式指定初始值</code></strong>。</p><p><strong><code>final</code>修饰符通常和<code>static</code>修饰符一起使用来创建<code>类常量</code></strong>。</p><p>实例</p><pre><code>public class Test{  final int value = 10;  // 下面是声明常量的实例  public static final int BOXWIDTH = 6;  static final String TITLE = "Manager";  public void changeValue(){     value = 12; //不能重新赋值，将输出一个错误  }}</code></pre><p><strong>final 方法</strong></p><p>父类中的 final 方法<strong>可以被子类继承，但是不能被子类重写</strong>。</p><p>声明 final 方法的<strong>主要目的是防止该方法的内容被修改</strong>。</p><p>如下所示，使用 final 修饰符声明方法。</p><pre><code>public class Test{    public final void changeName(){       // 方法体    }}</code></pre><p><strong>final 类</strong></p><p><strong>final 类<code>不能被继承</code>，没有类能够继承 final 类的任何特性</strong>。</p><p>实例</p><pre><code>public final class Test {   // 类体}</code></pre><h4 id="abstract-修饰符"><a href="#abstract-修饰符" class="headerlink" title="abstract 修饰符"></a>abstract 修饰符</h4><p><strong>抽象类：</strong></p><p>抽象类<strong>不能用来<code>实例化对象</code>，声明抽象类的<code>唯一目的</code>是为了将来<code>对该类进行扩充</code>。</strong></p><p><strong>一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类</strong>，否则将出现编译错误。 </p><p><strong>抽象类可以包含<code>抽象方法</code>和<code>非抽象方法</code>。</strong></p><p> 实例</p><pre><code> abstract class Caravan{    private double price;    private String model;    private String year;    public abstract void goFast(); //抽象方法    public abstract void changeColor(); //抽象方法 }</code></pre><p><strong>抽象方法</strong></p><p>抽象方法是<strong>一种没有任何实现的方法，该方法的的具体实现由子类提供</strong>。</p><p>抽象<strong>方法不能被声明成 final 和 static</strong>。 </p><p>任何继承抽象类的<strong>子类必须实现父类的<code>所有</code>抽象方法，除非该子类也是抽象类</strong>。 </p><p>如果一个类<strong>包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法</strong>。 </p><p>抽象<strong>方法的声明以分号结尾</strong>，例如：<strong><code>public abstract sample();</code></strong>。 </p><p>实例</p><pre><code>public abstract class SuperClass{    abstract void m(); //抽象方法}class SubClass extends SuperClass{     //实现抽象方法      void m(){          .........      }}</code></pre><h4 id="synchronized-修饰符"><a href="#synchronized-修饰符" class="headerlink" title="synchronized 修饰符"></a>synchronized 修饰符</h4><p>synchronized 关键字<strong>声明的<code>方法</code>同一时间<code>只能被一个线程</code>访问</strong>。</p><p>synchronized 修饰符<strong>可以应用于四个<code>访问修饰符</code></strong>。 </p><p>实例</p><pre><code>public synchronized void showDetails(){.......}</code></pre><h4 id="transient-修饰符"><a href="#transient-修饰符" class="headerlink" title="transient 修饰符"></a>transient 修饰符</h4><p>序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。 </p><p>该修饰符包含在定义变量的语句中，用来<strong>预处理类和变量的数据类型</strong>。 </p><p>实例</p><pre><code>public transient int limit = 55;   // 不会持久化public int b; // 持久化</code></pre><h4 id="volatile-修饰符"><a href="#volatile-修饰符" class="headerlink" title="volatile 修饰符"></a>volatile 修饰符</h4><p><strong>volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存</strong>。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</p><p>一个 volatile 对象引用可能是 null。 </p><p>实例</p><pre><code>public class MyRunnable implements Runnable{    private volatile boolean active;    public void run()    {        active = true;        while (active) // 第一行        {            // 代码        }    }    public void stop()    {        active = false; // 第二行    }}</code></pre><p><strong>通常情况下，在一个线程调用 run() 方法（在 Runnable 开启的线程），在另一个线程调用 stop() 方法。 如果 第一行 中缓冲区的 active 值被使用，那么在 第二行 的 active 值为 false 时循环不会停止。</strong></p><p>但是以上代码中我们<strong>使用了 volatile 修饰 active，所以该循环会停止</strong>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建博客</title>
      <link href="/2020/04/04/hexo-github-da-jian-ge-ren-bo-ke/"/>
      <url>/2020/04/04/hexo-github-da-jian-ge-ren-bo-ke/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建博客笔记"><a href="#搭建博客笔记" class="headerlink" title="搭建博客笔记"></a>搭建博客笔记</h1><p>在B站看到github+hexo搭建个人博客的视频，一时间来了兴趣开始着手搭建。<br>此文章用于记录自己搭建的过程，也算是个小教程，内容集合了一些自己的理解和各路大神（太多，就不一一说了）的讲解。一方面方便自己以后回过头来查看。<br>另一方面想见证自己学习的过程。  </p><p><strong>GitHub page平台</strong>: GitHub是一个面向开源及私有软件项目的托管平台，因为只支持git作为唯一的版本库格式进行托管，故名GitHub.<br><strong>Github</strong>: <a href="https://github.com/" target="_blank" rel="noopener">网址</a>  </p><p><strong>Hexo</strong>: hexo是一个高效的静态网站生成框架，基于Node.js，快速，简单且功能强大，是搭建博客的首选框架。通过Hexo，你可以直接使用Markdown语法来撰写博客。<br><strong>Hexo</strong>: <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">网址</a></p><p>使用github平台上托管博客。我们可以放心写作，又不需要自购服务器域名那样定期维护，hexo作为一个快速简洁的博客框架，用它来搭建博客会非常轻松。</p><h2 id="一-搭建博客"><a href="#一-搭建博客" class="headerlink" title="一. 搭建博客"></a>一. 搭建博客</h2><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>由于Hexo是基于node.js编写的，所以要先安装node.js和里面的npm工具<strong>（Node.js打包管理工具）</strong>。<br><strong>Node.js</strong>: Node是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为与PHP、Python、Perl、Ruby 等服务端语言平起平坐的<strong>脚本语言</strong>。  </p><p><strong>Node</strong>: <a href="http://nodejs.cn/download/" target="_blank" rel="noopener">下载地址</a></p><h3 id="下载git"><a href="#下载git" class="headerlink" title="下载git"></a>下载git</h3><p>为了把本地的博客文件上传到github上面去，需要工具Git。  </p><p><strong>Git</strong>: Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者通过克隆（git clone），在本地机器上拷贝一个完整的Git仓库。</p><p><strong>git</strong>: <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">下载地址</a>  </p><p>下载后直接使用<strong>Git Bash</strong>输入命令,不需要用到cmd</p><h3 id="Git-Bash输入指令"><a href="#Git-Bash输入指令" class="headerlink" title="Git Bash输入指令"></a>Git Bash输入指令</h3><p>想对hexo 指令做更深入的了解，可以访问<a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">hexo指令网址</a></p><p>按顺序输入以后命令</p><a id="more"></a><pre><code>node -v           查看node版本，检查是否安装成功npm -v            查看npm版本，检查是否安装成功npm install -g cnpm --registry=http://registry.npm.taobao.org           安装淘宝的cnpm 管理器，阿里的国内镜像cnpm -v           查看cnpm版本，检查是否安装成功cnpm install -g hexo-cli           安装hexo博客框架hexo -v           查看hexo版本，检查是否安装成功mkdir blog        创建blog（名字自取）目录，存放博客文件cd blog           进入blog目录，此后对博客的修改基于blog目录hexo init         当前文件夹初始化-生成博客。</code></pre><p>新建完成后，我们的blog文件夹就有以下文件：</p><ul><li>node_modules: 依赖包，node.js各种库的目录</li><li>public：生成的网页文件目录</li><li>scaffolds：新文章和新页面的初始模板</li><li>source：用来存放你的文章和图片等资源文件<ul><li>_posts</li><li>assets</li></ul></li><li>themes：存放主题</li><li>_config.yml: 博客的配置文件<strong>（非常重要）</strong>  </li></ul><p>下面流程中我们在blog常用到的简单命令：  </p><ul><li><strong>hexo clean</strong>（清除缓存文件 (db.json) 和已生成的静态文件 (public)。<br>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。）</li><li><strong>hexo generate</strong>（可以简写为<strong>hexo g</strong>，生成静态文件）</li><li><strong>hexo server</strong>（可以简写为<strong>hexo s</strong>，启动服务器。默认情况下，访问网址为：<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> ）</li><li><strong>hexo deploy</strong>（可以简写为：<strong>hexo d</strong>，部署网站）</li></ul><p>了解完后，接着输入以下命令</p><pre><code>hexo server           http://localhost:4000/           默认本地访问地址hexo n "我的第一篇文章"           （名字可自取），创建新文章 返回blog目录hexo cleanhexo g</code></pre><p>打开Github，右上角+新建一个项目仓库New repository，项目命名为：<strong>Github自身用户名.github.io</strong><br>只有这样设置，将博客部署到github才会被识别</p><pre><code>cnpm install --save hexo-deployer-git         在blog目录下安装git部署插件</code></pre><h3 id="将hexo部署到GitHub"><a href="#将hexo部署到GitHub" class="headerlink" title="将hexo部署到GitHub"></a>将hexo部署到GitHub</h3><p>打开博客根目录下的_config.yml文件<strong>（博客的配置文件）</strong>，在这里你可以修改与博客配置相关的各种信息。  </p><p>修改博客最后一行</p><pre><code>deploy:  type: git  repo: https://github.com/YourGithubName/YourGithubName.github.io.git  branch: master</code></pre><p>repository改为自己github项目地址，就是部署时告诉工具，将生成网页通过git方式上传到你对应的链接仓库中。</p><pre><code>hexo cleanhexo ghexo d                                                                  注意deploy时可能要你输入username和password。https://YourGithubName.github.io/`                                      部署成功后，访问这个地址可以查看博客</code></pre><hr><h2 id="二-定制博客"><a href="#二-定制博客" class="headerlink" title="二. 定制博客"></a>二. 定制博客</h2><p>建议了解上方<strong>blog文件目录</strong>和<strong>hexo基本配置</strong>  </p><p>hexo配置文档：<a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">网址</a></p><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>hexo默认主题是lanscape，不过太显单调了。  </p><p>我们可以到github或是Hexo上下载自己喜欢的主题。</p><p>这里我推荐两个，一个是yilia，另一个则是matery。后续有较好的主题，我会继续推荐 </p><p><strong>yilia</strong>：<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">下载地址</a><br><strong>matery</strong>: <a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">下载地址</a><br><strong>next</strong>: <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">github排名第一主题，我在这里放出来</a></p><p>大家可以根据<strong>创作者放出的教程</strong>一步步安装主题，下面是一个yilia安装的示范：  </p><pre><code>git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia     通过克隆方式将yilia主题下到themes主题下的yilia目录下修改hexo根目录下的 _config.yml 文件 ：定位到 theme: yilia</code></pre><h3 id="添加404页面"><a href="#添加404页面" class="headerlink" title="添加404页面"></a>添加404页面</h3><p>原来的主题缺少404页面，我们可以自做。  </p><p>首先在/source/目录下新建一个<strong>404.md</strong>，可以用命令新建，也可以到_posts文件夹右键新建</p><pre><code>title: 404date: ''type: "404"layout: "404"description: "我崩溃了！真的！我都不知道你到底想找什么！！！"</code></pre><p>然后在/themes/matery/layout/目录下新建<strong>404.ejs</strong>文件</p><pre><code>&lt;style type="text/css"&gt;     /* don't remove. */     .about-cover {         height: 75vh;     } &lt;/style&gt; &lt;div class="bg-cover pd-header about-cover"&gt;    &lt;div class="container"&gt;         &lt;div class="row"&gt;             &lt;div class="col s10 offset-s1 m8 offset-m2 l8 offset-l2"&gt;                 &lt;div class="brand"&gt;                    &lt;div class="title center-align"&gt;                         404                     &lt;/div&gt;                     &lt;div class="description center-align"&gt;                         &lt;%= page.description %&gt;                     &lt;/div&gt;                 &lt;/div&gt;             &lt;/div&gt;         &lt;/div&gt;     &lt;/div&gt; &lt;/div&gt; &lt;script&gt;     // 每天切换 banner 图. Switch banner image every day.     $('.bg-cover').css('background-image', 'url(/medias/banner/' + new Date().getDay() + '.jpg)'); &lt;/script&gt;</code></pre><h3 id="添加live2D"><a href="#添加live2D" class="headerlink" title="添加live2D"></a>添加live2D</h3><p>大多数博客都有的看板娘<strong>(老婆)</strong>，最激动人心的环节来了~  </p><p>Live2D是一种应用于电子游戏的绘图渲染技术，由日本Cybernoids公司开发，通过一系列的连续图像和人物建模来生成一种类似二维图像的三维模型，换句话说就是2D的素材实现一定程度的3D效果，但只能是一定程度3D，因为Live 2D人物无法大幅度转身。</p><p><a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md" target="_blank" rel="noopener">详细过程</a></p><p>首先检查博客主目录下的<code>package.json</code>是否有<code>"hexo-helper-live2d": "^3.1.1"</code>依赖。<br>有的话可以先进行卸载：<code>npm uninstall hexo-helper-live2d</code>  </p><p>安装依赖：<code>npm install --save hexo-helper-live2d</code>  </p><p>成功了之后可以看到<code>blog</code>目录的<code>node_modules/</code>下有个<code>live2d-widget</code>目录，这是动画的主配置：</p><p>下载model文件，示例：<br><code>npm install live2d-widget-model-shizuku</code>,添加模型随自己挑选</p><p><a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener">模型</a></p><p>安装完成可以在<code>node_modules/</code>下看到<code>live2d-widget-model-shizuku</code>文件夹</p><p>最后，添加live2d看板娘到hexo:  </p><p>配置Hexo的<code>主_config.yml</code>或者使用的主题的<code>_config.yml</code><br>添加以下代码到配置文件中：</p><pre><code># live2dlive2d:  userConfig:   enable: true  scriptFrom: local  # pluginRootPath: live2dw/  # pluginJsPath: lib/  pluginModelPath: assets/  tagMode: false  debug: false  model:    use: live2d-widget-model-shizuku  display:    position: right    width: 200    height: 600    hOffset: 0       vOffset: -198    mobile:    show: true  react:    opacity: 1  dialog:    enable: true    hitokoto: true</code></pre><p>使用<code>hexo g</code>生成文件，<code>hexo s</code>即可在本地查看效果</p><h3 id="添加评论插件"><a href="#添加评论插件" class="headerlink" title="添加评论插件"></a>添加评论插件</h3><p>这个主题自带了gittalk、gitment、valine等评论插件，所以我们只需要去主题下的配置文件修改对应插件参数就行了。</p><p>注意：<strong>Valine</strong>评论模块，在blog目录下config.yml中。<code>appId</code>和<code>appKey</code>字段是需要自己注册登录<code>leancloud</code>官网，创建应用然后获取</p><p><a href="https://www.leancloud.cn/" target="_blank" rel="noopener">leanCloud网址</a></p><h3 id="添加博客动态标签"><a href="#添加博客动态标签" class="headerlink" title="添加博客动态标签"></a>添加博客动态标签</h3><p>原理就是给博客增加一个事件判断，如下图所示：</p><p>路径：<code>themes/matery/layout/layout.ejs</code>，在任意位置添加如下代码：</p><pre><code>&lt;script type="text/javascript"&gt;            var OriginTitile = document.title,                st;            document.addEventListener("visibilitychange", function () {                document.hidden ? (document.title = "✪ ω ✪你想捉迷藏吗", clearTimeout(st)) : (document.title =                    "ヾ(•ω•`)o找到你了！", st = setTimeout(function () {                        document.title = OriginTitile                    }, 3e3))            })&lt;/script&gt;</code></pre><hr><h2 id="三-博客优化"><a href="#三-博客优化" class="headerlink" title="三. 博客优化"></a>三. 博客优化</h2><h3 id="npm速度优化"><a href="#npm速度优化" class="headerlink" title="npm速度优化"></a>npm速度优化</h3><p>玩hexo的，肯定经常使用npm，但是npm的下载速度太慢。</p><p>前面我们提到过一次<strong>cnpm</strong>，下面介绍一下</p><ul><li>阿里的淘宝团队在国内做了个跟npm仓库一样的镜像叫cnpm。</li><li>淘宝镜像与npm官方包的同步频率目前为10分钟一次，来保证尽量与官方服务同步。</li><li>二者可以说是一样，可以说没有差别。</li></ul><p>安装cnpm命令：<br><code>npm install -g cnpm --registry=http://registry.npm.taobao.org</code></p><p>安装后，测试是否安装成功：<code>cnpm -v</code></p><p>成功后，以后都可以使用 <code>cnpm</code> 代替 <code>npm</code> 来执行命令</p><h3 id="全站CDN加速"><a href="#全站CDN加速" class="headerlink" title="全站CDN加速"></a>全站CDN加速</h3><p>CDN的全称是<strong>Content Delivery Network</strong>，即内容分发网络。</p><p>CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。</p><p>CDN的关键技术主要有内容存储和分发技术。</p><p>由于github使用国外服务器，放在Github的资源在国内加载速度比较慢，因此需要使用CDN加速来优化网站打开速度，jsDelivr + Github便是免费且好用的CDN，非常适合博客网站使用。</p><p>用法：<br><code>https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径</code></p><p>还可以配合PicGo图床上传工具的自定义域名前缀来上传图片，使用极其方便。</p><h3 id="打造稳定快速、高效免费图床"><a href="#打造稳定快速、高效免费图床" class="headerlink" title="打造稳定快速、高效免费图床"></a>打造稳定快速、高效免费图床</h3><p>本图床是基于Github的，采用jsdelivr cdn进行加速，上传工具采用的是PicGo。</p><p>新建一个GitHub仓库</p><p>在主页依次选择<code>Settings</code>-<code>Developer settings</code>-<code>Personal access tokens</code>-<code>Generate new token</code>，填写好描述，勾选<code>repo</code>（仓库权限），然后点击<code>Generate token</code>生成一个<code>Token</code>，注意这个Token只会显示一次，自己先保存下来，或者等后面配置好PicGo后再关闭此网页</p><p>配置PicGo</p><p>前往下载PicGo，安装好后开始配置Github图床</p><ul><li>设定仓库名：按照【用户名 / 图床仓库名】的格式填写</li><li>设定分支名：<code>master</code></li><li>设定Token：粘贴之前生成的<code>Token</code></li><li>指定存储路径：填写想要储存的路径，如images/，这样就会在仓库下创建一个名为 images 的文件夹，上传图片将会储存在此文件夹中</li><li>设定自定义域名：它的作用是，在图片上传后，PicGo会按照【自定义域名+储存路径+上传的图片名】的方式生成访问链接，放到粘贴板上，因为我们要使用 jsDelivr 加速访问，所以可以设置为<code>https://cdn.jsdelivr.net/gh/用户名/图床仓库名</code>，上传完毕后，我们就可以通过<code>https://cdn.jsdelivr.net/gh/用户名/图床仓库名/图片路径</code>加速访问我们的图片了</li></ul><p>配置好PicGo后，将图片拖拽到上传区，将会自动上传并复制访问链接，将链接粘贴到博文中就行了。</p><hr><p>暂且写到这里，就此收键。</p><p>To be continue…..</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> Markdown </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yilia主题</title>
      <link href="/2020/04/02/hexo-yilia-zhu-ti-you-hua/"/>
      <url>/2020/04/02/hexo-yilia-zhu-ti-you-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="yilia主题优化"><a href="#yilia主题优化" class="headerlink" title="yilia主题优化"></a>yilia主题优化</h1><h4 id="查看所有文章缺失模块"><a href="#查看所有文章缺失模块" class="headerlink" title="查看所有文章缺失模块"></a>查看所有文章缺失模块</h4><ul><li>在首次使用<code>yilia</code>时，点击所有文章时会出现模块找不到的错误，根据提示复制操作<a id="more"></a></li></ul><ul><li><code>_config.yml</code>路径是指 根目录下的，而非 yilia 主题下</li></ul><hr><h4 id="配置图片资源"><a href="#配置图片资源" class="headerlink" title="配置图片资源"></a>配置图片资源</h4><ul><li>路径 <code>blog/source/</code>下，添加 <code>assets</code> 文件夹，里面存放图片</li><li>配置文件引用。路径 <code>themes/yilia/_config.yml</code> 修改配置文件中图片地址</li></ul><pre><code>#你的头像urlavatar: /assets/img/头像.jpgfavicon: /assets/img/favicon.ico</code></pre><hr><h4 id="文章只显示摘要"><a href="#文章只显示摘要" class="headerlink" title="文章只显示摘要"></a>文章只显示摘要</h4><ul><li>点击主页时，发现所有文章都是全文显示，不利于查找，可控制显示的字数</li><li>在你 MD 格式文章正文插入 <code>&lt;!-- more --&gt;</code>即可，只会显示它之前的，此后的就不显示。</li><li>点击文章标题，全文阅读才可看到</li><li>同时在<code>themes/yilia/_config.yml</code>注释掉<code>excerpt_link: more</code></li></ul><hr><h4 id="主题作者名字更改"><a href="#主题作者名字更改" class="headerlink" title="主题作者名字更改"></a>主题作者名字更改</h4><ul><li>根目录下<code>_config.yml</code>更改author字段后的内容</li></ul><pre><code>author: (你的博客名)</code></pre><ul><li>更改完重新部署</li><li>删除博客底部 Hexo Theme Yilia by Litten</li><li>在<code>blog\themes\yilia\layout\_partial\footer.ejs</code>下修改：</li></ul><pre><code>&lt;div class="footer-right"&gt;    This is Asgrad&lt;/div&gt;</code></pre><hr><h4 id="文章显示目录"><a href="#文章显示目录" class="headerlink" title="文章显示目录"></a>文章显示目录</h4><ul><li>增加文章目录<code>TOC(table of content )</code>，方便阅读文章。</li><li>在<code>themes/yilia/_config.ym</code>中配置 <code>toc: 2</code>。</li></ul><hr><h4 id="增加归档菜单"><a href="#增加归档菜单" class="headerlink" title="增加归档菜单"></a>增加归档菜单</h4><ul><li>修改 themes/yilia/_config.yml</li></ul><pre><code>menu:    主页:  /    归档:  /archives/index.html</code></pre><hr><h4 id="增加不蒜子统计"><a href="#增加不蒜子统计" class="headerlink" title="增加不蒜子统计"></a>增加不蒜子统计</h4><ul><li>统计博客的访问量</li><li><strong>安装不蒜子脚本</strong></li><li>在<code>themes\yilia\layout\_partial\after-footer.ejs</code>最后添加</li></ul><pre><code>&lt;script  async  src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;</code></pre><ul><li><strong>添加统计网站访问量</strong></li><li>修改 <code>themes\yilia\layout\_partial\footer.ejs</code>，包括访客数和站点访问总量</li><li>注意修改文件后另存编码为UTF-8</li></ul><pre><code> # PV方式，单个用户连续点击 n 篇，记录 n 次记录值&lt;span id="busuanzi_container_site_pv"&gt;    本站总访问量&lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt;次&lt;/span&gt;# UV方式，单个用户连续点击 n 篇，记录 1 次记录值&lt;span id="busuanzi_container_site_uv"&gt;  本站访客数&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;人次&lt;/span&gt;</code></pre><hr><h4 id="添加评论系统Valine"><a href="#添加评论系统Valine" class="headerlink" title="添加评论系统Valine"></a>添加评论系统Valine</h4><ul><li>登录或注册 <strong>LeanCloud</strong>, 进入控制台后点击左下角创建应用，进入刚刚创建的应用，选择左下角的<kbd>设置</kbd>&gt;<kbd>应用Key</kbd>，然后就能看到你的<code>APP ID</code>和<code>APP Key</code>了。</li><li>在<code>themes\yilia\_config.yml</code>后面添加valine设置（把<code>APP ID</code>，<code>APP KEY</code>换成自己应用中的信息）</li></ul><pre><code> #6、Valine https://valine.js.orgvaline:  appid: 'APP ID' #Leancloud中自己的appId appkey: 'APP KEY' #Leancloud应用自己的appKey verify: false #验证码 notify: false #评论回复提醒 avatar:'' // (''/mp/identicon/monsterid/wavatar/robohash/retro/hide) placeholder: Just go go #评论框占位符</code></pre><ul><li>在<code>blog\themes\yilia\layout\_partial\article.ejs</code>中<code>&lt;% if (!index &amp;&amp; post.comments){ %&gt;</code>后添加代码</li></ul><pre><code>&lt;% if (theme.valine &amp;&amp; theme.valine.appid &amp;&amp; theme.valine.appkey){ %&gt;    &lt;section id="comments" class="comments"&gt;      &lt;style&gt;        .comments{margin:30px;padding:10px;background:#fff}        @media screen and (max-width:800px){.comments{margin:auto;padding:10px;background:#fff}}      &lt;/style&gt;      &lt;%- partial('post/valine', {        key: post.slug,        title: post.title,        url: config.url+url_for(post.path)        }) %&gt;  &lt;/section&gt;&lt;% } %&gt;</code></pre><ul><li><code>blog\themes\yilia\layout\_partial\post</code>下新建文件<code>valine.ejs</code>写入代码</li></ul><pre><code>&lt;div id="vcomment" class="comment"&gt;&lt;/div&gt; &lt;script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"&gt;&lt;/script&gt;&lt;script src="//unpkg.com/valine/dist/Valine.min.js"&gt;&lt;/script&gt;&lt;script&gt;   var notify = '&lt;%= theme.valine.notify %&gt;' == true ? true : false;   var verify = '&lt;%= theme.valine.verify %&gt;' == true ? true : false;    window.onload = function() {        new Valine({            el: '.comment',            notify: notify,            verify: verify,            app_id: "&lt;%= theme.valine.appid %&gt;",            app_key: "&lt;%= theme.valine.appkey %&gt;",            placeholder: "&lt;%= theme.valine.placeholder %&gt;",            avatar:"&lt;%= theme.valine.avatar %&gt;"        });    }&lt;/script&gt;</code></pre><hr><h4 id="头像旋转功能"><a href="#头像旋转功能" class="headerlink" title="头像旋转功能"></a>头像旋转功能</h4><ul><li>在<code>blog\themes\yilia\source</code>下新建<code>avatarrotation.css</code>：</li></ul><pre><code>.left-col #header .profilepic img {    /* 控制旋转速度时间*/  -webkit-transition: -webkit-transform 1.0s ease-out;  -moz-transition: -moz-transform 1.0s ease-out;  transition: transform 1.0s ease-out;}.left-col #header .profilepic img:hover {    /* 鼠标经过360% */  -webkit-transform: rotateZ(360deg);  -moz-transform: rotateZ(360deg);  transform: rotateZ(360deg);}</code></pre><ul><li>在<code>blog\themes\yilia\layout\_partia\head.ejs</code>文件中<code>&lt;%- partial('css') %&gt;</code>下方添加代码</li></ul><pre><code>&lt;%- partial('css') %&gt;  &lt;% if (theme.avatarrotation) { %&gt;    &lt;link rel = "stylesheet" type = "text/css" href = "/avatarrotation.css"&gt;  &lt;% } %&gt;</code></pre><ul><li>在yilia的_config.yml下：</li></ul><pre><code>头像是否旋转(如果不要旋转取false)avatarrotation: true</code></pre><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> yilia </tag>
            
            <tag> github </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown</title>
      <link href="/2020/04/02/markdown-xue-xi/"/>
      <url>/2020/04/02/markdown-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown学习"><a href="#Markdown学习" class="headerlink" title="Markdown学习"></a>Markdown学习</h1><h4 id="一-Markdown是什么"><a href="#一-Markdown是什么" class="headerlink" title="一. Markdown是什么"></a>一. Markdown是什么</h4><hr><ul><li>Markdown 是一种轻量级<strong>标记语言</strong>，它允许人们使用易读易写的纯文本格式编写文档。</li><li>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。</li><li>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</li><li>Markdown 编写的文档后缀为 <strong>.md, .markdown</strong>。</li></ul><hr><a id="more"></a><h4 id="二-使用Markdown的理由"><a href="#二-使用Markdown的理由" class="headerlink" title="二. 使用Markdown的理由"></a>二. 使用Markdown的理由</h4><ul><li>它是易读（看起来很舒服）、易写（语法简单）、易更改（纯文本）。处处体现着极简主义的影子。</li><li>兼容HTML,可以转换为HTML格式发布。</li><li>跨平台使用。</li><li>越来越多的网站支持Markdown。</li></ul><hr><h4 id="三-Markdown标题"><a href="#三-Markdown标题" class="headerlink" title="三. Markdown标题"></a>三. Markdown标题</h4><ul><li>使用 # 号标记</li></ul><ul><li>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。<pre><code># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre></li></ul><ul><li>效果如下<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6></li></ul><hr><h4 id="四-Markdown-段落"><a href="#四-Markdown-段落" class="headerlink" title="四. Markdown 段落"></a>四. Markdown 段落</h4><ul><li><p>Markdown 段落没有特殊的格式，直接编写文字就好。段落的换行是使用两个以上空格加上回车。</p></li><li><p><strong>字体</strong></p></li><li><p>Markdown 可以使用以下几种字体：</p></li></ul><pre><code>*斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___</code></pre><ul><li><strong>分隔线</strong></li><li>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</li></ul><pre><code>**** * ******- - -----------</code></pre><ul><li><p><strong>删除线</strong></p></li><li><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：</p><pre><code>RUNOOB.COMGOOGLE.COM~~BAIDU.COM~~</code></pre><p><del>baidu.com</del></p></li><li><p><strong>下划线</strong></p></li><li><p>下划线可以通过 HTML 的<code>&lt;u&gt;</code>标签来实现：</p><pre><code>&lt;u&gt;带下划线文本&lt;/u&gt;</code></pre><p><u>带下划线文本</u></p></li><li><p><strong>脚注</strong></p></li><li><p>脚注是对文本的补充说明。</p></li><li><p>Markdown 脚注的格式如下:</p><pre><code>[^要注明的文本]</code></pre></li><li><p>以下实例演示了脚注的用法：</p><pre><code>创建脚注格式类似这样 [^RUNOOB]。[^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！</code></pre></li></ul><hr><h4 id="五-Markdown-列表"><a href="#五-Markdown-列表" class="headerlink" title="五. Markdown 列表"></a>五. Markdown 列表</h4><ul><li>Markdown 支持有序列表和无序列表。</li><li>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记：</li></ul><pre><code>* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项</code></pre><ul><li>有序列表使用数字并加上 . 号来表示，如：</li></ul><pre><code>1. 第一项2. 第二项3. 第三项</code></pre><ul><li><strong>列表嵌套</strong><ul><li>列表嵌套只需在子列表中的选项添加四个空格即可：</li></ul></li></ul><pre><code>1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素</code></pre><hr><h4 id="六-Markdown-区块"><a href="#六-Markdown-区块" class="headerlink" title="六. Markdown 区块"></a>六. Markdown 区块</h4><ul><li>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号：</li><li>另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：  </li><li><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote></li></ul><hr><h4 id="七-Markdown-代码"><a href="#七-Markdown-代码" class="headerlink" title="七. Markdown 代码"></a>七. Markdown 代码</h4><ul><li>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如：<pre><code>`printf()` 函数也可以用 前后``` 包裹一段代码，并指定一种语言（也可以不指定）：</code></pre></li></ul><hr><h4 id="八-Markdown-链接"><a href="#八-Markdown-链接" class="headerlink" title="八. Markdown 链接"></a>八. Markdown 链接</h4><blockquote><p>链接使用方法如下：</p></blockquote><pre><code>[链接名称](链接地址)或者&lt;链接地址&gt;</code></pre><p>你有什么不懂的就找 <a href="https://www.baidu.com" target="_blank" rel="noopener">度娘</a></p><hr><h4 id="九-Markdown-图片"><a href="#九-Markdown-图片" class="headerlink" title="九. Markdown 图片"></a>九. Markdown 图片</h4><ul><li>Markdown 图片语法格式如下：</li></ul><pre><code>![alt 属性文本](图片地址)![alt 属性文本](图片地址 "可选标题")</code></pre><ul><li>开头一个感叹号 !</li><li>接着一个方括号，里面放上图片的替代文字</li><li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。<br><img src="http://piccn.ihuaben.com/pic/chapter/201912/0715/1575705212847-ZoV4Xu22qv_400-400.jpeg" alt="我不管，这就是兰兰！" title="这是兰兰"></li><li>Markdown 无法指定图片的高度与宽度，使用HTML标签<code>&lt;img&gt;</code></li></ul><img src="http://piccn.ihuaben.com/pic/chapter/201912/0715/1575705212847-ZoV4Xu22qv_400-400.jpeg" width="30%" title="这是缩水后的兰兰"><hr><h4 id="十-Markdown-表格"><a href="#十-Markdown-表格" class="headerlink" title="十. Markdown 表格"></a>十. Markdown 表格</h4><ul><li>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。</li><li>对齐方式 <ul><li>我们可以设置表格的对齐方式：</li><li>-: 设置内容和标题栏居右对齐。</li><li>:- 设置内容和标题栏居左对齐。</li><li>:-: 设置内容和标题栏居中对齐。</li></ul></li></ul><pre><code>| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 |</code></pre><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><hr><h4 id="十一-Markdown-高级技巧"><a href="#十一-Markdown-高级技巧" class="headerlink" title="十一. Markdown 高级技巧"></a>十一. Markdown 高级技巧</h4><ul><li><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p></li><li><p>目前支持的 HTML 元素有：<br><code>&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;</code>等</p></li><li><p>如：<br>使用 <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt;</code>重启电脑</p></li><li><p>输出结果为：<br><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> </p></li><li><p><strong>转义</strong></p></li><li><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：</p></li></ul><pre><code>\*\* 正常显示星号 \*\*</code></pre><p>** 正常显示星号 **</p><ul><li>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</li></ul><pre><code>\   反斜线`   反引号*   星号_   下划线{}  花括号[]  方括号()  小括号#   井字号+   加号-   减号.   英文句点!   感叹号</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
