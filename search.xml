<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java学习</title>
      <link href="/2020/04/10/java-xue-xi/"/>
      <url>/2020/04/10/java-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-简介和基础语法"><a href="#Java-简介和基础语法" class="headerlink" title="Java 简介和基础语法"></a>Java 简介和基础语法</h2><h3 id="Java主要特性"><a href="#Java主要特性" class="headerlink" title="Java主要特性"></a>Java主要特性</h3><ul><li><p><strong>Java语言是简单的</strong>：<br>Java语言的语法与C语言和C++语言很接近，使得大多数程序员很容易学习和使用。另一方面，Java丢弃了C++中很少使用的、很难理解的、令人迷惑的那些特性，如<strong>操作符重载、多继承、自动的强制类型转换</strong>。特别地，Java语言<strong>不使用指针，而是引用</strong>。并提供了自动的废料收集，使得程序员不必为内存管理而担忧。</p></li><li><p><strong>Java语言是面向对象的</strong>：<br>Java语言提供类、接口和继承等面向对象的特性，为了简单起见，只支持<strong>类之间的单继承</strong>，但支持<strong>接口之间的多继承</strong>，并支持类与接口之间的实现机制（关键字为implements）。Java语言全面支持动态绑定，而C++语言只对虚函数使用动态绑定。总之，Java语言是一个纯的面向对象程序设计语言。</p></li><li><p><strong>Java语言是分布式的</strong>：<br>Java语言支持Internet应用的开发，在基本的Java应用编程接口中有一个网络应用编程接口（java net），它提供了用于网络应用编程的类库，包括URL、URLConnection、Socket、ServerSocket等。Java的RMI（远程方法激活）机制也是开发分布式应用的重要手段。</p></li><li><p><strong>Java语言是健壮的</strong>：<br>Java的强类型机制、异常处理、垃圾的自动收集等是Java程序健壮性的重要保证。对指针的丢弃是Java的明智选择。Java的安全检查机制使得Java更具健壮性。</p></li><li><p><strong>Java语言是安全的</strong>：<br>Java通常被用在网络环境中，为此，Java提供了一个安全机制以防恶意代码的攻击。除了Java语言具有的许多安全特性以外，Java对通过网络下载的类具有一个安全防范机制（类ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查，并提供安全管理机制（类SecurityManager）让Java应用设置安全哨兵。</p></li><li><p><strong>Java语言是体系结构中立的</strong>：<br>Java程序（<strong>后缀为java的文件</strong>）在Java平台上被编译为体系结构中立的<strong>字节码格式（后缀为class的文件）</strong>，然后可以在实现这个Java平台的任何系统中运行。这种途径适合于异构的网络环境和软件的分发。</p></li><li><p><strong>Java语言是可移植的</strong>：<br>这种可移植性来源于体系结构中立性，另外，Java还严格规定了各个基本数据类型的长度。Java系统本身也具有很强的可移植性，Java编译器是用Java实现的，Java的运行环境是用ANSI C实现的。</p></li><li><p><strong>Java语言是解释型的</strong>：<br>如前所述，Java程序在Java平台上被编译为字节码格式，然后可以在实现这个Java平台的任何系统中运行。在运行时，Java平台中的<strong>Java解释器对这些字节码进行解释执行</strong>，执行过程中需要的类在联接阶段被载入到运行环境中。</p></li><li><p><strong>Java是高性能的</strong>：<br>与那些解释型的高级脚本语言相比，Java的确是高性能的。事实上，Java的运行速度随着JIT(Just-In-Time）编译器技术的发展越来越接近于C++。</p></li><li><p><strong>Java语言是多线程的</strong>：<br>在Java语言中，线程是一种特殊的对象，它必须由Thread类或其子（孙）类来创建。通常有两种方法来创建线程：其一，使用型构为Thread(Runnable)的构造子类将一个实现了Runnable接口的对象包装成一个线程，其二，从Thread类派生出子类并重写run方法，使用该子类创建的对象即为线程。值得注意的是Thread类已经实现了Runnable接口，因此，任何一个线程均有它的run方法，而run方法中包含了线程所要运行的代码。线程的活动由一组方法来控制。Java语言支持多个线程的同时执行，并提供多线程之间的同步机制（关键字为synchronized）。</p></li><li><p><strong>Java语言是动态的</strong>：<br>Java语言的设计目标之一是适应于动态变化的环境。Java程序需要的类能够动态地被载入到运行环境，也可以通过网络来载入所需要的类。这也有利于软件的升级。另外，Java中的类有一个运行时刻的表示，能进行运行时刻的类型检查。</p></li></ul><h3 id="Java开发工具"><a href="#Java开发工具" class="headerlink" title="Java开发工具"></a>Java开发工具</h3><ul><li>Linux 系统、Mac OS 系统、Windows 95/98/2000/XP，WIN 7/8系统。</li><li>Java JDK 7、8……（<strong>JDK是 Java 语言的软件开发工具包，主要用于移动设备、嵌入式设备上的java应用程序。JDK是整个java开发的核心，它包含了JAVA的运行环境（JVM+Java系统类库）和JAVA工具。</strong>）</li><li>JVM是<strong>Java Virtual Machine（Java虚拟机）</strong>的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。<br>引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</li><li>Notepad 编辑器或者其他编辑器。</li><li>IDE：Eclipse（<strong>集成开发环境（IDE，Integrated Development Environment ）是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。集成了代码编写功能、分析功能、编译功能、调试功能等一体化的开发软件服务套。所有具备这一特性的软件或者软件套（组）都可以叫集成开发环境。</strong> ）</li></ul><h3 id="使用Netbeans运行第一个-Java-程序"><a href="#使用Netbeans运行第一个-Java-程序" class="headerlink" title="使用Netbeans运行第一个 Java 程序"></a>使用Netbeans运行第一个 Java 程序</h3><p>HelloWorld.java 文件代码：</p><pre><code>public class HelloWorld {    /* 第一个Java程序     * 它将打印字符串 Hello World     */    public static void main(String []args) {        System.out.println("Hello World"); // 打印 Hello World    }}</code></pre><p><strong>注意</strong>：String args[] 与 String[] args 都可以执行，但推荐使用 <strong>String[] args</strong>，这样可以避免歧义和误读。</p><h3 id="Java-基础语法"><a href="#Java-基础语法" class="headerlink" title="Java 基础语法"></a>Java 基础语法</h3><p>一个 Java 程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作。下面简要介绍下类、对象、方法和实例变量的概念。</p><ul><li><strong>对象</strong>：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</li><li><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态。</li><li><strong>方法</strong>：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。</li><li><strong>实例变量</strong>：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。</li></ul><p>编写 Java 程序时，应注意以下几点：</p><ul><li><strong>大小写敏感</strong>：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。</li><li><strong>包名</strong>：多单词组成时所有字母都小写：xxxyyyzzz</li><li><strong>类名，接口名</strong>：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。(<strong>大驼峰</strong>)</li><li><strong>变量名、方法名</strong>：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。xxxYyyZzz。（<strong>小驼峰</strong>）</li><li><strong>源文件名</strong>：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 .java。（如果文件名和类名不相同则会导致编译错误）。</li><li><strong>常量名</strong>：所有字母大写，多单词时每个单词用下划线连接：XXX_YYY_ZZZ</li><li><strong>主方法入口</strong>：所有的 Java 程序由 public static void main(String []args) 方法开始执行。</li></ul><h3 id="Java-标识符"><a href="#Java-标识符" class="headerlink" title="Java 标识符"></a>Java 标识符</h3><p>Java 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。</p><p>关于 Java 标识符的命名规则，不遵守编译不通过：</p><ul><li>所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始</li><li>首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合</li><li>关键字不能用作标识符</li><li>标识符是大小写敏感的</li><li>合法标识符举例：age、$salary、_value、__1_value</li><li>非法标识符举例：123abc、-salary</li></ul><h3 id="Java-修饰符"><a href="#Java-修饰符" class="headerlink" title="Java 修饰符"></a>Java 修饰符</h3><p>像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：</p><p><strong>访问控制修饰符</strong> : default, public , protected, private</p><p><strong>非访问控制修饰符</strong> : final, abstract, static, synchronized </p><h3 id="Java-变量"><a href="#Java-变量" class="headerlink" title="Java 变量"></a>Java 变量</h3><p>Java 中主要有如下几种类型的变量</p><ul><li>局部变量</li><li>类变量（静态变量）</li><li>成员变量（非静态变量）</li></ul><h3 id="Java-数组"><a href="#Java-数组" class="headerlink" title="Java 数组"></a>Java 数组</h3><p>数组是储存在堆上的对象，可以保存多个同类型变量。</p><h3 id="Java-枚举"><a href="#Java-枚举" class="headerlink" title="Java 枚举"></a>Java 枚举</h3><p>Java 5.0引入了枚举，枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的 bug。</p><p>例如，我们为果汁店设计一个程序，它将限制果汁为小杯、中杯、大杯。这就意味着它不允许顾客点除了这三种尺寸外的果汁。</p><pre><code>class FreshJuice {   enum FreshJuiceSize{ SMALL, MEDIUM , LARGE }   FreshJuiceSize size;}public class FreshJuiceTest {   public static void main(String []args){      FreshJuice juice = new FreshJuice();      juice.size = FreshJuice.FreshJuiceSize.MEDIUM  ;   }}</code></pre><p><strong>注意</strong>：枚举可以单独声明或者声明在类里面。方法、变量、构造函数也可以在枚举中定义。</p><p><a href="https://www.runoob.com/java/java-basic-syntax.html" target="_blank" rel="noopener">关键字具体参考</a></p><h3 id="Java注释"><a href="#Java注释" class="headerlink" title="Java注释"></a>Java注释</h3><p>类似于 C/C++、Java 也支持单行以及多行注释。注释中的字符将被 Java 编译器忽略。</p><pre><code>public class HelloWorld {   /* 这是第一个Java程序    *它将打印Hello World    * 这是一个多行注释的示例    */    public static void main(String []args){       // 这是单行注释的示例       /* 这个也是单行注释的示例 */       System.out.println("Hello World");     }}</code></pre><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在 Java 中，一个类可以由其他类派生。如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以将新创建的类继承该类。<br>利用继承的方法，可以重用已存在类的方法和属性，而不用重写这些代码。被继承的类称为超类（super class），派生类称为子类（subclass）。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>在 Java 中，接口可理解为对象间相互通信的协议。接口在继承中扮演着很重要的角色。</p><p>接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类。</p><h3 id="Java-源程序与编译型运行区别"><a href="#Java-源程序与编译型运行区别" class="headerlink" title="Java 源程序与编译型运行区别"></a>Java 源程序与编译型运行区别</h3><p><img src="https://www.runoob.com/wp-content/uploads/2013/12/ZSSDMld.png" alt=""></p><h3 id="Java-对象和类"><a href="#Java-对象和类" class="headerlink" title="Java 对象和类"></a>Java 对象和类</h3><p>Java作为一种面向对象语言。支持以下基本概念：</p><ul><li>多态</li><li>继承</li><li>封装</li><li>抽象</li><li>类</li><li>对象</li><li>实例</li><li>方法</li><li>重载</li></ul><p>对象和类的概念</p><ul><li>对象：对象是类的一个实例（对象不是找个女朋友），有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</li><li>类：类是一个模板，它描述一类对象的行为和状态。</li></ul><h3 id="Java中的对象"><a href="#Java中的对象" class="headerlink" title="Java中的对象"></a>Java中的对象</h3><p>现在让我们深入了解什么是对象。看看周围真实的世界，会发现身边有很多对象，车，狗，人等等。所有这些对象都有自己的状态和行为。<br>拿一条狗来举例，它的状态有：名字、品种、颜色，行为有：叫、摇尾巴和跑。<br>对比现实对象和软件对象，它们之间十分相似。<br>软件对象也有状态和行为。软件对象的状态就是属性，行为通过方法体现。<br>在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。</p><h3 id="Java中的类"><a href="#Java中的类" class="headerlink" title="Java中的类"></a>Java中的类</h3><p>类可以看成是创建Java对象的模板。</p><p>通过下面一个简单的类来理解下Java中类的定义：</p><pre><code>public class Dog{  String breed; //品种  int age;      //年龄  String color; //颜色  void barking(){      //吠叫  }  void hungry(){      //饥饿  }  void sleeping(){      //睡觉  }}</code></pre><p>一个类可以包含以下类型变量：</p><ul><li><strong>局部变量</strong>：在<strong>方法、构造方法或者语句块</strong>中定义的变量被称为局部变量。<strong>变量声明和初始化</strong>都是在方法中，方法结束后，变量就会自动销毁。</li><li><strong>成员变量</strong>：成员变量是定义在<strong>类中，方法体之外</strong>的变量。这种变量在创建对象的时候实例化。成员变量可以被<strong>类中方法、构造方法和特定类的语句块访问</strong>。</li><li><strong>类变量</strong>：类变量也声明在<strong>类中，方法体之外</strong>，但<strong>必须声明</strong>为<strong>static</strong>类型。</li></ul><p><strong>一个类可以拥有多个方法</strong>，在上面的例子中：barking()、hungry()和sleeping()都是Dog类的方法。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个<strong>默认构造方法</strong>。</p><p>在创建一个对象的时候，至少要调用一个构造方法。构造方法的<strong>名称必须与类同名</strong>，一个类可以有多个构造方法。</p><p>下面是一个构造方法(构造器)示例：</p><pre><code>public class Puppy{    public Puppy(){    }    public Puppy(String name){        // 这个构造器仅有一个参数：name    }}</code></pre><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>对象是根据类创建的。在Java中，使用<strong>关键字new</strong>来创建一个新的对象。创建对象需要以下三步：</p><ul><li><strong>声明</strong>：声明一个对象，包括对象名称和对象类型。</li><li><strong>实例化</strong>：使用关键字new来创建一个对象。</li><li><strong>初始化</strong>：使用new创建对象时，会<strong>调用构造方法初始化</strong>对象。</li></ul><p>下面是一个创建对象的例子：</p><pre><code>public class Puppy{   public Puppy(String name){      //这个构造器仅有一个参数：name      System.out.println("小狗的名字是 : " + name );    }   public static void main(String[] args){      // 下面的语句将创建一个Puppy对象      Puppy myPuppy = new Puppy( "tommy" );   }}</code></pre><p>编译并运行上面的程序，会打印出下面的结果：<code>小狗的名字是 : tommy</code></p><h3 id="访问实例变量和方法"><a href="#访问实例变量和方法" class="headerlink" title="访问实例变量和方法"></a>访问实例变量和方法</h3><p>通过已创建的对象来访问成员变量和成员方法，如下所示：</p><pre><code>/* 实例化对象 */Object referenceVariable = new Constructor();/* 访问类中的变量 */referenceVariable.variableName;/* 访问类中的方法 */referenceVariable.methodName();</code></pre><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><pre><code>public class Puppy{   int puppyAge;   public Puppy(String name){      // 这个构造器仅有一个参数：name      System.out.println("小狗的名字是 : " + name );    }   public void setAge( int age ){       puppyAge = age;   }   public int getAge( ){       System.out.println("小狗的年龄为 : " + puppyAge );        return puppyAge;   }   public static void main(String[] args){      /* 创建对象 */      Puppy myPuppy = new Puppy( "tommy" );      /* 通过方法来设定age */      myPuppy.setAge( 2 );      /* 调用另一个方法获取age */      myPuppy.getAge( );      /*你也可以像下面这样访问成员变量 */      System.out.println("变量值 : " + myPuppy.puppyAge );    }}</code></pre><p>编译并运行上面的程序，产生如下结果： </p><pre><code>小狗的名字是 : tommy小狗的年龄为 : 2变量值 : 2</code></pre><h3 id="源文件声明规则"><a href="#源文件声明规则" class="headerlink" title="源文件声明规则"></a>源文件声明规则</h3><p>当在一个源文件中<strong>定义多个类</strong>，并且还有<strong>import语句和package语句</strong>时，要特别注意这些规则。</p><ul><li>一个源文件中只能有<strong>一个public类</strong></li><li>一个源文件可以有多个非public类</li><li><strong>源文件的名称</strong>应该和<strong>public类的类名保持一致</strong>。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java。</li><li>如果一个<strong>类定义在某个包</strong>中，那么package语句应该在<strong>源文件的首行</strong>。</li><li>如果源文件包含import语句，那么应该放在<strong>package语句和类定义之间</strong>。如果没有package语句，那么import语句应该在源文件中最前面。</li><li>import语句和package语句对源文件中定义的所有类都有效。在<strong>同一源文件中，不能给不同的类不同的包声明</strong>。</li></ul><p>类有若干种访问级别，并且类也分不同的类型：抽象类和final类等。这些将在访问控制章节介绍。<br>除了上面提到的几种类型，Java还有一些特殊的类，如：内部类、匿名类。</p><h3 id="Java-包"><a href="#Java-包" class="headerlink" title="Java 包"></a>Java 包</h3><p>包主要用来<strong>对类和接口进行分类</strong>。当开发Java程序时，可能编写成百上千的类，因此很有必要对类和接口进行分类。</p><h3 id="Import-语句"><a href="#Import-语句" class="headerlink" title="Import 语句"></a>Import 语句</h3><p>在Java中，如果给出一个完整的限定名，包括包名、类名，那么Java编译器就可以很容易地定位到源代码或者类。Import语句就是用来提供一个合理的路径，使得编译器可以找到某个类。</p><p>例如，下面的命令行将会命令编译器载入<strong>java_installation/java/io</strong>路径下的<strong>所有类</strong></p><pre><code>import java.io.*;</code></pre><h4 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h4><p>创建两个类：Employee 和 EmployeeTest。</p><p>Employee类有四个成员变量：<strong>name、age、designation和salary</strong>。该类显式声明了一个构造方法，该方法只有一个参数。</p><p>Employee.java 文件代码：</p><pre><code>import java.io.*;public class Employee{   String name;   int age;   String designation;   double salary;   // Employee 类的构造器   public Employee(String name){      this.name = name;   }   // 设置age的值   public void empAge(int empAge){      age =  empAge;   }   /* 设置designation的值*/   public void empDesignation(String empDesig){      designation = empDesig;   }   /* 设置salary的值*/   public void empSalary(double empSalary){      salary = empSalary;   }   /* 打印信息 */   public void printEmployee(){      System.out.println("名字:"+ name );      System.out.println("年龄:" + age );      System.out.println("职位:" + designation );      System.out.println("薪水:" + salary);   }}</code></pre><p><strong>程序都是从main方法开始执行</strong>。为了能<strong>运行这个程序</strong>，必须<strong>包含main方法</strong>并且<strong>创建一个实例对象</strong>。</p><p>下面给出EmployeeTest类，该类实例化<strong>2个 Employee 类的实例</strong>，并调用方法<strong>设置变量的值</strong>。</p><p>EmployeeTest.java文件代码：</p><pre><code>import java.io.*;public class EmployeeTest{   public static void main(String[] args){      /* 使用构造器创建两个对象 */      Employee empOne = new Employee("RUNOOB1");      Employee empTwo = new Employee("RUNOOB2");      // 调用这两个对象的成员方法      empOne.empAge(26);      empOne.empDesignation("高级程序员");      empOne.empSalary(1000);      empOne.printEmployee();      empTwo.empAge(21);      empTwo.empDesignation("菜鸟程序员");      empTwo.empSalary(500);      empTwo.printEmployee();   }}</code></pre><p>编译这两个文件并且运行 EmployeeTest 类，可以看到如下结果：</p><pre><code>名字:RUNOOB1年龄:26职位:高级程序员薪水:1000.0名字:RUNOOB2年龄:21职位:菜鸟程序员薪水:500.0</code></pre><h2 id="Java-基本数据类型"><a href="#Java-基本数据类型" class="headerlink" title="Java 基本数据类型"></a>Java 基本数据类型</h2><p>变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。</p><p>内存管理系统<strong>根据变量的类型</strong>为变量分配存储空间，分配的空间<strong>只能用来储存该类型数据</strong>。</p><p><img src="https://www.runoob.com/wp-content/uploads/2013/12/memorypic1.jpg" alt=""></p><p>因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。</p><p>Java 的两大数据类型:</p><ul><li><strong>内置</strong>数据类型</li><li><strong>引用</strong>数据类型</li></ul><h3 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a>内置数据类型</h3><p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。 </p><p><strong>四个整数型</strong>：</p><p><strong>byte</strong>：</p><ul><li>byte 数据类型是<strong>8位</strong>、有符号的，以<strong>二进制补码</strong>表示的整数；</li><li><strong>最小值</strong>是 <strong>-128（-2^7）</strong>；</li><li><strong>最大值</strong>是 <strong>127（2^7-1）</strong>；</li><li>默认值是 0；</li><li>byte 类型<strong>用在大型数组</strong>中节约空间，主要<strong>代替整数</strong>，因为 byte 变量占用的空间<strong>只有 int 类型的四分之一</strong>；</li><li>例子：byte a = 100，byte b = -50。</li></ul><p><strong>short</strong>：</p><ul><li>short 数据类型是 <strong>16 位</strong>、有符号的以二进制补码表示的整数</li><li>最小值是 -32768（-2^15）；</li><li>最大值是 32767（2^15 - 1）；</li><li>Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；</li><li>默认值是 0；</li><li>例子：short s = 1000，short r = -20000。</li></ul><p><strong>int</strong>：</p><ul><li>int 数据类型是<strong>32位</strong>、有符号的以二进制补码表示的整数；</li><li>最小值是 -2,147,483,648（-2^31）；</li><li>最大值是 2,147,483,647（2^31 - 1）；</li><li>一般地<strong>整型变量默认为 int 类型</strong>；</li><li>默认值是 0 ；</li><li>例子：int a = 100000, int b = -200000。</li></ul><p><strong>long</strong>：</p><ul><li>long 数据类型是 64 位、有符号的以二进制补码表示的整数；</li><li>最小值是 -9,223,372,036,854,775,808（-2^63）；</li><li>最大值是 9,223,372,036,854,775,807（2^63 -1）；</li><li>这种类型主要<strong>使用在需要比较大整数的系统</strong>上；</li><li>默认值是 <strong>0L</strong>；</li><li>例子： long a = 100000<strong>L</strong>，Long b = -200000<strong>L</strong>。</li><li>“L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以<strong>最好大写</strong>。 </li></ul><p><strong>两个浮点型</strong>：</p><p><strong>float</strong>：</p><ul><li>float 数据类型是<strong>单精度</strong>、<strong>32位</strong>、符合IEEE 754标准的浮点数；</li><li>float 在<strong>储存大型浮点数组</strong>的时候<strong>可节省内存</strong>空间；</li><li>默认值是 <strong>0.0f</strong>；</li><li>浮点数不能用来表示精确的值，如货币；</li><li>例子：float f1 = 234.5f。</li></ul><p><strong>double</strong>：</p><ul><li>double 数据类型是<strong>双精度</strong>、<strong>64 位</strong>、符合IEEE 754标准的浮点数；</li><li><strong>浮点数的默认类型</strong>为<strong>double</strong>类型；</li><li>double类型同样不能表示精确的值，如货币；</li><li>默认值是 <strong>0.0d</strong>；</li><li>例子：double d1 = 123.4。</li></ul><p><strong>布尔型</strong>：</p><p><strong>boolean</strong>：</p><ul><li>boolean数据类型表示一位的信息；</li><li><strong>只有两个取值</strong>：true 和 false；</li><li>这种类型只作为一种标志来记录 true/false 情况；</li><li>默认值是 false；</li><li>例子：boolean one = true。</li></ul><p><strong>字符型</strong>：</p><p><strong>char</strong>：</p><ul><li>char类型是一个<strong>单一的 16 位 Unicode 字符</strong>；</li><li>最小值是 \u0000（即为0）；</li><li>最大值是 \uffff（即为65,535）；</li><li>char 数据类型<strong>可以储存任何字符</strong>；</li><li>例子：char letter = ‘A’;。</li></ul><h4 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h4><p>对于数值类型的基本类型的<strong>取值范围，我们无需强制去记忆</strong>，因为它们的<strong>值都已经以常量的形式定义在对应的包装类</strong>中了。请看下面的例子：</p><pre><code>public class PrimitiveTypeTest {      public static void main(String[] args) {          // byte          System.out.println("基本类型：byte 二进制位数：" + Byte.SIZE);          System.out.println("包装类：java.lang.Byte");          System.out.println("最小值：Byte.MIN_VALUE=" + Byte.MIN_VALUE);          System.out.println("最大值：Byte.MAX_VALUE=" + Byte.MAX_VALUE);          System.out.println();          // short          System.out.println("基本类型：short 二进制位数：" + Short.SIZE);          System.out.println("包装类：java.lang.Short");          System.out.println("最小值：Short.MIN_VALUE=" + Short.MIN_VALUE);          System.out.println("最大值：Short.MAX_VALUE=" + Short.MAX_VALUE);          System.out.println();          // int          System.out.println("基本类型：int 二进制位数：" + Integer.SIZE);          System.out.println("包装类：java.lang.Integer");          System.out.println("最小值：Integer.MIN_VALUE=" + Integer.MIN_VALUE);          System.out.println("最大值：Integer.MAX_VALUE=" + Integer.MAX_VALUE);          System.out.println();          // long          System.out.println("基本类型：long 二进制位数：" + Long.SIZE);          System.out.println("包装类：java.lang.Long");          System.out.println("最小值：Long.MIN_VALUE=" + Long.MIN_VALUE);          System.out.println("最大值：Long.MAX_VALUE=" + Long.MAX_VALUE);          System.out.println();          // float          System.out.println("基本类型：float 二进制位数：" + Float.SIZE);          System.out.println("包装类：java.lang.Float");          System.out.println("最小值：Float.MIN_VALUE=" + Float.MIN_VALUE);          System.out.println("最大值：Float.MAX_VALUE=" + Float.MAX_VALUE);          System.out.println();          // double          System.out.println("基本类型：double 二进制位数：" + Double.SIZE);          System.out.println("包装类：java.lang.Double");          System.out.println("最小值：Double.MIN_VALUE=" + Double.MIN_VALUE);          System.out.println("最大值：Double.MAX_VALUE=" + Double.MAX_VALUE);          System.out.println();          // char          System.out.println("基本类型：char 二进制位数：" + Character.SIZE);          System.out.println("包装类：java.lang.Character");          // 以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台          System.out.println("最小值：Character.MIN_VALUE="                  + (int) Character.MIN_VALUE);          // 以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台          System.out.println("最大值：Character.MAX_VALUE="                  + (int) Character.MAX_VALUE);      }  }</code></pre><p>编译以上代码输出结果如下所示：</p><pre><code>基本类型：byte 二进制位数：8包装类：java.lang.Byte最小值：Byte.MIN_VALUE=-128最大值：Byte.MAX_VALUE=127基本类型：short 二进制位数：16包装类：java.lang.Short最小值：Short.MIN_VALUE=-32768最大值：Short.MAX_VALUE=32767基本类型：int 二进制位数：32包装类：java.lang.Integer最小值：Integer.MIN_VALUE=-2147483648最大值：Integer.MAX_VALUE=2147483647基本类型：long 二进制位数：64包装类：java.lang.Long最小值：Long.MIN_VALUE=-9223372036854775808最大值：Long.MAX_VALUE=9223372036854775807基本类型：float 二进制位数：32包装类：java.lang.Float最小值：Float.MIN_VALUE=1.4E-45最大值：Float.MAX_VALUE=3.4028235E38基本类型：double 二进制位数：64包装类：java.lang.Double最小值：Double.MIN_VALUE=4.9E-324最大值：Double.MAX_VALUE=1.7976931348623157E308基本类型：char 二进制位数：16包装类：java.lang.Character最小值：Character.MIN_VALUE=0最大值：Character.MAX_VALUE=65535</code></pre><p>Float和Double的最小值和最大值都是以科学记数法的形式输出的，结尾的<strong>“E+数字”表示E之前的数字要乘以10的多少次方</strong>。比如<strong>3.14E3就是3.14 × 103 =3140</strong>，<strong>3.14E-3 就是 3.14 x 10-3 =0.00314</strong>。</p><p>实际上，JAVA中还存在<strong>另外一种基本类型 void</strong>，它也有对应的包装类 <strong>java.lang.Void</strong>，不过我们<strong>无法直接对它们进行操作</strong>。</p><h3 id="类型默认值"><a href="#类型默认值" class="headerlink" title="类型默认值"></a>类型默认值</h3><p>下表列出了 Java 各个类型的默认值：</p><table><thead><tr><th align="left">数据类型</th><th align="right">默认值</th></tr></thead><tbody><tr><td align="left">byte</td><td align="right">0</td></tr><tr><td align="left">short</td><td align="right">0</td></tr><tr><td align="left">int</td><td align="right">0</td></tr><tr><td align="left">long</td><td align="right">0L</td></tr><tr><td align="left">float</td><td align="right">0.0f</td></tr><tr><td align="left">double</td><td align="right">0.0d</td></tr><tr><td align="left">char</td><td align="right">‘u0000’</td></tr><tr><td align="left">String (or any object)</td><td align="right">null</td></tr><tr><td align="left">boolean</td><td align="right">false</td></tr></tbody></table><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><pre><code>public class Test {    //类变量    static boolean bool;    static byte by;    static char ch;    static double d;    static float f;    static int i;    static long l;    static short sh;    static String str;    public static void main(String[] args) {        System.out.println("Bool :" + bool);        System.out.println("Byte :" + by);        System.out.println("Character:" + ch);        System.out.println("Double :" + d);        System.out.println("Float :" + f);        System.out.println("Integer :" + i);        System.out.println("Long :" + l);        System.out.println("Short :" + sh);        System.out.println("String :" + str);    }}</code></pre><p>实例输出结果为：</p><pre><code>Bool     :falseByte     :0Character:Double   :0.0Float    :0.0Integer  :0Long     :0Short    :0String   :null</code></pre><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><ul><li>在Java中，引用类型的变量非常<strong>类似于C/C++的指针</strong>。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。</li><li><strong>对象、数组都是引用数据类型。</strong></li><li>所有引用类型的<strong>默认值都是null</strong>。</li><li>一个引用变量可以用来引用任何与之兼容的类型。</li><li>例子：Site site = new Site(“Runoob”)。</li></ul><h3 id="Java-常量"><a href="#Java-常量" class="headerlink" title="Java 常量"></a>Java 常量</h3><p>常量在<strong>程序运行时是不能被修改</strong>的。</p><p>在 Java 中使用 <strong>final 关键字</strong>来<strong>修饰</strong>常量，声明方式和变量类似：</p><pre><code>final double PI = 3.1415927;</code></pre><p>虽然常量名也可以用小写，但为了便于识别，通常使用<strong>大写字母表示常量</strong>。 </p><p><strong>字面量</strong>可以赋给<strong>任何内置类型的变量</strong>。例如：</p><pre><code>byte a = 68;char a = 'A'</code></pre><p><strong>byte、int、long、和short</strong>都<strong>可以用十进制、16进制以及8进制</strong>的方式来表示。</p><p>当使用常量的时候，<strong>前缀 0 表示 8 进制</strong>，而<strong>前缀 0x 代表 16 进制</strong>, 例如：</p><pre><code>int decimal = 100;int octal = 0144;int hexa =  0x64;</code></pre><p>和其他语言一样，Java的<strong>字符串常量</strong>也是包含在两个引号之间的字符序列。下面是字符串型字面量的例子：</p><pre><code>"Hello World""two\nlines""\"This is in quotes\""</code></pre><p><strong>字符串常量和字符常量</strong>都<strong>可以包含任何Unicode字符</strong>。例如：</p><pre><code>char a = '\u0001';String a = "\u0001";</code></pre><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>整型、实型（常量）、字符型数据可以<strong>混合运算</strong>。运算中，不同类型的数据先转化为同一类型，然后进行运算。</p><p>转换从<strong>低级到高级</strong>。</p><pre><code>低  ------------------------------------&gt;  高byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double</code></pre><p>数据类型转换<strong>必须满足</strong>如下规则：</p><ul><li><p><strong>不能对boolean类型进行类型转换</strong>。</p></li><li><p><strong>不能把对象类型转换成不相关类的对象</strong>。</p></li><li><p><strong>在把容量大的类型转换为容量小的类型时必须使用强制类型转换</strong>。</p></li><li><p>转换过程中可能导致<strong>溢出或损失精度</strong>，例如：</p><pre><code>int i =128;   byte b = (byte)i;</code></pre><p>因为 <strong>byte 类型是 8 位，最大值为127</strong>。所以当<strong>int 强制转换为 byte</strong>类型时，<strong>值 128 时候就会导致溢出</strong>。</p></li><li><p><strong>浮点数到整数</strong>的转换是通过<strong>舍弃小数</strong>得到，而<strong>不是四舍五入</strong>，例如：</p><pre><code>(int)23.7 == 23;        (int)-45.89f == -45</code></pre></li></ul><h3 id="自动类型转换-1"><a href="#自动类型转换-1" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>必须满足<strong>转换前的数据类型的位数要低于转换后的数据类型(低转高)</strong>，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。 </p><pre><code>public class ZiDongLeiZhuan{        public static void main(String[] args){            char c1='a';//定义一个char类型            int i1 = c1;//char自动类型转换为int            System.out.println("char自动类型转换为int后的值等于"+i1);            char c2 = 'A';//定义一个char类型            int i2 = c2+1;//char 类型和 int 类型计算            System.out.println("char类型和int计算后的值等于"+i2);        }}</code></pre><p>运行结果为:</p><pre><code>char自动类型转换为int后的值等于97char类型和int计算后的值等于66</code></pre><p><strong>解析：c1 的值为字符 a ,查 ASCII 码表可知对应的 int 类型值为 97， A 对应值为 65，所以 i2=65+1=66。</strong></p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><ol><li>条件是转换的<strong>数据类型必须是兼容</strong>的。</li><li>格式：(type)value type是要强制类型转换后的数据类型 实例：<pre><code>public class QiangZhiZhuanHuan{ public static void main(String[] args){     int i1 = 123;     byte b = (byte)i1;//强制类型转换为byte     System.out.println("int强制类型转换为byte后的值等于"+b); }}</code></pre>运行结果：<pre><code>int强制类型转换为byte后的值等于123</code></pre></li></ol><h3 id="隐含强制类型转换"><a href="#隐含强制类型转换" class="headerlink" title="隐含强制类型转换"></a>隐含强制类型转换</h3><ol><li><strong>整数的默认类型是 int</strong>。</li><li><strong>浮点型不存在这种情况</strong>，因为在<strong>定义 float 类型时必须在数字后面跟上 F 或者 f</strong>。 </li></ol><h1 id="Java-变量类型"><a href="#Java-变量类型" class="headerlink" title="Java 变量类型"></a>Java 变量类型</h1><p>在Java语言中，所有的<strong>变量在使用前必须声明</strong>。声明变量的基本格式如下：</p><pre><code>type identifier [ = value][, identifier [= value] ...] ;  //[]表示可选</code></pre><p><strong>格式说明：type为Java数据类型。identifier是变量名。可以使用逗号隔开来声明多个同类型变量。</strong></p><p>以下列出了一些变量的声明实例。注意有些包含了初始化过程。</p><pre><code>int a, b, c;         // 声明三个int型整数：a、 b、cint d = 3, e = 4, f = 5; // 声明三个整数并赋予初值byte z = 22;         // 声明并初始化 zString s = "runoob";  // 声明并初始化字符串 sdouble pi = 3.14159; // 声明了双精度浮点型变量 pichar x = 'x';        // 声明变量 x 的值是字符 'x'。</code></pre><p>Java语言支持的变量类型有：</p><ul><li><strong>类变量</strong>：<strong>类中，独立于方法之外</strong>的变量，<strong>用 static 修饰</strong>。</li><li><strong>实例变量</strong>：<strong>类中，独立于方法之外</strong>的变量，不过<strong>没有 static 修饰</strong>。 </li><li><strong>局部变量</strong>：类的方法中的变量。</li></ul><pre><code>public class Variable{    static int allClicks=0;    // 类变量    String str="hello world";  // 实例变量    public void method(){        int i =0;  // 局部变量    }}</code></pre><h3 id="Java-局部变量"><a href="#Java-局部变量" class="headerlink" title="Java 局部变量"></a>Java 局部变量</h3><ul><li>局部变量声明在<strong>方法、构造方法或者语句块中</strong>；</li><li>局部变量在方法、构造方法、或者语句块<strong>被执行的时候创建</strong>，当它们<strong>执行完成后，变量将会被销毁</strong>；</li><li><strong>访问修饰符不能用于局部变量</strong>；</li><li>局部变量只在声明它的方法、构造方法或者语句块中可见；</li><li>局部变量是在<strong>栈上分配的</strong>。</li><li>局部变量<strong>没有默认值</strong>，所以局部变量<strong>被声明后，必须经过初始化，才可以使用</strong>。</li></ul><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例 1"></a>实例 1</h4><p>在以下实例中age是一个局部变量。定义在pupAge()方法中，它的作用域就限制在这个方法中。</p><pre><code>package com.runoob.test;public class Test{    public void pupAge(){      int age = 0;      age = age + 7;      System.out.println("小狗的年龄是: " + age);   }   public static void main(String[] args){      Test test = new Test();      test.pupAge();   }}</code></pre><p>以上实例编译运行结果如下:</p><pre><code>小狗的年龄是: 7</code></pre><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例 2"></a>实例 2</h4><p>在下面的例子中 age 变量没有初始化，所以在编译时会出错：</p><pre><code>package com.runoob.test;public class Test{    public void pupAge(){      int age;      age = age + 7;      System.out.println("小狗的年龄是 : " + age);   }   public static void main(String[] args){      Test test = new Test();      test.pupAge();   }}</code></pre><p>以上实例编译运行结果如下:</p><pre><code>Test.java:4:variable number might not have been initializedage = age + 7;         ^1 error</code></pre><h3 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h3><ul><li>实例变量<strong>声明在一个类中，但在方法、构造方法和语句块之外</strong>；</li><li>当一个对象被<strong>实例化之后，每个实例变量的值就跟着确定</strong>；</li><li>实例变量在<strong>对象创建的时候创建，在对象被销毁的时候销毁</strong>；</li><li>实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；</li><li>实例变量可以声明在使用前或者使用后；</li><li><strong>访问修饰符可以修饰实例变量</strong>；</li><li>实例变量<strong>对于类中的方法、构造方法或者语句块是可见的</strong>。一般情况下<strong>应该把实例变量设为私有</strong>。通过<strong>使用访问修饰符可以使实例变量对子类可见</strong>；</li><li><strong>实例变量具有默认值</strong>。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的<strong>值可以在声明时指定，也可以在构造方法中指定</strong>；</li><li>实例变量可以直接通过变量名访问。但在<strong>静态方法以及其他类中</strong>，就应该<strong>使用完全限定名：<code>ObejectReference.VariableName</code>。</strong></li></ul><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><p><strong>Employee.java 文件代码</strong>：</p><pre><code>import java.io.*;public class Employee{   // 这个实例变量对子类可见   public String name;   // 私有变量，仅在该类可见   private double salary;   //在构造器中对name赋值   public Employee (String empName){      name = empName;   }   //设定salary的值   public void setSalary(double empSal){      salary = empSal;   }     // 打印信息   public void printEmp(){      System.out.println("名字 : " + name );      System.out.println("薪水 : " + salary);   }   public static void main(String[] args){      Employee empOne = new Employee("RUNOOB");      empOne.setSalary(1000.0);      empOne.printEmp();   }}</code></pre><p>以上实例编译运行结果如下:</p><pre><code>名字 : RUNOOB薪水 : 1000.0</code></pre><h3 id="类变量（静态变量）"><a href="#类变量（静态变量）" class="headerlink" title="类变量（静态变量）"></a>类变量（静态变量）</h3><ul><li>类变量<strong>也称为静态变量</strong>，在类中<strong>以 static 关键字声明，但必须在方法之外</strong>。</li><li>无论一个类创建了多少个对象，<strong>类只拥有类变量的一份拷贝</strong>。</li><li><strong>静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变</strong>。</li><li><strong>静态变量储存在静态存储区。经常被声明为常量，很少<code>单独</code>使用static声明变量</strong>。</li><li>静态变量在<strong>第一次被访问时创建，在程序结束时销毁</strong>。</li><li>与实例变量具有相似的可见性。但<strong>为了对类的使用者可见，大多数静态变量声明为public类型</strong>。</li><li>默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</li><li><strong>静态变量可以通过：<code>ClassName.VariableName</code>的方式访问</strong>。</li><li>类变量<strong>被声明为public static final类型时</strong>，类变量<strong>名称一般建议使用大写字母</strong>。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。</li></ul><h4 id="实例：-1"><a href="#实例：-1" class="headerlink" title="实例："></a>实例：</h4><p>Employee.java 文件代码：</p><pre><code>import java.io.*;public class Employee {    //salary是静态的私有变量    private static double salary;    // DEPARTMENT是一个常量    public static final String DEPARTMENT = "开发人员";    public static void main(String[] args){    salary = 10000;        System.out.println(DEPARTMENT+"平均工资:"+salary);    }}</code></pre><p>以上实例编译运行结果如下:</p><pre><code>开发人员平均工资:10000.0</code></pre><p><strong>注意：如果<code>其他类</code>想要访问该变量，可以这样访问：Employee.DEPARTMENT。</strong></p><h2 id="Java-修饰符-1"><a href="#Java-修饰符-1" class="headerlink" title="Java 修饰符"></a>Java 修饰符</h2><p>Java语言提供了很多修饰符，主要分为以下两类：</p><ul><li><strong>访问</strong>修饰符</li><li><strong>非访问</strong>修饰符</li></ul><p>修饰符用来<strong>定义类、方法或者变量</strong>，通常<strong>放在语句的最前端</strong>。我们通过下面的例子来说明： </p><pre><code>public class ClassName {   private boolean myFlag;   static final double weeks = 9.5;   protected static final int BOXWIDTH = 42;   public static void main(String[] arguments) {      // 方法体   }}</code></pre><h3 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h3><p>Java中，可以<strong>使用访问控制符来保护对类、变量、方法和构造方法的访问</strong>。Java 支持<strong>4 种不同的访问权限</strong>。</p><ul><li><strong>default</strong> <strong>(即默认，什么也不写）: 在<code>同一包内</code>可见，不使用任何修饰符。</strong>使用对象：类、接口、变量、方法。</li><li><strong>private</strong> : <strong>在<code>同一类内</code>可见</strong>。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong></li><li><strong>public</strong> : <strong>对<code>所有类</code>可见</strong>。使用对象：类、接口、变量、方法</li><li><strong>protected</strong> : <strong>对<code>同一包内的类</code>和<code>所有子类</code>可见</strong>。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）。</strong></li></ul><h4 id="默认访问修饰符-不使用任何关键字"><a href="#默认访问修饰符-不使用任何关键字" class="headerlink" title="默认访问修饰符-不使用任何关键字"></a>默认访问修饰符-不使用任何关键字</h4><p>使用<strong>默认访问修饰符声明的变量和方法，对同一个包内的类是可见的</strong>。</p><p><strong>特殊：接口里的<code>变量都隐式声明为 public static final</code>,而接口里的<code>方法默认情况下访问权限为 public</code></strong>。 </p><p>如下例所示，<strong>变量和方法的声明可以不使用任何修饰符</strong>。 </p><pre><code>String version = "1.5.1";boolean processOrder() {   return true;}</code></pre><h4 id="私有访问修饰符-private"><a href="#私有访问修饰符-private" class="headerlink" title="私有访问修饰符-private"></a>私有访问修饰符-private</h4><p>私有访问修饰符是<strong>最严格的访问级别</strong>，所以被声明为 private 的方法、变量和构造方法<strong>只能被所属类访问</strong>，并且<strong>类和接口不能声明为 private</strong>。</p><p>声明为<strong>私有访问类型的变量只能通过类中<code>公共的 getter 方法</code>被外部类访问</strong>。</p><p>Private 访问修饰符的使用主要用来<strong>隐藏类的实现细节和保护类的数据</strong>。</p><p>下面的类使用了私有访问修饰符：</p><pre><code>public class Logger {   private String format;   public String getFormat() {      return this.format;   }   public void setFormat(String format) {      this.format = format;   }}</code></pre><p><strong>实例中，Logger 类中的 format 变量为<code>私有变量</code>，所以其他类不能直接得到和设置该变量的值。为了使其他类能够操作该变量，定义了两个 <code>public 方法</code>：getFormat() （返回 format的值）和 setFormat(String)（设置 format 的值）</strong></p><h4 id="公有访问修饰符-public"><a href="#公有访问修饰符-public" class="headerlink" title="公有访问修饰符-public"></a>公有访问修饰符-public</h4><p>被声明为 public 的类、方法、构造方法和接口<strong>能够被任何其他类访问</strong>。 </p><p><strong>如果几个相互访问的 public 类分布在不同的包中，则需要<code>导入</code>相应 public 类所在的包。</strong>由于类的继承性，<strong>类所有的<code>公有方法和变量</code>都能被其子类继承</strong>。 </p><p>以下函数使用了公有访问控制：</p><pre><code>public static void main(String[] arguments) {   // ...}</code></pre><p><strong>Java 程序的 <code>main() 方法必须设置成公有的</code>，否则，Java 解释器将不能运行该类</strong>。</p><h4 id="受保护的访问修饰符-protected"><a href="#受保护的访问修饰符-protected" class="headerlink" title="受保护的访问修饰符-protected"></a>受保护的访问修饰符-protected</h4><p>protected 需要从以下两个点来分析说明：</p><ul><li><strong>子类与基类在同一包中</strong>：被声明为 protected 的变量、方法和构造器<strong>能被同一个包中的任何其他类访问</strong>；</li><li><strong>子类与基类不在同一包中</strong>：那么在子类中，<strong>子类实例可以访问其<code>从基类继承</code>而来的 protected 方法，而不能访问<code>基类实例</code>的protected方法</strong>。</li></ul><p>protected 可以修饰数据成员，构造方法，方法成员，<strong>不能修饰类（内部类除外）</strong>。</p><p><strong><code>接口及接口的成员变量和成员方法</code>不能声明为 protected。</strong></p><p>子类能访问 protected 修饰符声明的方法和变量，这样就能<strong>防止不相关的类使用这些方法和变量</strong>。</p><p>下面的父类使用了 protected 访问修饰符，<strong>子类重写了父类的 openSpeaker() 方法</strong>。</p><pre><code>class AudioPlayer {   protected boolean openSpeaker(Speaker sp) {      // 实现细节   }}class StreamingAudioPlayer extends AudioPlayer {   protected boolean openSpeaker(Speaker sp) {      // 重写后的实现细节   }}</code></pre><p>如果把 openSpeaker() 方法声明为 private，那么除了 AudioPlayer 之外的类将不能访问该方法。</p><p>如果把 openSpeaker() 声明为 public，那么所有的类都能够访问该方法。</p><p>如果我们<strong>只想让该方法对其<code>所在类的子类可见</code>，则将该方法声明为 protected</strong>。</p><h4 id="访问控制和继承"><a href="#访问控制和继承" class="headerlink" title="访问控制和继承"></a>访问控制和继承</h4><p>请注意以下方法继承的规则： </p><ul><li><strong>父类中声明为 public 的<code>方法</code>在子类中也必须为 public</strong>。</li><li><strong>父类中声明为 protected 的<code>方法</code>在子类中要么声明为 protected，要么声明为 public，不能声明为 private</strong>。</li><li><strong>父类中声明为 private 的<code>方法</code>，不能够被继承</strong>。</li></ul><h3 id="非访问修饰符"><a href="#非访问修饰符" class="headerlink" title="非访问修饰符"></a>非访问修饰符</h3><p>为了实现一些其他的功能，Java 也提供了许多非访问修饰符。</p><p><strong>static</strong> 修饰符，用来修饰<strong><code>类方法</code>和<code>类变量</code></strong>。</p><p><strong>final</strong> 修饰符，用来修饰类、方法和变量，<strong>final 修饰的<code>类不能够被继承</code>，修饰的<code>方法不能被继承类重新定义</code>，修饰的<code>变量为常量</code>，是不可修改的</strong>。</p><p><strong>abstract</strong> 修饰符，用来创建<strong><code>抽象类</code>和<code>抽象方法</code></strong>。</p><p><strong>synchronized 和 volatile</strong> 修饰符，主要用于<strong><code>线程的编程</code></strong>。</p><h4 id="static-修饰符"><a href="#static-修饰符" class="headerlink" title="static 修饰符"></a>static 修饰符</h4><ul><li><p><strong>静态变量</strong>：<br>static 关键字用来<strong>声明<code>独立于对象</code>的静态变量，无论一个类实例化多少对象，它的静态变量只有<code>一份拷贝</code></strong>。 静态变量也被称为<strong><code>类变量</code>。<code>局部变量</code>不能被声明为 static 变量</strong>。 </p></li><li><p><strong>静态方法</strong>：<br>static 关键字用来<strong>声明<code>独立于对象</code>的静态方法。<code>静态方法</code>不能使用类的<code>非静态变量</code></strong>。静态方法从参数列表得到数据，然后计算这些数据。 </p><p><strong>对<code>类变量</code>和<code>方法</code>的访问可以直接使用 <code>classname.variablename</code> 和 <code>classname.methodname</code> 的方式访问</strong>。 </p><p>如下例所示，static修饰符用来创建类方法和类变量。</p><pre><code>public class InstanceCounter {  private static int numInstances = 0;  protected static int getCount() {     return numInstances;  }  private static void addInstance() {     numInstances++;  }  InstanceCounter() {     InstanceCounter.addInstance();  }  public static void main(String[] arguments) {     System.out.println("Starting with " +     InstanceCounter.getCount() + " instances");     for (int i = 0; i &lt; 500; ++i){        new InstanceCounter();         }     System.out.println("Created " +     InstanceCounter.getCount() + " instances");  }}</code></pre><p>以上实例运行编辑结果如下:</p><pre><code>Starting with 0 instancesCreated 500 instances</code></pre></li></ul><h4 id="final-修饰符"><a href="#final-修饰符" class="headerlink" title="final 修饰符"></a>final 修饰符</h4><p><strong>final 变量</strong>：  </p><p>final 表示<strong>“最后的、最终的”</strong>含义，<code>变量</code><strong>一旦赋值后，不能被重新赋值。被 final 修饰的<code>实例变量</code>必须<code>显式指定初始值</code></strong>。</p><p><strong><code>final</code>修饰符通常和<code>static</code>修饰符一起使用来创建<code>类常量</code></strong>。</p><p>实例</p><pre><code>public class Test{  final int value = 10;  // 下面是声明常量的实例  public static final int BOXWIDTH = 6;  static final String TITLE = "Manager";  public void changeValue(){     value = 12; //不能重新赋值，将输出一个错误  }}</code></pre><p><strong>final 方法</strong></p><p>父类中的 final 方法<strong>可以被子类继承，但是不能被子类重写</strong>。</p><p>声明 final 方法的<strong>主要目的是防止该方法的内容被修改</strong>。</p><p>如下所示，使用 final 修饰符声明方法。</p><pre><code>public class Test{    public final void changeName(){       // 方法体    }}</code></pre><p><strong>final 类</strong></p><p><strong>final 类<code>不能被继承</code>，没有类能够继承 final 类的任何特性</strong>。</p><p>实例</p><pre><code>public final class Test {   // 类体}</code></pre><h4 id="abstract-修饰符"><a href="#abstract-修饰符" class="headerlink" title="abstract 修饰符"></a>abstract 修饰符</h4><p><strong>抽象类：</strong></p><p>抽象类<strong>不能用来<code>实例化对象</code>，声明抽象类的<code>唯一目的</code>是为了将来<code>对该类进行扩充</code>。</strong></p><p><strong>一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类</strong>，否则将出现编译错误。 </p><p><strong>抽象类可以包含<code>抽象方法</code>和<code>非抽象方法</code>。</strong></p><p> 实例</p><pre><code> abstract class Caravan{    private double price;    private String model;    private String year;    public abstract void goFast(); //抽象方法    public abstract void changeColor(); //抽象方法 }</code></pre><p><strong>抽象方法</strong></p><p>抽象方法是<strong>一种没有任何实现的方法，该方法的的具体实现由子类提供</strong>。</p><p>抽象<strong>方法不能被声明成 final 和 static</strong>。 </p><p>任何继承抽象类的<strong>子类必须实现父类的<code>所有</code>抽象方法，除非该子类也是抽象类</strong>。 </p><p>如果一个类<strong>包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法</strong>。 </p><p>抽象<strong>方法的声明以分号结尾</strong>，例如：<strong><code>public abstract sample();</code></strong>。 </p><p>实例</p><pre><code>public abstract class SuperClass{    abstract void m(); //抽象方法}class SubClass extends SuperClass{     //实现抽象方法      void m(){          .........      }}</code></pre><h4 id="synchronized-修饰符"><a href="#synchronized-修饰符" class="headerlink" title="synchronized 修饰符"></a>synchronized 修饰符</h4><p>synchronized 关键字<strong>声明的<code>方法</code>同一时间<code>只能被一个线程</code>访问</strong>。</p><p>synchronized 修饰符<strong>可以应用于四个<code>访问修饰符</code></strong>。 </p><p>实例</p><pre><code>public synchronized void showDetails(){.......}</code></pre><h4 id="transient-修饰符"><a href="#transient-修饰符" class="headerlink" title="transient 修饰符"></a>transient 修饰符</h4><p>序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。 </p><p>该修饰符包含在定义变量的语句中，用来<strong>预处理类和变量的数据类型</strong>。 </p><p>实例</p><pre><code>public transient int limit = 55;   // 不会持久化public int b; // 持久化</code></pre><h4 id="volatile-修饰符"><a href="#volatile-修饰符" class="headerlink" title="volatile 修饰符"></a>volatile 修饰符</h4><p><strong>volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存</strong>。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</p><p>一个 volatile 对象引用可能是 null。 </p><p>实例</p><pre><code>public class MyRunnable implements Runnable{    private volatile boolean active;    public void run()    {        active = true;        while (active) // 第一行        {            // 代码        }    }    public void stop()    {        active = false; // 第二行    }}</code></pre><p><strong>通常情况下，在一个线程调用 run() 方法（在 Runnable 开启的线程），在另一个线程调用 stop() 方法。 如果 第一行 中缓冲区的 active 值被使用，那么在 第二行 的 active 值为 false 时循环不会停止。</strong></p><p>但是以上代码中我们<strong>使用了 volatile 修饰 active，所以该循环会停止</strong>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习 二</title>
      <link href="/2020/04/04/java-xue-xi-er/"/>
      <url>/2020/04/04/java-xue-xi-er/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-运算符"><a href="#Java-运算符" class="headerlink" title="Java 运算符"></a>Java 运算符</h2><p>计算机的最基本用途之一就是执行数学运算，作为一门计算机语言，Java也提供了一套丰富的运算符来操纵变量。我们可以把运算符分成以下几组：</p><ul><li>算术运算符</li><li>关系运算符</li><li>位运算符</li><li>逻辑运算符</li><li>赋值运算符</li><li>其他运算符</li></ul><p><strong>鉴于与其他编程语言用法类似，以下内容不再详细记载</strong></p><p><a href="https://www.runoob.com/java/java-operators.html" target="_blank" rel="noopener">运算符详细教程</a></p><h2 id="Java-循环结构-for-while-及-do…while"><a href="#Java-循环结构-for-while-及-do…while" class="headerlink" title="Java 循环结构 - for, while 及 do…while"></a>Java 循环结构 - for, while 及 do…while</h2><p>顺序结构的程序语句只能被执行一次。如果您想要同样的操作执行多次,，就需要使用循环结构。 </p><p>Java中有三种主要的循环结构：</p><ul><li>while 循环</li><li>do…while 循环</li><li>for 循环</li></ul><p>对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。</p><p>do…while 循环和 while 循环相似，不同的是，<strong>do…while 循环至少会执行一次</strong>。</p><p><strong>在Java5中引入了一种主要用于数组的增强型for循环。</strong></p><h3 id="Java-增强-for-循环"><a href="#Java-增强-for-循环" class="headerlink" title="Java 增强 for 循环"></a>Java 增强 for 循环</h3><p>Java 增强 for 循环语法格式如下:</p><pre><code>for(声明语句 : 表达式){   //代码句子}</code></pre><p><strong>声明语句</strong>：声明新的局部变量，<strong>该变量的类型必须和数组元素的类型匹配</strong>。其作用域限定在循环语句块，其值与此时数组元素的值相等。 </p><p><strong>表达式：表达式是要访问的<code>数组名</code>，或者是<code>返回值为数组</code>的<code>方法</code></strong>。</p><p>实例</p><pre><code>public class Test {   public static void main(String args[]){      int [] numbers = {10, 20, 30, 40, 50};      for(int x : numbers ){         System.out.print( x );         System.out.print(",");      }      System.out.print("\n");      String [] names ={"James", "Larry", "Tom", "Lacy"};      for( String name : names ) {         System.out.print( name );         System.out.print(",");      }   }}</code></pre><p>以上实例编译运行结果如下：</p><pre><code>10,20,30,40,50,James,Larry,Tom,Lacy,</code></pre><h3 id="break-关键字"><a href="#break-关键字" class="headerlink" title="break 关键字"></a>break 关键字</h3><p><strong>break 主要用在<code>循环语句</code>或者<code>switch 语句</code>中，用来跳出整个语句块。</strong></p><p><strong>break 跳出<code>最里层</code>的循环，并且继续执行该循环下面的语句。</strong></p><h3 id="continue-关键字"><a href="#continue-关键字" class="headerlink" title="continue 关键字"></a>continue 关键字</h3><p><strong>continue 适用于<code>任何循环控制结构</code>中。作用是让程序立刻跳转到下一次循环的迭代。</strong></p><p><strong>在 <code>for</code>循环中，continue 语句使程序立即跳转到<code>更新语句</code>。</strong></p><pre><code>for(初始化; 布尔表达式; 更新) {    //代码语句}</code></pre><p><strong>在 <code>while 或者 do…while</code>循环中，程序立即跳转到<code>布尔表达式</code>的判断语句。</strong> </p><h2 id="Java-条件语句-if…else"><a href="#Java-条件语句-if…else" class="headerlink" title="Java 条件语句 - if…else"></a>Java 条件语句 - if…else</h2><h3 id="if…else语句"><a href="#if…else语句" class="headerlink" title="if…else语句"></a>if…else语句</h3><p><strong>if 语句后面可以跟 else 语句</strong>，当 if 语句的布尔表达式值为 false 时，else 语句块会被执行。</p><pre><code>if(布尔表达式){   //如果布尔表达式的值为true}else{   //如果布尔表达式的值为false}</code></pre><h3 id="if…else-if…else-语句"><a href="#if…else-if…else-语句" class="headerlink" title="if…else if…else 语句"></a>if…else if…else 语句</h3><p>if 语句后面可以跟 else if…else 语句，<strong>这种语句可以检测到<code>多种可能的情况</code>。</strong></p><p>使用 if，else if，else 语句的时候，需要注意下面几点：</p><ul><li><strong>if 语句至多有<code>1 个</code>else 语句，else 语句在所有的 <code>else if</code>语句之后。</strong></li><li>if 语句可以有若干个 else if 语句，它们必须在 else 语句之前。</li><li><strong>一旦其中一个 else if 语句检测为 true，其他的 else if 以及 else 语句都将<code>跳过执行</code>。</strong></li></ul><h3 id="嵌套的-if…else-语句"><a href="#嵌套的-if…else-语句" class="headerlink" title="嵌套的 if…else 语句"></a>嵌套的 if…else 语句</h3><p>用嵌套的 if…else 语句是合法的。也就是说你<strong>可以在另一个 if 或者 else if 语句中使用 if 或者 else if 语句。</strong></p><h2 id="Java-switch-case-语句"><a href="#Java-switch-case-语句" class="headerlink" title="Java switch case 语句"></a>Java switch case 语句</h2><p>switch case 语句<strong>判断一个变量与一系列值中某个值是否相等，每个值称为一个分支</strong>。</p><pre><code>switch(expression){    case value :       //语句       break; //可选    case value :       //语句       break; //可选    //你可以有任意数量的case语句    default : //可选       //语句}</code></pre><p>switch case 语句有如下规则：</p><ul><li>switch 语句中的<strong>变量类型可以是： <code>byte、short、int 或者 char</code>。从 Java SE 7 开始，switch 支持<code>字符串 String 类型</code>了，同时 case 标签必须为<code>字符串常量</code>或<code>字面量</code>。</strong></li><li>switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。</li><li><strong>case 语句中的<code>值</code>的数据类型必须与<code>变量</code>的数据类型相同，而且<code>只能是常量或者字面常量</code>。</strong></li><li>当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，<strong>直到 break 语句出现才会跳出 switch 语句</strong>。</li><li>当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。<strong>case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句</strong>。</li><li>switch 语句可以包含一个 <strong>default 分支，该分支一般是 switch 语句的最后一个分支（可以在任何位置，但建议在最后一个）。default 在没有 case 语句的值和变量值相等的时候执行。default 分支<code>不需要 break 语句</code>。</strong></li></ul><p><strong>switch case 执行时，一定会先进行匹配，匹配成功返回当前 case 的值，再根据是否有 break，判断是否继续输出，或是跳出判断。</strong></p><h2 id="Java-Number-amp-Math-类"><a href="#Java-Number-amp-Math-类" class="headerlink" title="Java Number &amp; Math 类"></a>Java Number &amp; Math 类</h2><p><strong>一般地，当需要使用数字的时候，我们通常使用内置数据类型，如：byte、int、long、double 等。</strong></p><p>实例</p><pre><code>int a = 5000;float b = 13.65f;byte c = 0x4a;</code></pre><p>然而，在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情形。为了解决这个问题，<strong>Java 语言为每一个内置数据类型提供了对应的包装类</strong>。 </p><p>所有的包装类<code>（Integer、Long、Byte、Double、Float、Short）</code>都是<strong><code>抽象类 Number</code> 的子类</strong>。</p><p> <img src="https://www.runoob.com/wp-content/uploads/2013/12/number1.png" alt=""></p><p>这种由编译器特别支持的包装称为装箱，所以当<strong>内置数据类型被当作对象使用的时候，编译器会把内置类型<code>装箱</code>为包装类。</strong>相似的，<strong>编译器也可以把一个对象<code>拆箱</code>为内置类型</strong>。Number 类属于 java.lang 包。 </p><p>下面是一个使用 Integer 对象的实例：</p><pre><code>public class Test{   public static void main(String args[]){      Integer x = 5;      x =  x + 10;      System.out.println(x);    }}</code></pre><p>以上实例编译运行结果如下：</p><pre><code>15</code></pre><p><strong>当 x 被赋为整型值时，由于x是一个对象，所以编译器要对x进行<code>装箱</code>。然后，为了使x能进行加运算，所以要对x进行<code>拆箱</code>。</strong> </p><h3 id="Java-Math-类"><a href="#Java-Math-类" class="headerlink" title="Java Math 类"></a>Java Math 类</h3><p><strong>Java 的 Math 包含了用于执行基本数学运算的<code>属性</code>和<code>方法</code></strong>，如初等指数、对数、平方根和三角函数。</p><p><strong>Math 的方法都被定义为 <code>static</code>形式，通过 Math 类可以在<code>主函数</code>中直接调用。</strong></p><pre><code>public class Test {      public static void main (String []args)      {          System.out.println("90 度的正弦值：" + Math.sin(Math.PI/2));          System.out.println("0度的余弦值：" + Math.cos(0));          System.out.println("60度的正切值：" + Math.tan(Math.PI/3));          System.out.println("1的反正切值： " + Math.atan(1));          System.out.println("π/2的角度值：" + Math.toDegrees(Math.PI/2));          System.out.println(Math.PI);      }  }</code></pre><h3 id="Number-amp-Math-类方法"><a href="#Number-amp-Math-类方法" class="headerlink" title="Number &amp; Math 类方法"></a>Number &amp; Math 类方法</h3><p><a href="https://www.runoob.com/java/java-number.html" target="_blank" rel="noopener">常用方法请参考</a></p><h3 id="Math-的-floor-round-和-ceil-方法实例比较"><a href="#Math-的-floor-round-和-ceil-方法实例比较" class="headerlink" title="Math 的 floor,round 和 ceil 方法实例比较"></a>Math 的 floor,round 和 ceil 方法实例比较</h3><ul><li>Math.floor（地板）</li><li>Math.round（四舍五入）</li><li>Math.ceil（天花板）</li></ul><h2 id="Java-Character-类"><a href="#Java-Character-类" class="headerlink" title="Java Character 类"></a>Java Character 类</h2><p><strong><code>Character 类</code>用于对<code>单个字符</code>进行操作。</strong></p><p><strong><code>Character 类</code>在<code>对象</code>中包装一个基本类型 <code>char</code> 的值</strong></p><pre><code>char ch = 'a';// Unicode 字符表示形式char uniChar = '\u039A'; // 字符数组char[] charArray ={ 'a', 'b', 'c', 'd', 'e' };</code></pre><p>然而，在实际开发过程中，我们经常会遇到<strong>需要使用对象，而不是内置数据类型的情况</strong>。为了解决这个问题，Java语言为内置数据类型char提供了包装类Character类。 </p><p>Character类提供了一系列方法来操纵字符。你可以<strong>使用Character的构造方法创建一个Character类对象</strong>，例如： </p><pre><code>Character ch = new Character('a');</code></pre><p>在某些情况下，Java编译器会自动创建一个Character对象。</p><p>例如，<strong>将一个<code>char</code>类型的参数传递给需要一个<code>Character</code>类型参数的方法时，那么<code>编译器</code>会自动地将<code>char</code>类型参数转换为<code>Character</code>对象。 这种特征称为<code>装箱</code>，反过来称为<code>拆箱</code>。</strong> </p><p>实例</p><pre><code>// 原始字符 'a' 装箱到 Character 对象 ch 中Character ch = 'a';// 原始字符 'x' 用 test 方法装箱// 再返回拆箱的值到 'c'char c = test('x');</code></pre><h3 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h3><p><a href="https://www.runoob.com/java/java-character.html" target="_blank" rel="noopener">转义序列请参考</a></p><p><strong>当打印语句遇到一个转义序列时，编译器可以正确地对其进行解释。</strong></p><p>以下实例转义双引号并输出：</p><pre><code>public class Test {   public static void main(String args[]) {      System.out.println("访问\"菜鸟教程!\"");   }}</code></pre><p>以上实例编译运行结果如下： </p><pre><code>访问"菜鸟教程!"</code></pre><h3 id="Character-方法"><a href="#Character-方法" class="headerlink" title="Character 方法"></a>Character 方法</h3><p><a href="https://www.runoob.com/java/java-character.html" target="_blank" rel="noopener">Character类的方法请参考</a></p><h2 id="Java-String-类"><a href="#Java-String-类" class="headerlink" title="Java String 类"></a>Java String 类</h2><p>字符串广泛应用 在 Java 编程中，在 Java 中<strong>字符串属于对象</strong>，Java 提供了 <strong>String 类来创建和操作字符串</strong>。 </p><h3 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a>创建字符串</h3><p>创建字符串最简单的方式如下:</p><pre><code>String greeting = "菜鸟教程";</code></pre><p>在代码中遇到字符串常量时，这里的值是 “菜鸟教程””，编译器会使用该值创建一个 String 对象。</p><p>和其它对象一样，<strong>可以使用<code>关键字</code>和<code>构造方法</code>来创建 String 对象。</strong></p><p>String 类有<strong><code>11 种构造方法</code>，这些方法提供不同的参数来初始化字符串</strong>，比如提供一个字符数组参数:</p><pre><code>//StringDemo 字符串示范public class StringDemo{   public static void main(String args[]){      char[] helloArray = { 'r', 'u', 'n', 'o', 'o', 'b'};      String helloString = new String(helloArray);        System.out.println( helloString );   }}</code></pre><p>以上实例编译运行结果如下：</p><pre><code>runoob</code></pre><p><strong>注意:String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了</strong></p><p><strong>String 类是不可改变的解析</strong>，例如：</p><pre><code>String s = "Google";System.out.println("s = " + s);s = "Runoob";System.out.println("s = " + s);</code></pre><p>输出结果为：</p><pre><code>GoogleRunoob</code></pre><p>从结果上看是改变了，但为什么说String对象是不可变的呢？</p><p><strong>原因在于实例中的 s 只是一个 String 对象的引用，并不是对象本身，当执行 s = “Runoob”; 创建了一个新的对象 “Runoob”，而原来的 “Google” 还存在于内存中。</strong></p><p><img src="https://www.runoob.com/wp-content/uploads/2013/12/string-no-modify.png" alt=""></p><p>还可以根据 jdk 的源码来分析。</p><p><strong>字符串实际上就是一个 <code>char 数组</code>，并且内部就是<code>封装</code>了一个 char 数组</strong>。</p><p><strong>并且这里 char 数组是被 <code>final</code> 修饰的</strong>:</p><pre><code>public final class String    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {    /** The value is used for character storage. */    private final char value[];</code></pre><p><strong>并且 String 中的所有的方法，都是对于 <code>char 数组的改变</code>，只要是对它的改变，方法内部都是<code>返回一个新的 String 实例</code>。</strong></p><p>如果<strong>需要对字符串做很多修改，那么应该选择使用 <a href="https://www.runoob.com/java/java-stringbuffer.html" target="_blank" rel="noopener"> StringBuffer &amp; StringBuilder </a> 类。</strong> </p><h3 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h3><p><strong>用于<code>获取有关对象的信息的方法</code>称为<code>访问器方法</code>。</strong></p><p><strong>String 类的一个<code>访问器方法</code>是 <code>length() 方法</code>，它返回字符串对象包含的<code>字符数</code>。</strong></p><p>下面的代码执行后，len 变量等于 14:</p><pre><code>public class StringDemo {    public static void main(String args[]) {        String site = "www.runoob.com";        int len = site.length();        System.out.println( "菜鸟教程网址长度 : " + len );   }}</code></pre><p>以上实例编译运行结果如下：</p><pre><code>菜鸟教程网址长度 : 14</code></pre><h4 id="length-方法，length-属性和-size-方法的区别"><a href="#length-方法，length-属性和-size-方法的区别" class="headerlink" title="length() 方法，length 属性和 size() 方法的区别:"></a>length() 方法，length 属性和 size() 方法的区别:</h4><ul><li><strong><code>length() 方法</code>是针对<code>字符串</code>来说的，要<code>求一个字符串的长度</code>就要用到它的<code>length()方法</code>；</strong> </li><li><strong><code>length 属性</code>是针对 Java 中的<code>数组</code>来说的，要求<code>数组的长度</code>可以用其 <code>length 属性</code>；</strong> </li><li><strong>Java 中的 <code>size() 方法</code>是针对<code>泛型集合</code>说的, 如果想看这个<code>泛型有多少个元素</code>, 就调用此方法来查看!</strong><br><a href="https://www.runoob.com/java/java-generics.html" target="_blank" rel="noopener">泛型具体教程</a> </li></ul><p>演示这两个方法和一个属性的用法：</p><pre><code>import java.util.ArrayList;import java.util.List;public class Main {    public static void main(String[] args) {        String array[] = { "First", "Second", "Third" };        String a = "HelloWorld";        List&lt;String&gt; list = new ArrayList&lt;String&gt;();        list.add(a);        System.out.println("数组array的长度为" + array.length);        System.out.println("字符串a的长度为" + a.length());        System.out.println("list中元素个数为" + list.size());    }}</code></pre><p>输出的值为: </p><pre><code>数组array的长度为3字符串a的长度为10list中元素个数为1</code></pre><h3 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h3><p>String 类提供了连接两个字符串的方法：</p><pre><code>// 返回 string2 连接 string1 的新字符串string1.concat(string2);// 也可以对字符串常量使用 concat() 方法"我的名字是 ".concat("Runoob");// 更常用的是使用'+'操作符来连接字符串String string1 = "菜鸟教程网址：";     System.out.println("1、" + string1 + "www.runoob.com");  </code></pre><p>以上实例编译运行结果如下：</p><pre><code>1、菜鸟教程网址：www.runoob.com</code></pre><p>对于<strong>字符串的<code>加运算</code>，当编译成 class 文件时，会<code>自动编译</code>为 <code>StringBuffer</code> 来进行字符串的连接操作。</strong></p><p>如下列代码：</p><pre><code>String a = "a";String b = "b";String c = a + b;</code></pre><p>相当于：</p><pre><code>String c = new StringBuffer().append(a).append(b).toString();</code></pre><p>同时对于字符串常量池：</p><p><strong>当一个字符串是一个<code>字面量</code>时，它会被放到一个<code>常量池</code>中，等待<code>复用</code>。</strong></p><pre><code>String a = "saff";                 // 常量池String b = "saff";                 // 缓冲池String c = new String("saff");    // 堆内存中System.out.println(a.equal(b));  // trueSystem.out.println(a.equal(c));  // trueSystem.out.println(a == b);  // trueSystem.out.println(a == c);  // false两个对象的地址值不一样。</code></pre><p><strong>“==””这里的比较是针对两个String类型的<code>变量的引用</code>，也就是说如果两个String类型的变量，他们所引用的是同一个string对象（<code>指向同一个内存堆</code>），即返回true。</strong> </p><p><strong>String对象继承自Object，并且对equals方法进行了重写，用此方法进行比较时，其实是对String对象封装的<code>字符串内容</code>进行比较，相同返回true。</strong></p><p><strong>再来看<code>b</code>这个字符串对象并不是通过<code>new</code>来创建的，所以虚拟机并不会为它分配内存堆，而是先到String<code>缓冲池</code>中寻找是否存在与“saff”相同值的String对象存在，如果有，直接将该对象的引用赋值给str，若没有，则<code>虚拟机</code>会在<code>缓冲池</code>内创建此对象，其动作就是<code>new String(“saff”);</code>,然后把此String对象的引用赋值给b。</strong></p><p><strong>众所周知，通过 <code>new 关键字</code>来生成对象是在<code>堆区</code>进行的，而在堆区进行对象生成的过程是<code>不会去检测该对象是否已经存在</code>的。因此通过 new 来创建对象，创建出的<code>一定是不同的对象</code>，即使字符串的<code>内容是相同</code>的。</strong></p><p><strong>面试题1:</strong></p><pre><code>String s1="a"+"b"+"c";String s2="abc";System.out.println(s1==s2);System.out.println(s1.equals(s2));</code></pre><p><strong>java 中常量优化机制，<code>编译时</code> s1 已经成为 abc 在<code>常量池</code>中查找创建，s2 不需要再创建。</strong> </p><p><strong>面试题2:</strong></p><pre><code>String s1="ab";String s2="abc";String s3=s1+"c";System.out.println(s3==s2);         // falseSystem.out.println(s3.equals(s2));  // true</code></pre><p><strong>先在<code>常量池</code>中创建 ab ，地址指向 s1, 再创建 abc ，指向 s2。对于 s3，先创建<code>StringBuilder（或 StringBuffer）对象</code>，通过 append 连接得到 abc ,再调用 <code>toString()</code> 转换得到的地址指向 s3。故 (s3==s2) 为 false。</strong></p><h3 id="创建格式化字符串"><a href="#创建格式化字符串" class="headerlink" title="创建格式化字符串"></a>创建格式化字符串</h3><p>我们知道输出格式化数字可以使用 printf() 和 format() 方法。</p><p><strong>String 类使用静态方法 <code>format()</code> 返回一个<code>String 对象</code>而<code>不是 PrintStream 对象</code>。</strong></p><p><strong>String 类的静态方法 format() 能用来<code>创建可复用的格式化字符串</code>，而不仅仅是用于一次打印输出。</strong></p><pre><code>String fs;fs = String.format("浮点型变量的值为 " +                   "%f, 整型变量的值为 " +                   " %d, 字符串变量的值为 " +                   " %s", floatVar, intVar, stringVar);</code></pre><h3 id="String-方法"><a href="#String-方法" class="headerlink" title="String 方法"></a>String 方法</h3><p>请参考：<a href="https://www.runoob.com/java/java-string.html" target="_blank" rel="noopener">String支持的方法</a></p><h2 id="Java-StringBuffer-和-StringBuilder-类"><a href="#Java-StringBuffer-和-StringBuilder-类" class="headerlink" title="Java StringBuffer 和 StringBuilder 类"></a>Java StringBuffer 和 StringBuilder 类</h2><p><strong>当对字符串进行修改的时候，需要使用 <code>StringBuffer</code> 和 <code>StringBuilder</code> 类。</strong> </p><p><strong>和 String 类不同的是，<code>StringBuffer</code> 和 <code>StringBuilder</code> 类的对象<code>能够被多次的修改</code>，并且<code>不产生新的未使用对象</code>。</strong> </p><p>StringBuilder 类在 Java 5 中被提出，<strong>它和 StringBuffer 之间的最大不同在于 <code>StringBuilder 的方法不是线程安全的</code>（不能同步访问）。</strong> </p><p><strong>由于 <code>StringBuilder</code> 相较于 <code>StringBuffer</code> 有<code>速度优势</code>，所以多数情况下建议使用 <code>StringBuilder</code> 类。然而在应用程序要求<code>线程安全</code>的情况下，则<code>必须使用 StringBuffer</code>类。</strong> </p><pre><code>public class Test{  public static void main(String args[]){    StringBuffer sBuffer = new StringBuffer("菜鸟教程官网：");    sBuffer.append("www");    sBuffer.append(".runoob");    sBuffer.append(".com");    System.out.println(sBuffer);    }}</code></pre><p>以上实例编译运行结果如下：</p><pre><code>菜鸟教程官网：www.runoob.com</code></pre><h3 id="StringBuffer-方法"><a href="#StringBuffer-方法" class="headerlink" title="StringBuffer 方法"></a>StringBuffer 方法</h3><p><a href="https://www.runoob.com/java/java-stringbuffer.html" target="_blank" rel="noopener">StringBuffer 类支持的主要方法</a></p><h2 id="Java-数组"><a href="#Java-数组" class="headerlink" title="Java 数组"></a>Java 数组</h2><p><strong>Java 语言中提供的数组是用来存储<code>固定大小</code>的<code>同类型</code>元素。</strong></p><h3 id="声明数组变量"><a href="#声明数组变量" class="headerlink" title="声明数组变量"></a>声明数组变量</h3><p><strong>首先必须<code>声明</code>数组变量，才能在程序中使用数组。</strong>下面是声明数组变量的语法：</p><pre><code>dataType[] arrayRefVar;   // 首选的方法或dataType arrayRefVar[];  // 效果相同，但不是首选方法</code></pre><p><strong>注意: 建议使用 <code>dataType[] arrayRefVar</code> 的声明风格声明数组变量。 <code>dataType arrayRefVar[]</code> 风格是来自 <code>C/C++ 语言</code> ，在Java中采用是为了<code>让 C/C++ 程序员能够快速理解java语言</code>。</strong> </p><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><p><strong>Java语言使用new操作符来<code>创建</code>数组，</strong>语法如下：</p><pre><code>arrayRefVar = new dataType[arraySize];</code></pre><p>上面的语法语句做了两件事：</p><ul><li>使用 dataType[arraySize] 创建了一个数组。</li><li><strong>把新创建的数组的<code>引用赋值</code>给变量 arrayRefVar。</strong></li></ul><p><strong>数组变量的<code>声明，和创建数组</code>可以用一条语句完成，</strong>如下所示：</p><pre><code>dataType[] arrayRefVar = new dataType[arraySize];</code></pre><p>另外，你还可以使用如下的方式创建数组。</p><pre><code>dataType[] arrayRefVar = {value0, value1, ..., valuek};</code></pre><p><strong>数组的<code>元素是通过索引访问的</code>。数组索引从 0 开始，所以索引值从 <code>0 到 arrayRefVar.length-1</code>。</strong></p><pre><code>public class TestArray {   public static void main(String[] args) {      // 数组大小      int size = 10;      // 定义数组      double[] myList = new double[size];      myList[0] = 5.6;      myList[1] = 4.5;      myList[2] = 3.3;      myList[3] = 13.2;      myList[4] = 4.0;      myList[5] = 34.33;      myList[6] = 34.0;      myList[7] = 45.45;      myList[8] = 99.993;      myList[9] = 11123;      // 计算所有元素的总和      double total = 0;      for (int i = 0; i &lt; size; i++) {         total += myList[i];      }      System.out.println("总和为： " + total);   }}</code></pre><p>以上实例输出结果为：</p><pre><code>总和为： 11367.373</code></pre><h3 id="处理数组"><a href="#处理数组" class="headerlink" title="处理数组"></a>处理数组</h3><pre><code>public class TestArray {   public static void main(String[] args) {      double[] myList = {1.9, 2.9, 3.4, 3.5};      // 打印所有数组元素      for (int i = 0; i &lt; myList.length; i++) {         System.out.println(myList[i] + " ");      }      // 计算所有元素的总和      double total = 0;      for (int i = 0; i &lt; myList.length; i++) {         total += myList[i];      }      System.out.println("Total is " + total);      // 查找最大元素      double max = myList[0];      for (int i = 1; i &lt; myList.length; i++) {         if (myList[i] &gt; max) max = myList[i];      }      System.out.println("Max is " + max);   }}</code></pre><p>以上实例编译运行结果如下：</p><pre><code>1.92.93.43.5Total is 11.7Max is 3.5</code></pre><h4 id="For-Each-循环"><a href="#For-Each-循环" class="headerlink" title="For-Each 循环"></a>For-Each 循环</h4><p>JDK 1.5 引进了一种新的循环类型，被称为<strong><code>For-Each 循环</code>或者<code>加强型循环</code></strong>，它能在不使用下标的情况下遍历数组。</p><p>语法格式如下：</p><pre><code>for(type element: array){    System.out.println(element);}</code></pre><p>实例</p><pre><code>public class TestArray {   public static void main(String[] args) {      double[] myList = {1.9, 2.9, 3.4, 3.5};      // 打印所有数组元素      for (double element: myList) {         System.out.println(element);      }   }}</code></pre><p>以上实例编译运行结果如下：</p><pre><code>1.92.93.43.5</code></pre><h3 id="数组作为函数的参数"><a href="#数组作为函数的参数" class="headerlink" title="数组作为函数的参数"></a>数组作为函数的参数</h3><p><strong>数组可以<code>作为参数传递给方法</code>。</strong></p><p>例如，下面的例子就是一个打印 int 数组中元素的方法:</p><pre><code>public static void printArray(int[] array) {  for (int i = 0; i &lt; array.length; i++) {    System.out.print(array[i] + " ");  }}</code></pre><p>下面例子调用 printArray 方法打印出 3，1，2，6，4 和 2：</p><pre><code>printArray(new int[]{3, 1, 2, 6, 4, 2}); //注意这种写法</code></pre><h3 id="数组作为函数的返回值"><a href="#数组作为函数的返回值" class="headerlink" title="数组作为函数的返回值"></a>数组作为函数的返回值</h3><pre><code>public static int[] reverse(int[] list) {  int[] result = new int[list.length];  for (int i = 0, j = result.length - 1; i &lt; list.length; i++, j--) {    result[j] = list[i];  }  return result;}</code></pre><p><strong>以上实例中 <code>result 数组</code>作为<code>函数的返回值</code>。</strong></p><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p><strong><code>多维数组</code>可以看成是<code>数组的数组</code>，比如<code>二维数组</code>就是一个<code>特殊的一维数组</code>，其<code>每一个元素</code>都是一个<code>一维数组</code></strong>，例如：</p><pre><code>String str[][] = new String[3][4];</code></pre><h4 id="多维数组的动态初始化（以二维数组为例）"><a href="#多维数组的动态初始化（以二维数组为例）" class="headerlink" title="多维数组的动态初始化（以二维数组为例）"></a>多维数组的动态初始化（以二维数组为例）</h4><p>直接为每一维分配空间，格式如下： </p><pre><code>type[][] typeName = new type[typeLength1][typeLength2];</code></pre><p><strong>type 可以为<code>基本数据类型</code>和<code>复合数据类型</code>，arraylength1 和 arraylength2 <code>必须为正整数</code>，<code>arraylength1 为行数</code>，<code>arraylength2 为列数</code>。</strong></p><p>例如：</p><pre><code>int a[][] = new int[2][3];</code></pre><p>解析：</p><p>二维数组 a 可以看成一个<strong>两行三列的数组。</strong></p><p>**从最高维开始，分别为每一维分配空间，例如： </p><pre><code>String s[][] = new String[2][];s[0] = new String[2];s[1] = new String[3];s[0][0] = new String("Good");s[0][1] = new String("Luck");s[1][0] = new String("to");s[1][1] = new String("you");s[1][2] = new String("!");</code></pre><p>解析： </p><p><strong><code>s[0]=new String[2]</code> 和 <code>s[1]=new String[3]</code> 是为最高维分配引用空间，也就是为最高维限制其能保存数据的最长的长度，然后再为其每个数组元素单独分配空间 <code>s[0][0]=new String("Good")</code> 等操作。</strong></p><h3 id="多维数组的引用（以二维数组为例）"><a href="#多维数组的引用（以二维数组为例）" class="headerlink" title="多维数组的引用（以二维数组为例）"></a>多维数组的引用（以二维数组为例）</h3><p><strong>对二维数组中的每个元素，引用方式为 <code>arrayName[index1][index2]</code></strong>，例如：</p><h3 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h3><p><strong><code>java.util.Arrays</code> 类能方便地<code>操作数组</code>，它提供的<code>所有方法都是静态</code>的。</strong></p><p>具有以下功能：</p><ul><li><strong>给数组赋值</strong>：通过 <strong>fill 方法</strong>。</li><li><strong>对数组排序</strong>：通过 <strong>sort 方法,按升序。</strong></li><li><strong>比较数组</strong>：通过 <strong>equals 方法</strong>比较数组中元素值是否相等。</li><li><strong>查找数组元素</strong>：通过 <strong><code>binarySearch 方法</code>能对<code>排序好</code>的数组进行<code>二分查找法</code></strong>操作。</li></ul><p><a href="https://www.runoob.com/java/java-array.html" target="_blank" rel="noopener">具体说明请查看</a></p><h2 id="Java-日期时间"><a href="#Java-日期时间" class="headerlink" title="Java 日期时间"></a>Java 日期时间</h2><p><strong><code>java.util 包</code>提供了 <code>Date</code> 类来封装当前的日期和时间。 Date 类提供<code>两个构造函数</code>来实例化 Date 对象。</strong></p><p><strong>第一个构造函数使用<code>当前日期和时间来初始化对象</code>。</strong></p><pre><code>Date( )</code></pre><p><strong>第二个构造函数<code>接收一个参数</code>，该参数是从<code>1970年1月1日起的毫秒数</code>。</strong> </p><pre><code>Date(long millisec)</code></pre><p>Date对象创建以后，可以调用下面的方法。</p><p><a href="https://www.runoob.com/java/java-date-time.html" target="_blank" rel="noopener">具体方法</a></p><h3 id="获取当前日期时间"><a href="#获取当前日期时间" class="headerlink" title="获取当前日期时间"></a>获取当前日期时间</h3><p>Java中获取当前日期和时间很简单，使用 <strong><code>Date 对象</code>的 <code>toString() 方法</code>来打印当前日期和时间</strong>，如下所示： </p><pre><code>import java.util.Date;public class DateDemo {   public static void main(String args[]) {       // 初始化 Date 对象       Date date = new Date();       // 使用 toString() 函数显示日期时间       System.out.println(date.toString());   }}</code></pre><p>以上实例编译运行结果如下:</p><pre><code>Wed Apr 15 20:54:19 CST 2020</code></pre><h3 id="日期比较"><a href="#日期比较" class="headerlink" title="日期比较"></a>日期比较</h3><p>Java使用以下三种方法来比较两个日期：</p><ul><li><strong>使用 <code>getTime()</code>方法获取<code>一个日期</code>（自1970年1月1日经历的毫秒数值），然后<code>比较这两个值</code>。</strong></li><li><strong>使用方法 <code>before()，after() 和 equals()</code></strong>。例如，一个月的12号比18号早，则 new Date(99, 2, 12).before(new Date (99, 2, 18)) 返回true。</li><li><strong>使用 <code>compareTo()</code>方法，它是由 Comparable 接口定义的，Date 类实现了这个接口。</strong></li></ul><h3 id="使用-SimpleDateFormat-格式化日期-重要"><a href="#使用-SimpleDateFormat-格式化日期-重要" class="headerlink" title="使用 SimpleDateFormat 格式化日期 (重要)"></a>使用 SimpleDateFormat 格式化日期 (重要)</h3><p><strong><code>SimpleDateFormat</code> 是一个以<code>语言环境</code>敏感的方式来<code>格式化和分析日期的类</code>。需要引进<code>import java.text.*;</code>包。</strong> SimpleDateFormat 允许你选择任何<code>用户自定义日期时间格式</code>来运行。**例如： </p><pre><code>import  java.util.*;import java.text.*;public class DateDemo {   public static void main(String args[]) {      Date dNow = new Date( );      SimpleDateFormat ft = new SimpleDateFormat ("yyyy-MM-dd HH:mm:ss");      System.out.println("当前时间为: " + ft.format(dNow));   }}</code></pre><p>以上实例编译运行结果如下:</p><pre><code>2020-04-15 21:53:50</code></pre><p>解析：</p><pre><code>SimpleDateFormat ft = new SimpleDateFormat ("yyyy-MM-dd hh:mm:ss");</code></pre><p><strong>这一行代码确立了转换的格式，其中 <code>yyyy</code> 是完整的<code>公元年</code>，<code>MM</code> 是<code>月份</code>，<code>dd</code> 是<code>日期</code>，<code>HH:mm:ss</code> 是<code>时、分、秒</code></strong>。</p><p><strong>注意: 有的格式大写，有的格式小写，例如 <code>MM</code> 是<code>月份</code>，<code>mm</code> 是<code>分</code>；<code>HH</code> 是 <code>24 小时制</code>，而 <code>hh</code> 是 <code>12 小时制</code>。</strong></p><h3 id="日期和时间的格式化编码"><a href="#日期和时间的格式化编码" class="headerlink" title="日期和时间的格式化编码"></a>日期和时间的格式化编码</h3><p><a href="https://www.runoob.com/java/java-date-time.html" target="_blank" rel="noopener">具体参考</a></p><h3 id="使用printf格式化日期"><a href="#使用printf格式化日期" class="headerlink" title="使用printf格式化日期"></a>使用printf格式化日期</h3><p><strong>printf 方法可以很轻松地格式化时间和日期。使用<code>两个字母格式</code>，它以 <code>%t 开头</code>并且以下面<code>表格中的一个字母结尾</code>。</strong></p><p><a href="https://www.runoob.com/java/java-date-time.html" target="_blank" rel="noopener">具体参考</a></p><p>实例</p><pre><code>import java.util.Date;public class DateDemo {  public static void main(String args[]) {     // 初始化 Date 对象     Date date = new Date();     //c的使用      System.out.printf("全部日期和时间信息：%tc%n",date);   // %n代表换行           //f的使用      System.out.printf("年-月-日格式：%tF%n",date);      //d的使用      System.out.printf("月/日/年格式：%tD%n",date);      //r的使用      System.out.printf("HH:MM:SS PM格式（12时制）：%tr%n",date);      //t的使用      System.out.printf("HH:MM:SS格式（24时制）：%tT%n",date);      //R的使用      System.out.printf("HH:MM格式（24时制）：%tR",date);    }}</code></pre><p>以上实例编译运行结果如下:</p><pre><code>全部日期和时间信息：星期一 九月 10 10:43:36 CST 2012  年-月-日格式：2012-09-10  月/日/年格式：09/10/12  HH:MM:SS PM格式（12时制）：10:43:36 上午  HH:MM:SS格式（24时制）：10:43:36  HH:MM格式（24时制）：10:43</code></pre><h3 id="Java-休眠-sleep"><a href="#Java-休眠-sleep" class="headerlink" title="Java 休眠(sleep)"></a>Java 休眠(sleep)</h3><p><strong><code>sleep()</code>使当前线程进入<code>停滞</code>状态（<code>阻塞当前线程</code>），<code>让出CPU</code>的使用、目的是<code>不让当前线程独自霸占该进程所获的CPU资源</code>，以留一定时间<code>给其他线程执行的机会</code>。</strong><br>你可以让程序休眠一毫秒的时间或者到您的计算机的寿命长的任意段时间。例如，下面的程序会休眠3秒：</p><pre><code>import java.util.*;public class SleepDemo {   public static void main(String args[]) {      try {          System.out.println(new Date( ) + "\n");          Thread.sleep(1000*3);   // Thread为线程类，休眠3秒         System.out.println(new Date( ) + "\n");       } catch (Exception e) {           System.out.println("Got an exception!");       }   }}</code></pre><p>以上实例编译运行结果如下:</p><pre><code>Thu Apr 16 19:09:58 CST 2020Thu Apr 16 19:10:01 CST 2020</code></pre><h3 id="测量时间"><a href="#测量时间" class="headerlink" title="测量时间"></a>测量时间</h3><pre><code>import java.util.*;public class DiffDemo {   public static void main(String args[]) {      try {         long start = System.currentTimeMillis( );         System.out.println(new Date( ) + "\n");         Thread.sleep(5*60*10);         System.out.println(new Date( ) + "\n");         long end = System.currentTimeMillis( );         long diff = end - start;         System.out.println("Difference is : " + diff);      } catch (Exception e) {         System.out.println("Got an exception!");      }   }}</code></pre><p>以上实例编译运行结果如下:</p><pre><code>Thu Apr 16 19:15:37 CST 2020Thu Apr 16 19:15:40 CST 2020Difference is : 3018</code></pre><h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><p>我们现在已经能够格式化并创建一个日期对象了，但是我们如何才能<strong>设置和获取日期数据的特定部分呢，比如说小时，日，或者分钟</strong>? 我们又如何<strong>在日期的这些部分加上或者减去值</strong>呢? 答案是使用Calendar 类。 </p><p><strong>Calendar类的功能要比Date类强大很多</strong>，而且在实现方式上也比Date类要复杂一些。</p><p>Calendar类是一个<strong><code>抽象类</code>，在实际使用时实现特定的子类的对象，创建对象的<code>过程对程序员来说是透明的</code>，只需要使用<code>getInstance</code>方法创建即可。</strong></p><h4 id="创建一个代表系统当前日期的Calendar对象"><a href="#创建一个代表系统当前日期的Calendar对象" class="headerlink" title="创建一个代表系统当前日期的Calendar对象"></a>创建一个代表系统<code>当前日期</code>的Calendar对象</h4><pre><code>Calendar c = Calendar.getInstance();//默认是当前日期</code></pre><h4 id="创建一个指定日期的Calendar对象"><a href="#创建一个指定日期的Calendar对象" class="headerlink" title="创建一个指定日期的Calendar对象"></a>创建一个指定日期的Calendar对象</h4><p>使用Calendar类代表特定的时间，需要首先创建一个Calendar的对象，然后再设定该对象中的年月日参数来完成。</p><pre><code>//创建一个代表2009年6月12日的Calendar对象Calendar c1 = Calendar.getInstance();c1.set(2009, 6 - 1, 12);</code></pre><h4 id="Calendar类对象字段类型"><a href="#Calendar类对象字段类型" class="headerlink" title="Calendar类对象字段类型"></a>Calendar类对象字段类型</h4><p><a href="https://www.runoob.com/java/java-date-time.html" target="_blank" rel="noopener">常量具体参考</a></p><h4 id="Calendar类对象信息的获得"><a href="#Calendar类对象信息的获得" class="headerlink" title="Calendar类对象信息的获得"></a>Calendar类对象信息的获得</h4><pre><code>Calendar c1 = Calendar.getInstance();// 获得年份int year = c1.get(Calendar.YEAR);// 获得月份int month = c1.get(Calendar.MONTH) + 1;// 获得日期int date = c1.get(Calendar.DATE);// 获得小时int hour = c1.get(Calendar.HOUR_OF_DAY);// 获得分钟int minute = c1.get(Calendar.MINUTE);// 获得秒int second = c1.get(Calendar.SECOND);// 获得星期几（注意（这个与Date类是不同的）：1代表星期日、2代表星期1、3代表星期二，以此类推）int day = c1.get(Calendar.DAY_OF_WEEK);</code></pre><h2 id="Java-正则表达式"><a href="#Java-正则表达式" class="headerlink" title="Java 正则表达式"></a>Java 正则表达式</h2><p>正则表达式<strong>定义了字符串的模式。</strong></p><p>正则表达式<strong>可以用来搜索、编辑或处理文本。</strong></p><p>正则表达式<strong>并不仅限于某一种语言，但是在每种语言中有细微的差别。</strong></p><h4 id="正则表达式实例"><a href="#正则表达式实例" class="headerlink" title="正则表达式实例"></a>正则表达式实例</h4><p>一个字符串其实就是一个简单的正则表达式，例如 Hello World 正则表达式匹配 “Hello World” 字符串。</p><p><strong>.（点号）也是一个正则表达式，它匹配<code>任何一个字符</code>如：”a” 或 “1”。</strong></p><p>下表列出了一些正则表达式的实例及描述：<br><img src="https://cdn.jsdelivr.net/gh/Kanbaraleo/imgs/images/TIM%E5%9B%BE%E7%89%8720200416204116.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建博客</title>
      <link href="/2020/04/04/hexo-github-da-jian-ge-ren-bo-ke/"/>
      <url>/2020/04/04/hexo-github-da-jian-ge-ren-bo-ke/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建博客笔记"><a href="#搭建博客笔记" class="headerlink" title="搭建博客笔记"></a>搭建博客笔记</h1><p>在B站看到github+hexo搭建个人博客的视频，一时间来了兴趣开始着手搭建。<br>此文章用于记录自己搭建的过程，也算是个小教程，内容集合了一些自己的理解和各路大神（太多，就不一一说了）的讲解。一方面方便自己以后回过头来查看。<br>另一方面想见证自己学习的过程。  </p><p><strong>GitHub page平台</strong>: GitHub是一个面向开源及私有软件项目的托管平台，因为只支持git作为唯一的版本库格式进行托管，故名GitHub.<br><strong>Github</strong>: <a href="https://github.com/" target="_blank" rel="noopener">网址</a>  </p><p><strong>Hexo</strong>: hexo是一个高效的静态网站生成框架，基于Node.js，快速，简单且功能强大，是搭建博客的首选框架。通过Hexo，你可以直接使用Markdown语法来撰写博客。<br><strong>Hexo</strong>: <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">网址</a></p><p>使用github平台上托管博客。我们可以放心写作，又不需要自购服务器域名那样定期维护，hexo作为一个快速简洁的博客框架，用它来搭建博客会非常轻松。</p><h2 id="一-搭建博客"><a href="#一-搭建博客" class="headerlink" title="一. 搭建博客"></a>一. 搭建博客</h2><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>由于Hexo是基于node.js编写的，所以要先安装node.js和里面的npm工具<strong>（Node.js打包管理工具）</strong>。<br><strong>Node.js</strong>: Node是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为与PHP、Python、Perl、Ruby 等服务端语言平起平坐的<strong>脚本语言</strong>。  </p><p><strong>Node</strong>: <a href="http://nodejs.cn/download/" target="_blank" rel="noopener">下载地址</a></p><h3 id="下载git"><a href="#下载git" class="headerlink" title="下载git"></a>下载git</h3><p>为了把本地的博客文件上传到github上面去，需要工具Git。  </p><p><strong>Git</strong>: Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者通过克隆（git clone），在本地机器上拷贝一个完整的Git仓库。</p><p><strong>git</strong>: <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">下载地址</a>  </p><p>下载后直接使用<strong>Git Bash</strong>输入命令,不需要用到cmd</p><h3 id="Git-Bash输入指令"><a href="#Git-Bash输入指令" class="headerlink" title="Git Bash输入指令"></a>Git Bash输入指令</h3><p>想对hexo 指令做更深入的了解，可以访问<a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">hexo指令网址</a></p><p>按顺序输入以后命令</p><a id="more"></a><pre><code>node -v           查看node版本，检查是否安装成功npm -v            查看npm版本，检查是否安装成功npm install -g cnpm --registry=http://registry.npm.taobao.org           安装淘宝的cnpm 管理器，阿里的国内镜像cnpm -v           查看cnpm版本，检查是否安装成功cnpm install -g hexo-cli           安装hexo博客框架hexo -v           查看hexo版本，检查是否安装成功mkdir blog        创建blog（名字自取）目录，存放博客文件cd blog           进入blog目录，此后对博客的修改基于blog目录hexo init         当前文件夹初始化-生成博客。</code></pre><p>新建完成后，我们的blog文件夹就有以下文件：</p><ul><li>node_modules: 依赖包，node.js各种库的目录</li><li>public：生成的网页文件目录</li><li>scaffolds：新文章和新页面的初始模板</li><li>source：用来存放你的文章和图片等资源文件<ul><li>_posts</li><li>assets</li></ul></li><li>themes：存放主题</li><li>_config.yml: 博客的配置文件<strong>（非常重要）</strong>  </li></ul><p>下面流程中我们在blog常用到的简单命令：  </p><ul><li><strong>hexo clean</strong>（清除缓存文件 (db.json) 和已生成的静态文件 (public)。<br>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。）</li><li><strong>hexo generate</strong>（可以简写为<strong>hexo g</strong>，生成静态文件）</li><li><strong>hexo server</strong>（可以简写为<strong>hexo s</strong>，启动服务器。默认情况下，访问网址为：<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> ）</li><li><strong>hexo deploy</strong>（可以简写为：<strong>hexo d</strong>，部署网站）</li></ul><p>了解完后，接着输入以下命令</p><pre><code>hexo server           http://localhost:4000/           默认本地访问地址hexo n "我的第一篇文章"           （名字可自取），创建新文章 返回blog目录hexo cleanhexo g</code></pre><p>打开Github，右上角+新建一个项目仓库New repository，项目命名为：<strong>Github自身用户名.github.io</strong><br>只有这样设置，将博客部署到github才会被识别</p><pre><code>cnpm install --save hexo-deployer-git         在blog目录下安装git部署插件</code></pre><h3 id="将hexo部署到GitHub"><a href="#将hexo部署到GitHub" class="headerlink" title="将hexo部署到GitHub"></a>将hexo部署到GitHub</h3><p>打开博客根目录下的_config.yml文件<strong>（博客的配置文件）</strong>，在这里你可以修改与博客配置相关的各种信息。  </p><p>修改博客最后一行</p><pre><code>deploy:  type: git  repo: https://github.com/YourGithubName/YourGithubName.github.io.git  branch: master</code></pre><p>repository改为自己github项目地址，就是部署时告诉工具，将生成网页通过git方式上传到你对应的链接仓库中。</p><pre><code>hexo cleanhexo ghexo d                                                                  注意deploy时可能要你输入username和password。https://YourGithubName.github.io/`                                      部署成功后，访问这个地址可以查看博客</code></pre><hr><h2 id="二-定制博客"><a href="#二-定制博客" class="headerlink" title="二. 定制博客"></a>二. 定制博客</h2><p>建议了解上方<strong>blog文件目录</strong>和<strong>hexo基本配置</strong>  </p><p>hexo配置文档：<a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">网址</a></p><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>hexo默认主题是lanscape，不过太显单调了。  </p><p>我们可以到github或是Hexo上下载自己喜欢的主题。</p><p>这里我推荐两个，一个是yilia，另一个则是matery。后续有较好的主题，我会继续推荐 </p><p><strong>yilia</strong>：<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">下载地址</a><br><strong>matery</strong>: <a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">下载地址</a><br><strong>next</strong>: <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">github排名第一主题，我在这里放出来</a></p><p>大家可以根据<strong>创作者放出的教程</strong>一步步安装主题，下面是一个yilia安装的示范：  </p><pre><code>git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia     通过克隆方式将yilia主题下到themes主题下的yilia目录下修改hexo根目录下的 _config.yml 文件 ：定位到 theme: yilia</code></pre><h3 id="添加404页面"><a href="#添加404页面" class="headerlink" title="添加404页面"></a>添加404页面</h3><p>原来的主题缺少404页面，我们可以自做。  </p><p>首先在/source/目录下新建一个<strong>404.md</strong>，可以用命令新建，也可以到_posts文件夹右键新建</p><pre><code>title: 404date: ''type: "404"layout: "404"description: "我崩溃了！真的！我都不知道你到底想找什么！！！"</code></pre><p>然后在/themes/matery/layout/目录下新建<strong>404.ejs</strong>文件</p><pre><code>&lt;style type="text/css"&gt;     /* don't remove. */     .about-cover {         height: 75vh;     } &lt;/style&gt; &lt;div class="bg-cover pd-header about-cover"&gt;    &lt;div class="container"&gt;         &lt;div class="row"&gt;             &lt;div class="col s10 offset-s1 m8 offset-m2 l8 offset-l2"&gt;                 &lt;div class="brand"&gt;                    &lt;div class="title center-align"&gt;                         404                     &lt;/div&gt;                     &lt;div class="description center-align"&gt;                         &lt;%= page.description %&gt;                     &lt;/div&gt;                 &lt;/div&gt;             &lt;/div&gt;         &lt;/div&gt;     &lt;/div&gt; &lt;/div&gt; &lt;script&gt;     // 每天切换 banner 图. Switch banner image every day.     $('.bg-cover').css('background-image', 'url(/medias/banner/' + new Date().getDay() + '.jpg)'); &lt;/script&gt;</code></pre><h3 id="添加live2D"><a href="#添加live2D" class="headerlink" title="添加live2D"></a>添加live2D</h3><p>大多数博客都有的看板娘<strong>(老婆)</strong>，最激动人心的环节来了~  </p><p>Live2D是一种应用于电子游戏的绘图渲染技术，由日本Cybernoids公司开发，通过一系列的连续图像和人物建模来生成一种类似二维图像的三维模型，换句话说就是2D的素材实现一定程度的3D效果，但只能是一定程度3D，因为Live 2D人物无法大幅度转身。</p><p><a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md" target="_blank" rel="noopener">详细过程</a></p><p>首先检查博客主目录下的<code>package.json</code>是否有<code>"hexo-helper-live2d": "^3.1.1"</code>依赖。<br>有的话可以先进行卸载：<code>npm uninstall hexo-helper-live2d</code>  </p><p>安装依赖：<code>npm install --save hexo-helper-live2d</code>  </p><p>成功了之后可以看到<code>blog</code>目录的<code>node_modules/</code>下有个<code>live2d-widget</code>目录，这是动画的主配置：</p><p>下载model文件，示例：<br><code>npm install live2d-widget-model-shizuku</code>,添加模型随自己挑选</p><p><a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener">模型</a></p><p>安装完成可以在<code>node_modules/</code>下看到<code>live2d-widget-model-shizuku</code>文件夹</p><p>最后，添加live2d看板娘到hexo:  </p><p>配置Hexo的<code>主_config.yml</code>或者使用的主题的<code>_config.yml</code><br>添加以下代码到配置文件中：</p><pre><code># live2dlive2d:  userConfig:   enable: true  scriptFrom: local  # pluginRootPath: live2dw/  # pluginJsPath: lib/  pluginModelPath: assets/  tagMode: false  debug: false  model:    use: live2d-widget-model-shizuku  display:    position: right    width: 200    height: 600    hOffset: 0       vOffset: -198    mobile:    show: true  react:    opacity: 1  dialog:    enable: true    hitokoto: true</code></pre><p>使用<code>hexo g</code>生成文件，<code>hexo s</code>即可在本地查看效果</p><h3 id="添加评论插件"><a href="#添加评论插件" class="headerlink" title="添加评论插件"></a>添加评论插件</h3><p>这个主题自带了gittalk、gitment、valine等评论插件，所以我们只需要去主题下的配置文件修改对应插件参数就行了。</p><p>注意：<strong>Valine</strong>评论模块，在blog目录下config.yml中。<code>appId</code>和<code>appKey</code>字段是需要自己注册登录<code>leancloud</code>官网，创建应用然后获取</p><p><a href="https://www.leancloud.cn/" target="_blank" rel="noopener">leanCloud网址</a></p><h3 id="添加博客动态标签"><a href="#添加博客动态标签" class="headerlink" title="添加博客动态标签"></a>添加博客动态标签</h3><p>原理就是给博客增加一个事件判断，如下图所示：</p><p>路径：<code>themes/matery/layout/layout.ejs</code>，在任意位置添加如下代码：</p><pre><code>&lt;script type="text/javascript"&gt;            var OriginTitile = document.title,                st;            document.addEventListener("visibilitychange", function () {                document.hidden ? (document.title = "✪ ω ✪你想捉迷藏吗", clearTimeout(st)) : (document.title =                    "ヾ(•ω•`)o找到你了！", st = setTimeout(function () {                        document.title = OriginTitile                    }, 3e3))            })&lt;/script&gt;</code></pre><hr><h2 id="三-博客优化"><a href="#三-博客优化" class="headerlink" title="三. 博客优化"></a>三. 博客优化</h2><h3 id="npm速度优化"><a href="#npm速度优化" class="headerlink" title="npm速度优化"></a>npm速度优化</h3><p>玩hexo的，肯定经常使用npm，但是npm的下载速度太慢。</p><p>前面我们提到过一次<strong>cnpm</strong>，下面介绍一下</p><ul><li>阿里的淘宝团队在国内做了个跟npm仓库一样的镜像叫cnpm。</li><li>淘宝镜像与npm官方包的同步频率目前为10分钟一次，来保证尽量与官方服务同步。</li><li>二者可以说是一样，可以说没有差别。</li></ul><p>安装cnpm命令：<br><code>npm install -g cnpm --registry=http://registry.npm.taobao.org</code></p><p>安装后，测试是否安装成功：<code>cnpm -v</code></p><p>成功后，以后都可以使用 <code>cnpm</code> 代替 <code>npm</code> 来执行命令</p><h3 id="全站CDN加速"><a href="#全站CDN加速" class="headerlink" title="全站CDN加速"></a>全站CDN加速</h3><p>CDN的全称是<strong>Content Delivery Network</strong>，即内容分发网络。</p><p>CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。</p><p>CDN的关键技术主要有内容存储和分发技术。</p><p>由于github使用国外服务器，放在Github的资源在国内加载速度比较慢，因此需要使用CDN加速来优化网站打开速度，jsDelivr + Github便是免费且好用的CDN，非常适合博客网站使用。</p><p>用法：<br><code>https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径</code></p><p>还可以配合PicGo图床上传工具的自定义域名前缀来上传图片，使用极其方便。</p><h3 id="打造稳定快速、高效免费图床"><a href="#打造稳定快速、高效免费图床" class="headerlink" title="打造稳定快速、高效免费图床"></a>打造稳定快速、高效免费图床</h3><p>本图床是基于Github的，采用jsdelivr cdn进行加速，上传工具采用的是PicGo。</p><p>新建一个GitHub仓库</p><p>在主页依次选择<code>Settings</code>-<code>Developer settings</code>-<code>Personal access tokens</code>-<code>Generate new token</code>，填写好描述，勾选<code>repo</code>（仓库权限），然后点击<code>Generate token</code>生成一个<code>Token</code>，注意这个Token只会显示一次，自己先保存下来，或者等后面配置好PicGo后再关闭此网页</p><p>配置PicGo</p><p>前往下载PicGo，安装好后开始配置Github图床</p><ul><li>设定仓库名：按照【用户名 / 图床仓库名】的格式填写</li><li>设定分支名：<code>master</code></li><li>设定Token：粘贴之前生成的<code>Token</code></li><li>指定存储路径：填写想要储存的路径，如images/，这样就会在仓库下创建一个名为 images 的文件夹，上传图片将会储存在此文件夹中</li><li>设定自定义域名：它的作用是，在图片上传后，PicGo会按照【自定义域名+储存路径+上传的图片名】的方式生成访问链接，放到粘贴板上，因为我们要使用 jsDelivr 加速访问，所以可以设置为<code>https://cdn.jsdelivr.net/gh/用户名/图床仓库名</code>，上传完毕后，我们就可以通过<code>https://cdn.jsdelivr.net/gh/用户名/图床仓库名/图片路径</code>加速访问我们的图片了</li></ul><p>配置好PicGo后，将图片拖拽到上传区，将会自动上传并复制访问链接，将链接粘贴到博文中就行了。</p><hr><p>暂且写到这里，就此收键。</p><p>To be continue…..</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> github </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown</title>
      <link href="/2020/04/02/markdown-xue-xi/"/>
      <url>/2020/04/02/markdown-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown学习"><a href="#Markdown学习" class="headerlink" title="Markdown学习"></a>Markdown学习</h1><h4 id="一-Markdown是什么"><a href="#一-Markdown是什么" class="headerlink" title="一. Markdown是什么"></a>一. Markdown是什么</h4><hr><ul><li>Markdown 是一种轻量级<strong>标记语言</strong>，它允许人们使用易读易写的纯文本格式编写文档。</li><li>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。</li><li>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</li><li>Markdown 编写的文档后缀为 <strong>.md, .markdown</strong>。</li></ul><hr><a id="more"></a><h4 id="二-使用Markdown的理由"><a href="#二-使用Markdown的理由" class="headerlink" title="二. 使用Markdown的理由"></a>二. 使用Markdown的理由</h4><ul><li>它是易读（看起来很舒服）、易写（语法简单）、易更改（纯文本）。处处体现着极简主义的影子。</li><li>兼容HTML,可以转换为HTML格式发布。</li><li>跨平台使用。</li><li>越来越多的网站支持Markdown。</li></ul><hr><h4 id="三-Markdown标题"><a href="#三-Markdown标题" class="headerlink" title="三. Markdown标题"></a>三. Markdown标题</h4><ul><li>使用 # 号标记</li></ul><ul><li>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。<pre><code># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre></li></ul><ul><li>效果如下<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6></li></ul><hr><h4 id="四-Markdown-段落"><a href="#四-Markdown-段落" class="headerlink" title="四. Markdown 段落"></a>四. Markdown 段落</h4><ul><li><p>Markdown 段落没有特殊的格式，直接编写文字就好。段落的换行是使用两个以上空格加上回车。</p></li><li><p><strong>字体</strong></p></li><li><p>Markdown 可以使用以下几种字体：</p></li></ul><pre><code>*斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___</code></pre><ul><li><strong>分隔线</strong></li><li>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</li></ul><pre><code>**** * ******- - -----------</code></pre><ul><li><p><strong>删除线</strong></p></li><li><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：</p><pre><code>RUNOOB.COMGOOGLE.COM~~BAIDU.COM~~</code></pre><p><del>baidu.com</del></p></li><li><p><strong>下划线</strong></p></li><li><p>下划线可以通过 HTML 的<code>&lt;u&gt;</code>标签来实现：</p><pre><code>&lt;u&gt;带下划线文本&lt;/u&gt;</code></pre><p><u>带下划线文本</u></p></li><li><p><strong>脚注</strong></p></li><li><p>脚注是对文本的补充说明。</p></li><li><p>Markdown 脚注的格式如下:</p><pre><code>[^要注明的文本]</code></pre></li><li><p>以下实例演示了脚注的用法：</p><pre><code>创建脚注格式类似这样 [^RUNOOB]。[^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！</code></pre></li></ul><hr><h4 id="五-Markdown-列表"><a href="#五-Markdown-列表" class="headerlink" title="五. Markdown 列表"></a>五. Markdown 列表</h4><ul><li>Markdown 支持有序列表和无序列表。</li><li>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记：</li></ul><pre><code>* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项</code></pre><ul><li>有序列表使用数字并加上 . 号来表示，如：</li></ul><pre><code>1. 第一项2. 第二项3. 第三项</code></pre><ul><li><strong>列表嵌套</strong><ul><li>列表嵌套只需在子列表中的选项添加四个空格即可：</li></ul></li></ul><pre><code>1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素</code></pre><hr><h4 id="六-Markdown-区块"><a href="#六-Markdown-区块" class="headerlink" title="六. Markdown 区块"></a>六. Markdown 区块</h4><ul><li>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号：</li><li>另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：  </li><li><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote></li></ul><hr><h4 id="七-Markdown-代码"><a href="#七-Markdown-代码" class="headerlink" title="七. Markdown 代码"></a>七. Markdown 代码</h4><ul><li>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如：<pre><code>`printf()` 函数也可以用 前后``` 包裹一段代码，并指定一种语言（也可以不指定）：</code></pre></li></ul><hr><h4 id="八-Markdown-链接"><a href="#八-Markdown-链接" class="headerlink" title="八. Markdown 链接"></a>八. Markdown 链接</h4><blockquote><p>链接使用方法如下：</p></blockquote><pre><code>[链接名称](链接地址)或者&lt;链接地址&gt;</code></pre><p>你有什么不懂的就找 <a href="https://www.baidu.com" target="_blank" rel="noopener">度娘</a></p><hr><h4 id="九-Markdown-图片"><a href="#九-Markdown-图片" class="headerlink" title="九. Markdown 图片"></a>九. Markdown 图片</h4><ul><li>Markdown 图片语法格式如下：</li></ul><pre><code>![alt 属性文本](图片地址)![alt 属性文本](图片地址 "可选标题")</code></pre><ul><li>开头一个感叹号 !</li><li>接着一个方括号，里面放上图片的替代文字</li><li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。<br><img src="http://piccn.ihuaben.com/pic/chapter/201912/0715/1575705212847-ZoV4Xu22qv_400-400.jpeg" alt="我不管，这就是兰兰！" title="这是兰兰"></li><li>Markdown 无法指定图片的高度与宽度，使用HTML标签<code>&lt;img&gt;</code></li></ul><img src="http://piccn.ihuaben.com/pic/chapter/201912/0715/1575705212847-ZoV4Xu22qv_400-400.jpeg" width="30%" title="这是缩水后的兰兰"><hr><h4 id="十-Markdown-表格"><a href="#十-Markdown-表格" class="headerlink" title="十. Markdown 表格"></a>十. Markdown 表格</h4><ul><li>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。</li><li>对齐方式 <ul><li>我们可以设置表格的对齐方式：</li><li>-: 设置内容和标题栏居右对齐。</li><li>:- 设置内容和标题栏居左对齐。</li><li>:-: 设置内容和标题栏居中对齐。</li></ul></li></ul><pre><code>| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 |</code></pre><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><hr><h4 id="十一-Markdown-高级技巧"><a href="#十一-Markdown-高级技巧" class="headerlink" title="十一. Markdown 高级技巧"></a>十一. Markdown 高级技巧</h4><ul><li><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p></li><li><p>目前支持的 HTML 元素有：<br><code>&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;</code>等</p></li><li><p>如：<br>使用 <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt;</code>重启电脑</p></li><li><p>输出结果为：<br><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> </p></li><li><p><strong>转义</strong></p></li><li><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：</p></li></ul><pre><code>\*\* 正常显示星号 \*\*</code></pre><p>** 正常显示星号 **</p><ul><li>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</li></ul><pre><code>\   反斜线`   反引号*   星号_   下划线{}  花括号[]  方括号()  小括号#   井字号+   加号-   减号.   英文句点!   感叹号</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yilia主题</title>
      <link href="/2020/04/02/hexo-yilia-zhu-ti-you-hua/"/>
      <url>/2020/04/02/hexo-yilia-zhu-ti-you-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="yilia主题优化"><a href="#yilia主题优化" class="headerlink" title="yilia主题优化"></a>yilia主题优化</h1><h4 id="查看所有文章缺失模块"><a href="#查看所有文章缺失模块" class="headerlink" title="查看所有文章缺失模块"></a>查看所有文章缺失模块</h4><ul><li>在首次使用<code>yilia</code>时，点击所有文章时会出现模块找不到的错误，根据提示复制操作<a id="more"></a></li></ul><ul><li><code>_config.yml</code>路径是指 根目录下的，而非 yilia 主题下</li></ul><hr><h4 id="配置图片资源"><a href="#配置图片资源" class="headerlink" title="配置图片资源"></a>配置图片资源</h4><ul><li>路径 <code>blog/source/</code>下，添加 <code>assets</code> 文件夹，里面存放图片</li><li>配置文件引用。路径 <code>themes/yilia/_config.yml</code> 修改配置文件中图片地址</li></ul><pre><code>#你的头像urlavatar: /assets/img/头像.jpgfavicon: /assets/img/favicon.ico</code></pre><hr><h4 id="文章只显示摘要"><a href="#文章只显示摘要" class="headerlink" title="文章只显示摘要"></a>文章只显示摘要</h4><ul><li>点击主页时，发现所有文章都是全文显示，不利于查找，可控制显示的字数</li><li>在你 MD 格式文章正文插入 <code>&lt;!-- more --&gt;</code>即可，只会显示它之前的，此后的就不显示。</li><li>点击文章标题，全文阅读才可看到</li><li>同时在<code>themes/yilia/_config.yml</code>注释掉<code>excerpt_link: more</code></li></ul><hr><h4 id="主题作者名字更改"><a href="#主题作者名字更改" class="headerlink" title="主题作者名字更改"></a>主题作者名字更改</h4><ul><li>根目录下<code>_config.yml</code>更改author字段后的内容</li></ul><pre><code>author: (你的博客名)</code></pre><ul><li>更改完重新部署</li><li>删除博客底部 Hexo Theme Yilia by Litten</li><li>在<code>blog\themes\yilia\layout\_partial\footer.ejs</code>下修改：</li></ul><pre><code>&lt;div class="footer-right"&gt;    This is Asgrad&lt;/div&gt;</code></pre><hr><h4 id="文章显示目录"><a href="#文章显示目录" class="headerlink" title="文章显示目录"></a>文章显示目录</h4><ul><li>增加文章目录<code>TOC(table of content )</code>，方便阅读文章。</li><li>在<code>themes/yilia/_config.ym</code>中配置 <code>toc: 2</code>。</li></ul><hr><h4 id="增加归档菜单"><a href="#增加归档菜单" class="headerlink" title="增加归档菜单"></a>增加归档菜单</h4><ul><li>修改 themes/yilia/_config.yml</li></ul><pre><code>menu:    主页:  /    归档:  /archives/index.html</code></pre><hr><h4 id="增加不蒜子统计"><a href="#增加不蒜子统计" class="headerlink" title="增加不蒜子统计"></a>增加不蒜子统计</h4><ul><li>统计博客的访问量</li><li><strong>安装不蒜子脚本</strong></li><li>在<code>themes\yilia\layout\_partial\after-footer.ejs</code>最后添加</li></ul><pre><code>&lt;script  async  src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;</code></pre><ul><li><strong>添加统计网站访问量</strong></li><li>修改 <code>themes\yilia\layout\_partial\footer.ejs</code>，包括访客数和站点访问总量</li><li>注意修改文件后另存编码为UTF-8</li></ul><pre><code> # PV方式，单个用户连续点击 n 篇，记录 n 次记录值&lt;span id="busuanzi_container_site_pv"&gt;    本站总访问量&lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt;次&lt;/span&gt;# UV方式，单个用户连续点击 n 篇，记录 1 次记录值&lt;span id="busuanzi_container_site_uv"&gt;  本站访客数&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;人次&lt;/span&gt;</code></pre><hr><h4 id="添加评论系统Valine"><a href="#添加评论系统Valine" class="headerlink" title="添加评论系统Valine"></a>添加评论系统Valine</h4><ul><li>登录或注册 <strong>LeanCloud</strong>, 进入控制台后点击左下角创建应用，进入刚刚创建的应用，选择左下角的<kbd>设置</kbd>&gt;<kbd>应用Key</kbd>，然后就能看到你的<code>APP ID</code>和<code>APP Key</code>了。</li><li>在<code>themes\yilia\_config.yml</code>后面添加valine设置（把<code>APP ID</code>，<code>APP KEY</code>换成自己应用中的信息）</li></ul><pre><code> #6、Valine https://valine.js.orgvaline:  appid: 'APP ID' #Leancloud中自己的appId appkey: 'APP KEY' #Leancloud应用自己的appKey verify: false #验证码 notify: false #评论回复提醒 avatar:'' // (''/mp/identicon/monsterid/wavatar/robohash/retro/hide) placeholder: Just go go #评论框占位符</code></pre><ul><li>在<code>blog\themes\yilia\layout\_partial\article.ejs</code>中<code>&lt;% if (!index &amp;&amp; post.comments){ %&gt;</code>后添加代码</li></ul><pre><code>&lt;% if (theme.valine &amp;&amp; theme.valine.appid &amp;&amp; theme.valine.appkey){ %&gt;    &lt;section id="comments" class="comments"&gt;      &lt;style&gt;        .comments{margin:30px;padding:10px;background:#fff}        @media screen and (max-width:800px){.comments{margin:auto;padding:10px;background:#fff}}      &lt;/style&gt;      &lt;%- partial('post/valine', {        key: post.slug,        title: post.title,        url: config.url+url_for(post.path)        }) %&gt;  &lt;/section&gt;&lt;% } %&gt;</code></pre><ul><li><code>blog\themes\yilia\layout\_partial\post</code>下新建文件<code>valine.ejs</code>写入代码</li></ul><pre><code>&lt;div id="vcomment" class="comment"&gt;&lt;/div&gt; &lt;script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"&gt;&lt;/script&gt;&lt;script src="//unpkg.com/valine/dist/Valine.min.js"&gt;&lt;/script&gt;&lt;script&gt;   var notify = '&lt;%= theme.valine.notify %&gt;' == true ? true : false;   var verify = '&lt;%= theme.valine.verify %&gt;' == true ? true : false;    window.onload = function() {        new Valine({            el: '.comment',            notify: notify,            verify: verify,            app_id: "&lt;%= theme.valine.appid %&gt;",            app_key: "&lt;%= theme.valine.appkey %&gt;",            placeholder: "&lt;%= theme.valine.placeholder %&gt;",            avatar:"&lt;%= theme.valine.avatar %&gt;"        });    }&lt;/script&gt;</code></pre><hr><h4 id="头像旋转功能"><a href="#头像旋转功能" class="headerlink" title="头像旋转功能"></a>头像旋转功能</h4><ul><li>在<code>blog\themes\yilia\source</code>下新建<code>avatarrotation.css</code>：</li></ul><pre><code>.left-col #header .profilepic img {    /* 控制旋转速度时间*/  -webkit-transition: -webkit-transform 1.0s ease-out;  -moz-transition: -moz-transform 1.0s ease-out;  transition: transform 1.0s ease-out;}.left-col #header .profilepic img:hover {    /* 鼠标经过360% */  -webkit-transform: rotateZ(360deg);  -moz-transform: rotateZ(360deg);  transform: rotateZ(360deg);}</code></pre><ul><li>在<code>blog\themes\yilia\layout\_partia\head.ejs</code>文件中<code>&lt;%- partial('css') %&gt;</code>下方添加代码</li></ul><pre><code>&lt;%- partial('css') %&gt;  &lt;% if (theme.avatarrotation) { %&gt;    &lt;link rel = "stylesheet" type = "text/css" href = "/avatarrotation.css"&gt;  &lt;% } %&gt;</code></pre><ul><li>在yilia的_config.yml下：</li></ul><pre><code>头像是否旋转(如果不要旋转取false)avatarrotation: true</code></pre><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> yilia </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
